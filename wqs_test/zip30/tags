!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.7	//
$	proginfo/fileinfo.cms	/^  A-Z, a-z, 0-9, and +, -, $, #, @, :, and _.  You can separate it$/;"	v
$	tags	/^to	LICENSE	\/^       limited to, labeling of the altered versions with the names "Info-ZIP"$\/;"	v	file:$/;"	v
$	win32/makefile.bor	/^	masm -ml win32\/crc_i386.asm,$@;$/;"	v
$	win32/makefile.bor	/^	masm -ml win32\/match32.asm,$@;$/;"	v
$	win32/makefile.bor	/^c0x32.obj $(OBJZ),$@,,import32.lib cw32.lib,,zip.res$/;"	v
$0	match.S	/^        adc     $0,%eax             \/* eax = carry ? len+1 : len *\/$/;"	v
$0	win32/lm32_lcc.asm	/^        adc     $0,%eax$/;"	v
$0x03	win32/crc_lcc.asm	/^	andl	$0x03,%ecx$/;"	v
$0x0f	win32/crc_lcc.asm	/^	andl	$0x0f,%ecx$/;"	v
$0xffffffff	win32/crc_lcc.asm	/^	xorl	$0xffffffff,%eax$/;"	v
$1	match.S	/^        subb    $1,%cl              \/* set carry if cl == 0 (cannot use DEC) *\/$/;"	v
$1	win32/lm32_lcc.asm	/^        subb    $1,%cl$/;"	v
$15	crc_i386.S	/^                andl    $15, %ecx         \/* ecx = len % 16   *\/$/;"	v
$16	win32/crc_lcc.asm	/^	addl	$16,%esi$/;"	v
$2	crc_i386.S	/^                shrl    $2,%ecx           \/* ecx = len \/ 4    *\/$/;"	v
$2	match.S	/^        shr     $2,%ebp                \/* chain_length >>= 2 *\/$/;"	v
$2	win32/crc_lcc.asm	/^        shrl	$2,%ecx$/;"	v
$2	win32/lm32_lcc.asm	/^        shr     $2,%ebp$/;"	v
$3	crc_i386.S	/^                andl    $3,%ecx          \/* ecx = len % 4 *\/$/;"	v
$3	win32/crc_lcc.asm	/^	testl	$3,%esi$/;"	v
$4	crc_i386.S	/^                shrl    $4, %ecx             \/* ecx = len \/ 16   *\/$/;"	v
$4	win32/crc_lcc.asm	/^	addl	$4,%esi$/;"	v
$4	win32/crc_lcc.asm	/^	shrl	$4,%ecx$/;"	v
$8	win32/crc_lcc.asm	/^	shrl	$8,%eax$/;"	v
A	amiga/deflate.a	/^; Arg 1 is scratch A, arg 2 is scratch D$/;"	v
A	human68k/deflate.s	/^; Arg 1 is scratch A, arg 2 is scratch D$/;"	v
ACCESS_SYSTEM_SECURITY	win32/rsxntwin.h	81;"	d
ACCINFO	os2/os2acl.c	/^ACCINFO;$/;"	t	typeref:struct:access_info	file:
ACCLIST	os2/os2acl.c	/^ACCLIST;$/;"	t	typeref:struct:access_list	file:
ACL	win32/rsxntwin.h	/^} ACL;$/;"	t	typeref:struct:_ACL
ACL_BUFFERSIZE	os2/os2acl.h	27;"	d
ADD	zip.c	77;"	d	file:
ADJUST_TM	timezone.c	725;"	d	file:
AFB_68020	amiga/deflate.a	/^        btst    #AFB_68020,AttnFlags+1(a0)$/;"	v
AFB_68020	amiga/match_68.a	/^        btst    #AFB_68020,AttnFlags+1(a0)$/;"	v
AFB_68020	human68k/deflate.s	/^        btst    #AFB_68020,AttnFlags+1(a0)$/;"	v
ALIAS_MASK	cmsmvs/mvs.h	30;"	d
ALIGNMENT	crc_i386.S	65;"	d	file:
ALIGNMENT	match.S	47;"	d	file:
ALL	novell/Netware.c	28;"	d	file:
AMIGA	amiga/deflate.a	/^     IFD    AMIGA               ; Amiga specific test for '020 CPU:$/;"	v
AMIGA	amiga/match_68.a	/^        IFD     AMIGA           ; Amiga specific test for '020 CPU:$/;"	v
AMIGA	human68k/deflate.s	/^     IFDEF  AMIGA               ; Amiga specific test for '020 CPU:$/;"	v
AMIGA	proginfo/ZipPorts	/^      it:  AMIGA, ATARI_ST, __human68k__, MACOS, MSDOS, MVS, OS2, TOPS20,$/;"	v
ANLEAP	amiga/filedate.c	185;"	d	file:
ANYSIZE_ARRAY	win32/rsxntwin.h	29;"	d
API	windll/example.c	18;"	d	file:
APSTUDIO_HIDDEN_SYMBOLS	windll/windll.rc	2;"	d	file:
APSTUDIO_HIDDEN_SYMBOLS	windll/windll.rc	7;"	d	file:
APSTUDIO_READONLY_SYMBOLS	windll/windll.rc	11;"	d	file:
APSTUDIO_READONLY_SYMBOLS	windll/windll.rc	1;"	d	file:
ARCHIVE	zip.c	80;"	d	file:
ARGBSIZE_UNIT	vms/cmdline.c	138;"	d	file:
ARG_FILE_ERR	fileio.c	3693;"	d	file:
ASCII	zip.h	214;"	d
ASMV	msdos/osdep.h	72;"	d
ASMV	novell/osdep.h	72;"	d
ASMV	os2/osdep.h	37;"	d
ASMV	tailor.h	168;"	d
ASMV	win32/osdep.h	308;"	d
ASM_CRC	msdos/osdep.h	87;"	d
ASM_CRC	novell/osdep.h	87;"	d
ASM_CRC	tailor.h	164;"	d
ASM_CRC	win32/osdep.h	314;"	d
ATARI_ST	proginfo/ZipPorts	/^      it:  AMIGA, ATARI_ST, __human68k__, MACOS, MSDOS, MVS, OS2, TOPS20,$/;"	v
ATH_BEO_UNX	ttyio.h	65;"	d
ATR$S_JOURNAL	vms/NOTES.TXT	367;"	d	file:
A_ARCHIVE	win32/win32.c	43;"	d	file:
A_DIR	win32/win32.c	42;"	d	file:
A_HIDDEN	win32/win32.c	39;"	d	file:
A_LABEL	win32/win32.c	41;"	d	file:
A_RONLY	win32/win32.c	38;"	d	file:
A_SYSTEM	win32/win32.c	40;"	d	file:
AceCount	win32/rsxntwin.h	/^    WORD   AceCount;$/;"	m	struct:_ACL	access:public
AclRevision	win32/rsxntwin.h	/^    BYTE  AclRevision;$/;"	m	struct:_ACL	access:public
AclSize	win32/rsxntwin.h	/^    WORD   AclSize;$/;"	m	struct:_ACL	access:public
Acorn	acorn/ReadMe	/^zip on an Acorn, and unzip on another Acorn, filetypes will be maintained$/;"	v
AdjustForTZmoveMac	macos/source/mactime.c	/^time_t AdjustForTZmoveMac(unsigned long macloctim, long s_gmtoffs)$/;"	f	signature:(unsigned long macloctim, long s_gmtoffs)
Administrators	proginfo/ntsd.txt	/^groups, like Administrators, Everyone, Network, Guests, etc.  These groups$/;"	v
Agetch	amiga/filedate.c	/^int Agetch(void)$/;"	f	signature:(void)
Align_Size	msdos/crc_i86.asm	/^        align   Align_Size              ; align destination of branch$/;"	v
Align_Size	msdos/match.asm	/^        align   Align_Size              ; align destination of branch$/;"	v
AllocMemory	api.c	/^int AllocMemory(unsigned int i, char *cmd, char *str, BOOL IncrementArgCee)$/;"	f	signature:(unsigned int i, char *cmd, char *str, BOOL IncrementArgCee)
Amiga	INSTALL	/^     wide range of systems:  Unix, VMS, MSDOS, OS\/2, NT, Amiga, Atari,$/;"	v
Amiga	amiga/crc_68.a	/^; On the Amiga, type extent is always unsigned long, not unsigned int, because$/;"	v
Amiga	human68k/crc_68.s	/^; On the Amiga, type extent is always unsigned long, not unsigned int, because$/;"	v
Amiga	macos/README.TXT	/^Amiga, Acorn RISC OS, and other systems.$/;"	v
Amiga	vms/VMS_ZIP.RNH	/^Macintosh, Amiga, and Acorn RISC OS.  It is analogous to a combination of$/;"	v
Amiga	vms/zip_cli.help	/^Atari, Macintosh, Amiga, and Acorn RISC OS.  It is analogous to a$/;"	v
AnsiToOem	win32/osdep.h	349;"	d
Ansi_Path	win32/win32.c	1005;"	d	file:
Ansi_Path	win32/win32.c	811;"	d	file:
Ansi_Path	win32/win32.c	860;"	d	file:
Ansi_Path	win32/win32.c	872;"	d	file:
Ansi_Path	win32/win32.c	897;"	d	file:
Ansi_Path	win32/win32.c	919;"	d	file:
Ansi_Path	win32/win32.c	968;"	d	file:
Ansi_Path	win32/win32.c	980;"	d	file:
April	README.CR	/^lic domain.  Zcrypt was originally written in Europe and, as of April 2000,$/;"	v
April	msdos/crc_i86.asm	/^; In March\/April 1997, the code has been revised to incorporate Rodney Brown's$/;"	v
April	windll/windll.txt	/^Last revised April 26, 2004.$/;"	v
Asian	proginfo/txtvsbin.txt	/^like Greek, Cyrillic or Asian, make extensive use of the bytes within$/;"	v
Assert	zip.h	565;"	d
Assert	zip.h	581;"	d
AssertBool	macos/ZipLib.h	105;"	d
AssertBool	macos/ZipLib.h	160;"	d
AssertBool	macos/ZipSx.h	106;"	d
AssertBool	macos/ZipSx.h	161;"	d
AssertIntRange	macos/ZipLib.h	132;"	d
AssertIntRange	macos/ZipLib.h	163;"	d
AssertIntRange	macos/ZipSx.h	133;"	d
AssertIntRange	macos/ZipSx.h	164;"	d
AssertStr	macos/ZipLib.h	109;"	d
AssertStr	macos/ZipLib.h	161;"	d
AssertStr	macos/ZipSx.h	110;"	d
AssertStr	macos/ZipSx.h	162;"	d
AssertStrNoOverlap	macos/ZipLib.h	138;"	d
AssertStrNoOverlap	macos/ZipLib.h	164;"	d
AssertStrNoOverlap	macos/ZipSx.h	139;"	d
AssertStrNoOverlap	macos/ZipSx.h	165;"	d
AssertTime	macos/ZipLib.h	122;"	d
AssertTime	macos/ZipLib.h	162;"	d
AssertTime	macos/ZipSx.h	123;"	d
AssertTime	macos/ZipSx.h	163;"	d
Assert_it	macos/ZipLib.h	159;"	d
Assert_it	macos/ZipLib.h	92;"	d
Assert_it	macos/ZipSx.h	160;"	d
Assert_it	macos/ZipSx.h	94;"	d
Atari	INSTALL	/^     wide range of systems:  Unix, VMS, MSDOS, OS\/2, NT, Amiga, Atari,$/;"	v
Atari	macos/README.TXT	/^VMS, MSDOS, OS\/2, Windows 9x, Windows NT, Atari, Macintosh,$/;"	v
Atari	vms/VMS_ZIP.RNH	/^systems, including UNIX, VMS,  MSDOS, OS\/2, Windows 9x\/NT\/XP, Minix, Atari,$/;"	v
Atari	vms/zip_cli.help	/^Atari, Macintosh, Amiga, and Acorn RISC OS.  It is analogous to a$/;"	v
Attributes	win32/rsxntwin.h	/^    DWORD Attributes;$/;"	m	struct:_LUID_AND_ATTRIBUTES	access:public
Avail	amiga/deflate.a	/^        UP_HASH d1,Avail                ; preserve d0$/;"	v
Avail	amiga/deflate.a	/^        move.b  1(Window,Strst.l),Avail ; Avail is not used in deflate_fast$/;"	v
Avail	human68k/deflate.s	/^        UP_HASH d1,Avail                ; preserve d0$/;"	v
Avail	human68k/deflate.s	/^        move.b  1(Window,Strst.l),Avail ; Avail is not used in deflate_fast$/;"	v
BC_METHOD	vms/vms_im.c	839;"	d	file:
BC_METHOD	vms/vms_im.c	842;"	d	file:
BEST	zip.h	328;"	d
BE_FILE_TYPE_NAME	beos/osdep.h	28;"	d
BFWRITE_CENTRALHEADER	zip.h	983;"	d
BFWRITE_DATA	zip.h	981;"	d
BFWRITE_HEADER	zip.h	984;"	d
BFWRITE_LOCALHEADER	zip.h	982;"	d
BIG_MEM	amiga/deflate.a	/^;    IFD     BIG_MEM      ; NOT supported -- type Pos needs to be 32 bits$/;"	v
BIG_MEM	human68k/deflate.s	/^;    IFD     BIG_MEM      ; NOT supported -- type Pos needs to be 32 bits$/;"	v
BIG_MEM	tailor.h	499;"	d
BIG_MEM	tops20/osdep.h	17;"	d
BINARY	zip.h	213;"	d
BLOCK_BYTES	vms/vms_im.c	494;"	d	file:
BLOCK_BYTES	vms/vms_pk.c	136;"	d	file:
BL_CODES	trees.c	154;"	d	file:
BM	os2/match32.asm	/^; Caution: this module works for IBM's C\/C++ compiler versions 2 and 3$/;"	v
BROKEN_FSEEK	amiga/osdep.h	93;"	d
BROKEN_FSEEK	win32/osdep.h	69;"	d
BS	proginfo/txtvsbin.txt	/^  7 (BEL), 8 (BS), 11 (VT), 12 (FF), 26 (SUB), 27 (ESC)$/;"	v
BZIP2	zip.h	331;"	d
BZ_NO_STDIO	bzip2/install.txt	/^source files, we recommend defining the C macro BZ_NO_STDIO, which$/;"	v
BackDate	macos/source/macglob.h	/^    time_t          BackDate;$/;"	m	struct:__anon17	access:public
BeOS	INSTALL	/^     BeOS, VM\/CMS, ...  You will need Unzip 5.0p1 or later (under any$/;"	v
Bflag	tandem/tanzip.c	/^  int Bflag = 0;            \/* Special formatting options for Tandem        *\/$/;"	v
Bk_UTCoffs	macos/source/macglob.h	/^    long            Bk_UTCoffs; \/* offset "local time - UTC" for BackDate *\/$/;"	m	struct:__anon17	access:public
Borland	msdos/crc_i86.asm	/^; (except Borland's __HUGE__ model), as long as the following$/;"	v
Brown	msdos/crc_i86.asm	/^; In March\/April 1997, the code has been revised to incorporate Rodney Brown's$/;"	v
Brown	win32/crc_i386.asm	/^;   Incorporated Rodney Brown's 32-bit-reads optimization as found in the$/;"	v
Brown	win32/crc_i386.asm	/^;   Incorporated Rodney Brown's additional tweaks for 32-bit-optimized CPUs$/;"	v
Buf_size	trees.c	364;"	d	file:
BumpDate	macos/source/macstuff.c	/^pascal  OSErr   BumpDate(short vRefNum,$/;"	f	signature:(short vRefNum, long dirID, ConstStr255Param name)
BytesOfData	macos/source/macglob.h	/^    unsigned long   BytesOfData;$/;"	m	struct:__anon17	access:public
C	INSTALL	/^     Supported compilers are Microsoft Visual C++, Borland C++, Watcom C\/C++,$/;"	v
C	INSTALL	/^     for Microsoft, Borland C++ and Turbo C, Watcom C\/C++ and the various$/;"	v
C	amiga/deflate.a	/^;   WSIZE      must be defined as the same number used for WSIZE in the C$/;"	v
C	human68k/deflate.s	/^;   WSIZE      must be defined as the same number used for WSIZE in the C$/;"	v
C	proginfo/infozip.who	/^Onno van der Linden     onno@simplex.nl                 NetBSD, Borland C++,$/;"	v
C	vms/install_vms.txt	/^     compilers, DEC\/Compaq\/HP C, VAX C, or GNU C.  If DEC\/Compaq\/HP C is$/;"	v
C	win32/match32.asm	/^; (Define the symbol WATCOM_DSEG to activate the specific Watcom C$/;"	v
C$$code	acorn/swiven.s	/^                AREA    |C$$code|, CODE, READONLY$/;"	v
CBSZ	cmsmvs/cmsmvs.h	120;"	d
CBSZ	msdos/osdep.h	108;"	d
CBSZ	msdos/osdep.h	112;"	d
CBSZ	msdos/osdep.h	116;"	d
CBSZ	novell/osdep.h	108;"	d
CBSZ	novell/osdep.h	112;"	d
CBSZ	novell/osdep.h	116;"	d
CBSZ	os2/osdep.h	103;"	d
CBSZ	tailor.h	448;"	d
CBSZ	tailor.h	453;"	d
CBSZ	tailor.h	458;"	d
CBSZ	tandem/tanzip.h	25;"	d
CBSZ	tops20/osdep.h	27;"	d
CC	msdos/makefile.bor	/^CC = tcc$/;"	v
CC	unix/configure	/^CC=${1-cc}$/;"	v
CC	win32/makefile.bor	/^CC = bcc32$/;"	v
CCOPTS	vms/build_zip.com	/^$!       \/[NO]OPTIMIZE.  For example, CCOPTS=\/ARCH=HOST\/OPTI=TUNE=HOST$/;"	v
CC_RMS_NAM	vms/vms.h	123;"	d
CC_RMS_NAM	vms/vms.h	86;"	d
CENATT	zipfile.c	107;"	d	file:
CENATX	zipfile.c	108;"	d	file:
CENCOM	zipfile.c	105;"	d	file:
CENCRC	zipfile.c	100;"	d	file:
CENDAT	zipfile.c	99;"	d	file:
CENDSK	zipfile.c	106;"	d	file:
CENEXT	zipfile.c	104;"	d	file:
CENFLG	zipfile.c	96;"	d	file:
CENHEAD	zip.h	141;"	d
CENHOW	zipfile.c	97;"	d	file:
CENLEN	zipfile.c	102;"	d	file:
CENNAM	zipfile.c	103;"	d	file:
CENOFF	zipfile.c	109;"	d	file:
CENSIG	zipfile.c	70;"	d	file:
CENSIZ	zipfile.c	101;"	d	file:
CENTIM	zipfile.c	98;"	d	file:
CENVEM	zipfile.c	94;"	d	file:
CENVER	zipfile.c	95;"	d	file:
CFLAGS	unix/configure	/^        CFLAGS="${CFLAGS} -DBZIP2_SUPPORT"$/;"	v
CFLAGS	unix/configure	/^      CFLAGS="${CFLAGS} -I${IZ_BZIP2} -DBZIP2_SUPPORT"$/;"	v
CFLAGS	unix/configure	/^    CFLAGS="${CFLAGS} -DASMV"$/;"	v
CFLAGS	unix/configure	/^    CFLAGS="${CFLAGS} -I${IZ_BZIP2} -DBZIP2_SUPPORT"$/;"	v
CFLAGS	unix/configure	/^    CFLAGS="${CFLAGS} -LARGE -Mel2 -DMEDIUM_MEM -DWSIZE=16384 -DNO_VOID"$/;"	v
CFLAGS	unix/configure	/^    CFLAGS="${CFLAGS} -posix"$/;"	v
CFLAGS	unix/configure	/^  CFLAGS="${CFLAGS} ${CFLAGS_OPT}"$/;"	v
CFLAGS_BZ	unix/configure	/^      CFLAGS_BZ="${CFLAGS_BZ} -DBZ_NO_STDIO"$/;"	v
CFLAGS_INCL	vms/descrip_src.mms	/^CFLAGS_INCL = \/INCLUDE = ([], [.VMS])$/;"	v
CFLAGS_OPT	unix/configure	/^        CFLAGS_OPT="$CFLAGS_OPT_TRY"$/;"	v
CFLAGS_OPT	unix/configure	/^        CFLAGS_OPT='-O3'$/;"	v
CFLAGS_OPT	unix/configure	/^    CFLAGS_OPT='-O3'$/;"	v
CFLAGS_OPT	unix/configure	/^  CFLAGS_OPT='-xO3'$/;"	v
CFLAGS_OPT_TRY	unix/configure	/^      CFLAGS_OPT_TRY="+O3 +Onolimit"$/;"	v
CHANGE_RTYPE	vms/vmsmunch.h	45;"	d
CHECKDIR	qdos/qdos.c	149;"	d	file:
CHECK_BUFFER_ALLOCATION	vms/cmdline.c	143;"	d	file:
CHECK_RAB	vms/vms_im.c	487;"	d	file:
CLEN	tailor.h	347;"	d
CLEN	tailor.h	357;"	d
CLI$_COMMA	vms/cmdline.c	/^globalvalue CLI$_COMMA;$/;"	v
CMS	INSTALL	/^     BeOS, VM\/CMS, ...  You will need Unzip 5.0p1 or later (under any$/;"	v
CMS	cmsmvs/README.CMS	/^Using ZIP and UNZIP on VM\/CMS$/;"	v
CMS	proginfo/ZipPorts	/^      with the possible exception of VM\/CMS, has a unique macro identifying$/;"	v
CMS	proginfo/fileinfo.cms	/^     the block descriptor word).  In CMS, BDWs and RDWs do not exist,$/;"	v
CMS_MVS	cmsmvs/cmsmvs.h	41;"	d
CMS_MVS	crypt.h	96;"	d
CMS_MVS	ttyio.h	71;"	d
CODE	acorn/match.s	/^                AREA    |C$$code|, CODE, READONLY$/;"	v
CODE	acorn/sendbits.s	/^        AREA    |Asm$$Code|, CODE, READONLY$/;"	v
CODE	acorn/swiven.s	/^                AREA    |C$$code|, CODE, READONLY$/;"	v
COMPILER_NAME	unix/unix.c	776;"	d	file:
COMPILER_NAME1	msdos/msdos.c	845;"	d	file:
COMPILER_NAME1	win32/win32.c	1158;"	d	file:
COMPILER_NAME2	msdos/msdos.c	853;"	d	file:
COMPILER_NAME2	win32/win32.c	1160;"	d	file:
COMPILE_DATE	msdos/msdos.c	956;"	d	file:
COMPILE_DATE	unix/unix.c	1024;"	d	file:
COMPILE_DATE	win32/win32.c	1252;"	d	file:
COMP_BLK	vms/vms_im.c	840;"	d	file:
COMP_BLK	vms/vms_im.c	843;"	d	file:
COPT	human68k/Makefile	/^COPT = -m68020-40$/;"	v
CPU020	amiga/deflate.a	/^    IFND    CPU020$/;"	v
CPU020	amiga/match_68.a	/^        IFND    CPU020$/;"	v
CPU020	human68k/deflate.s	/^    IFNDEF  CPU020$/;"	v
CPUTEST	amiga/deflate.a	/^    IFD     CPUTEST             ; now check for platform type$/;"	v
CPUTEST	amiga/match_68.a	/^        IFD     CPUTEST         ; now check for platform type$/;"	v
CPUTEST	human68k/deflate.s	/^    IFDEF   CPUTEST             ; now check for platform type$/;"	v
CP_UTF8	win32/rsxntwin.h	169;"	d
CR	proginfo/txtvsbin.txt	/^  9 (TAB), 10 (LF), 13 (CR), 20 (SPACE) to 255$/;"	v
CR	zip.h	265;"	d
CRC32	crc32.h	47;"	d
CRC32	crc32.h	51;"	d
CRC32	crc32.h	56;"	d
CRC32	crypt.c	116;"	d	file:
CRC32	crypt.c	117;"	d	file:
CRC32UPD	crc32.h	50;"	d
CRC32UPD	crc32.h	55;"	d
CRCVAL_INITIAL	zip.h	288;"	d
CRC_32_TAB	crc32.h	43;"	d
CRC_TABLE_IS_EMPTY	crc32.c	103;"	d	file:
CRC_TABLE_ONLY	msdos/crc_i86.asm	/^ifndef CRC_TABLE_ONLY$/;"	v
CRC_TABLE_ONLY	win32/crc_i386.asm	/^    IFNDEF CRC_TABLE_ONLY$/;"	v
CRC_TABLE_ONLY	zip.h	96;"	d
CRC_TBLS	crc32.c	45;"	d	file:
CRC_TBLS	crc32.c	47;"	d	file:
CRTL_CP_IS_ISO	win32/osdep.h	359;"	d
CRTL_CP_IS_ISO	win32/osdep.h	367;"	d
CRTL_CP_IS_OEM	win32/osdep.h	362;"	d
CRTL_CP_IS_OEM	win32/osdep.h	370;"	d
CRYPT	crypt.h	29;"	d
CRYPT	crypt.h	43;"	d
CRYPT	crypt.h	46;"	d
CRYPT	crypt.h	49;"	d
CRYPT	crypt.h	51;"	d
CRY_CRC_TAB	crypt.c	115;"	d	file:
CRY_CRC_TAB	crypt.c	119;"	d	file:
CR_BETA	crypt.h	60;"	d
CR_BETA_VER	crypt.h	66;"	d
CR_BETA_VER	crypt.h	69;"	d
CR_MAJORVER	crypt.h	63;"	d
CR_MINORVER	crypt.h	64;"	d
CR_RELEASE	crypt.h	71;"	d
CR_VERSION_DATE	crypt.h	67;"	d
CR_VERSION_DATE	crypt.h	70;"	d
CTL_FAC_IZ_ZIP	vms/vms.c	205;"	d	file:
CTRLZ	zip.h	266;"	d
CTXL	vms/vms_im.c	486;"	d	file:
CTXSIG	vms/vms_im.c	462;"	d	file:
CToPCpy	macos/source/helpers.c	/^unsigned char *CToPCpy(unsigned char *pstr, char *cstr)$/;"	f	signature:(unsigned char *pstr, char *cstr)
CWP	novell/Netware.c	27;"	d	file:
CWS	novell/Netware.c	25;"	d	file:
CWV	novell/Netware.c	26;"	d	file:
Chain_Length	amiga/deflate.a	/^        dbls    Chain_Length,bdo_scan$/;"	v
Chain_Length	amiga/deflate.a	/^        dbls    Chain_Length,wdo_scan$/;"	v
Chain_Length	amiga/match.a	/^        dbls    Chain_Length,do_scan$/;"	v
Chain_Length	amiga/match_68.a	/^        dbls    Chain_Length,bdo_scan$/;"	v
Chain_Length	amiga/match_68.a	/^        dbls    Chain_Length,wdo_scan$/;"	v
Chain_Length	human68k/deflate.s	/^        dbls    Chain_Length,bdo_scan$/;"	v
Chain_Length	human68k/deflate.s	/^        dbls    Chain_Length,wdo_scan$/;"	v
Chain_Length	human68k/match.s	/^        dbls    Chain_Length,do_scan$/;"	v
ChangeCreatorType	macos/source/macstuff.c	/^pascal  OSErr   ChangeCreatorType(short vRefNum,$/;"	f	signature:(short vRefNum, long dirID, ConstStr255Param name, OSType creator, OSType fileType)
ChangeNameForFAT	os2/os2zip.c	/^void ChangeNameForFAT(char *name)$/;"	f	signature:(char *name)
ChangeNameForFAT	win32/win32.c	/^void ChangeNameForFAT(char *name)$/;"	f	signature:(char *name)
CheckForSwitch	macos/source/helpers.c	/^Boolean CheckForSwitch(char *Switch, int argc, char **argv)$/;"	f	signature:(char *Switch, int argc, char **argv)
CheckMountedVolumes	macos/source/helpers.c	/^short CheckMountedVolumes(char *FullPath)$/;"	f	signature:(char *FullPath)
ClearArchiveBit	win32/win32.c	/^int ClearArchiveBit(char *name)$/;"	f	signature:(char *name)
ClearArchiveBitW	win32/win32.c	/^int ClearArchiveBitW(wchar_t *namew)$/;"	f	signature:(wchar_t *namew)
ClearIOErr_exit	amiga/amiga.c	/^void ClearIOErr_exit(int e)     \/* EXIT is defined as this *\/$/;"	f	signature:(int e)
CloseDirScan	win32/win32zip.c	/^local void CloseDirScan(d)$/;"	f
CloseDirScanW	win32/win32zip.c	/^local void CloseDirScanW(dw)$/;"	f
Code	trees.c	231;"	d	file:
CompiledWith	msdos/msdos.c	/^static ZCONST char CompiledWith[] = "Compiled with %s%s for %s%s%s.\\n\\n";$/;"	v	file:
CompiledWith	novell/Netware.c	/^static ZCONST char CompiledWith[] = "Compiled with %s%s for %s%s%s%s.\\n\\n";$/;"	v	file:
CompletePath	macos/source/getenv.c	/^static char CompletePath[NAME_MAX];$/;"	v	file:
Cr_UTCoffs	macos/source/macglob.h	/^    long            Cr_UTCoffs; \/* offset "local time - UTC" for CreatDate *\/$/;"	m	struct:__anon17	access:public
CreatDate	macos/source/macglob.h	/^    time_t          CreatDate;$/;"	m	struct:__anon17	access:public
Ctx	vms/vms_im.c	/^} Ctx, *Ctxptr;$/;"	t	typeref:struct:user_context	file:
Ctxptr	vms/vms_im.c	/^} Ctx, *Ctxptr;$/;"	t	typeref:struct:user_context	file:
Cur_Match	amiga/deflate.a	/^        add.w   Cur_Match,Cur_Match     ; assert value before doubling < 32K$/;"	v
Cur_Match	amiga/deflate.a	/^        and.l   #$0000FFFF,Cur_Match    ; upper half must be zero!$/;"	v
Cur_Match	amiga/deflate.a	/^        move.w  (Prev_Address,Cur_Match.w*2),Cur_Match  ; '020 addressing mode$/;"	v
Cur_Match	human68k/deflate.s	/^        add.w   Cur_Match,Cur_Match     ; assert value before doubling < 32K$/;"	v
Cur_Match	human68k/deflate.s	/^        and.l   #$0000FFFF,Cur_Match    ; upper half must be zero!$/;"	v
Cur_Match	human68k/deflate.s	/^        move.w  (Prev_Address,Cur_Match.w*2),Cur_Match  ; '020 addressing mode$/;"	v
CurrTextEncodingBase	macos/source/macglob.h	/^    short CurrTextEncodingBase;$/;"	m	struct:__anon17	access:public
CurrentFork	macos/source/macglob.h	/^    short       CurrentFork;$/;"	m	struct:__anon17	access:public
CurrentPath	macos/source/macglob.h	/^    char            CurrentPath[NAME_MAX];$/;"	m	struct:__anon17	access:public
D2_MAJORVER	api.h	47;"	d
D2_MINORVER	api.h	48;"	d
D2_PATCHLEVEL	api.h	49;"	d
DACL_SECURITY_INFORMATION	win32/rsxntwin.h	124;"	d
DAYSPERLYEAR	timezone.c	66;"	d	file:
DAYSPERNYEAR	timezone.c	65;"	d	file:
DAYSPERWEEK	timezone.c	64;"	d	file:
DAY_OF_YEAR	timezone.h	31;"	d
DEFCPYRT	zip.c	26;"	d	file:
DEFCPYRT	zipcloak.c	25;"	d	file:
DEFCPYRT	zipnote.c	20;"	d	file:
DEFCPYRT	zipsplit.c	20;"	d	file:
DEFINED_ONCE	api.h	76;"	d
DEFLATE	zip.h	330;"	d
DEFLAT_WORSTCASE_ADD	atheos/atheos.c	663;"	d	file:
DEFSIZ	zipsplit.c	24;"	d	file:
DEF_DEVDIR	vms/vmszip.c	571;"	d	file:
DEF_DEVDIRNAM	vms/vms.c	503;"	d	file:
DELETE	zip.c	75;"	d	file:
DESC	vms/install_vms.txt	/^          MMS \/DESC = [.VMS] CLEAN$/;"	v
DESC	vms/install_vms.txt	/^          MMS \/DESC = [.VMS] \/MACRO = LARGE=1$/;"	v
DESCRIP	vms/NOTES.TXT	/^      MMS \/DESCRIP = [.VMS] \/MACRO = ("LOCAL_UNZIP=NO_SYMLINKS=1")$/;"	v
DESCRIPTION	os2/zip.def	/^DESCRIPTION 'The world-famous zip utilities from Info-ZIP'$/;"	v
DESCRIPTION	windll/windll32.def	/^DESCRIPTION 'Windows Info-ZIP Zip DLL 3.0 by Info-ZIP, Mike White 2004'$/;"	v
DGROUP	msdos/crc_i86.asm	/^        ASSUME  DS: DGROUP, SS: DGROUP$/;"	v
DGROUP	msdos/crc_i86.asm	/^;  DGROUP. So, we load DS with DGROUP, to be safe.$/;"	v
DIAG_FLAG	vms/vms.c	649;"	d	file:
DIR	acorn/riscos.h	/^} DIR;$/;"	t	typeref:struct:__anon8
DIR	amiga/z-stat.h	/^} DIR;$/;"	t	typeref:struct:dirent
DIR	beos/beos.c	/^typedef FILE DIR;$/;"	t	file:
DIR	cmsmvs/mvs.h	/^} DIR;$/;"	t	typeref:struct:_DIR
DIR	os2/os2zip.h	/^DIR;$/;"	t	typeref:struct:_dirdesc
DIR	tandem/tandem.h	/^} DIR;$/;"	t	typeref:struct:_DIR
DIR	tops20/tops20.c	/^} DIR;$/;"	t	typeref:struct:__anon3	file:
DIR	unix/unix.c	/^typedef FILE DIR;$/;"	t	file:
DIRENT	atari/osdep.h	13;"	d
DIRENT	tops20/osdep.h	16;"	d
DIRSEP_CHR	util.c	41;"	d	file:
DIRSEP_CHR	util.c	47;"	d	file:
DIRSEP_CHR	util.c	57;"	d	file:
DIR_BUFSIZE	acorn/riscos.h	28;"	d
DIR_PAD	vms/vmszip.c	57;"	d	file:
DIR_TYPE_VER	vms/vmszip.c	51;"	d	file:
DIR_TYPE_VER_LEN	vms/vmszip.c	52;"	d	file:
DISK_DEVICE	tandem/tandem.h	94;"	d
DIST_BUFSIZE	trees.c	183;"	d	file:
DLL	INSTALL	/^  Windows DLL (WIN32):$/;"	f
DLLCOMMENT	api.h	/^typedef int (WINAPI DLLCOMMENT)(LPSTR);$/;"	t
DLLCOMMENT	windll/windll.txt	/^typedef int (WINAPI DLLCOMMENT)(LPSTR);$/;"	t	file:
DLLPASSWORD	api.h	/^typedef int (WINAPI DLLPASSWORD) (LPSTR, int, LPCSTR, LPCSTR);$/;"	t
DLLPASSWORD	windll/windll.txt	/^typedef int (WINAPI DLLPASSWORD) (LPSTR, int, LPCSTR, LPCSTR);$/;"	t	file:
DLLPRNT	api.h	/^typedef int (WINAPI DLLPRNT) (LPSTR, unsigned long);$/;"	t
DLLSERVICE	api.h	/^typedef int (WINAPI DLLSERVICE) (LPCSTR, unsigned __int64);$/;"	t
DLLSERVICE	api.h	/^typedef int (WINAPI DLLSERVICE) (LPCSTR, unsigned long);$/;"	t
DLLSERVICE	windll/windll.txt	/^typedef int (WINAPI DLLSERVICE) (LPCSTR, __int64);$/;"	t	file:
DLLSERVICE	windll/windll.txt	/^typedef int (WINAPI DLLSERVICE) (LPCSTR, unsigned long);$/;"	t	file:
DLLSERVICE_NO_INT64	api.h	/^typedef int (WINAPI DLLSERVICE_NO_INT64) (LPCSTR, unsigned long, unsigned long);$/;"	t
DLLSERVICE_NO_INT64	windll/windll.txt	/^typedef int (WINAPI DLLSERVICE_NO_INT64) (LPCSTR, unsigned long, unsigned long);$/;"	t	file:
DLLSPLIT	api.h	/^typedef int (WINAPI DLLSPLIT) (LPSTR);$/;"	t
DLLSPLIT	windll/windll.txt	/^typedef int (WINAPI DLLSPLIT) (LPSTR);$/;"	t	file:
DLL_VERSION_WARNING	windll/example.c	48;"	d	file:
DLL_WARNING	windll/example.c	45;"	d	file:
DO1	crc32.c	648;"	d	file:
DO2	crc32.c	649;"	d	file:
DO4	crc32.c	650;"	d	file:
DO8	crc32.c	651;"	d	file:
DOS	msdos/osdep.h	16;"	d
DOS	novell/osdep.h	16;"	d
DOSTIME_2038_01_18	zip.h	295;"	d
DOSTIME_MINIMUM	zip.h	294;"	d
DOS_EXTENSION	tandem/tandem.h	122;"	d
DOS_EXTENSION_STR	tandem/tandem.h	131;"	d
DOS_FLX_H68_OS2_W32	ttyio.h	59;"	d
DOS_FLX_OS2_W32	ttyio.h	53;"	d
DOS_H68_OS2_W32	crypt.h	90;"	d
DOS_H68_OS2_W32	ttyio.h	47;"	d
DOS_OS2_W32	crypt.h	84;"	d
DOS_OS2_W32	ttyio.h	41;"	d
DO_OPT16	crc32.c	673;"	d	file:
DO_OPT4	crc32.c	657;"	d	file:
DO_OPT4	crc32.c	661;"	d	file:
DO_OPT4	crc32.c	666;"	d	file:
DRIVE_CDROM	win32/rsxntwin.h	68;"	d
DRIVE_FIXED	win32/rsxntwin.h	66;"	d
DRIVE_RAMDISK	win32/rsxntwin.h	69;"	d
DRIVE_REMOTE	win32/rsxntwin.h	67;"	d
DRIVE_REMOVABLE	win32/rsxntwin.h	65;"	d
DRIVE_UNKNOWN	win32/rsxntwin.h	64;"	d
DTGetComment	macos/source/macstuff.c	/^pascal  OSErr   DTGetComment(short vRefNum,$/;"	f	signature:(short vRefNum, long dirID, ConstStr255Param name, Str255 comment)
DTOpen	macos/source/macstuff.c	/^pascal  OSErr   DTOpen(ConstStr255Param volName,$/;"	f	signature:(ConstStr255Param volName, short vRefNum, short *dtRefNum, Boolean *newDTDatabase)
DTSetComment	macos/source/macstuff.c	/^pascal  OSErr   DTSetComment(short vRefNum,$/;"	f	signature:(short vRefNum, long dirID, ConstStr255Param name, ConstStr255Param comment)
DWORD	win32/gvmat64.asm	/^COMM    match_start:DWORD$/;"	v
DWORD	win32/gvmat64.asm	/^COMM    prev_length:DWORD ; PrevLen$/;"	v
DW_MAJORVER	revision.h	27;"	d
DW_MINORVER	revision.h	28;"	d
DW_PATCHLEVEL	revision.h	29;"	d
DYN_ALLOC	amiga/osdep.h	58;"	d
DYN_ALLOC	msdos/osdep.h	98;"	d
DYN_ALLOC	novell/osdep.h	98;"	d
DYN_ALLOC	os2/osdep.h	65;"	d
DYN_ALLOC	tailor.h	503;"	d
DYN_TREES	trees.c	169;"	d	file:
D_CODES	trees.c	151;"	d	file:
D_curpos	cmsmvs/mvs.h	/^   struct  dirent *D_curpos;$/;"	m	struct:_DIR	typeref:struct:_DIR::dirent	access:public
D_curpos	tandem/tandem.h	/^   struct  dirent *D_curpos;$/;"	m	struct:_DIR	typeref:struct:_DIR::dirent	access:public
D_list	cmsmvs/mvs.h	/^   struct  dirent *D_list;$/;"	m	struct:_DIR	typeref:struct:_DIR::dirent	access:public
D_list	tandem/tandem.h	/^   struct  dirent *D_list;$/;"	m	struct:_DIR	typeref:struct:_DIR::dirent	access:public
D_path	cmsmvs/mvs.h	/^   char            D_path[FILENAME_MAX];$/;"	m	struct:_DIR	access:public
D_path	tandem/tandem.h	/^   char            D_path[NAMELEN+1];$/;"	m	struct:_DIR	access:public
Dad	trees.c	232;"	d	file:
DataFork	macos/source/macglob.h	19;"	d
DataFork	macos/source/pathname.h	56;"	d
DataForkOnly	macos/source/macglob.h	/^    Boolean         DataForkOnly;$/;"	m	struct:__anon17	access:public
DataSize	msdos/crc_i86.asm	/^if @DataSize$/;"	v
Date	api.h	/^LPSTR Date;             \/* Date to include after *\/$/;"	m	struct:__anon30	access:public
Date	windll/windll.txt	/^LPSTR Date;             \/* Date to include after *\/$/;"	m	struct:__anon18	file:	access:public
DaylightSaving	macos/source/mactime.c	/^static Boolean DaylightSaving(void)$/;"	f	file:	signature:(void)
DebugMalloc	os2/os2zip.c	/^void DebugMalloc(void)$/;"	f	signature:(void)
December	msdos/crc_i86.asm	/^; In December 1998, the loop branch commands were changed from "loop dest"$/;"	v
DetermineVRefNum	macos/source/macstuff.c	/^pascal  OSErr   DetermineVRefNum(ConstStr255Param pathname,$/;"	f	signature:(ConstStr255Param pathname, short vRefNum, short *realVRefNum)
DevDesc	ttyio.c	/^static struct dsc$descriptor_s DevDesc =$/;"	v	typeref:struct:dsc$descriptor_s	file:
DirLevels	macos/source/recurse.c	/^static unsigned long    DirLevels = 0;$/;"	v	file:
DisplayNumString	util.c	/^int DisplayNumString(file, i)$/;"	f
DllMain	windll/windll.c	/^BOOL WINAPI DllMain( HINSTANCE hInstance,$/;"	f	signature:( HINSTANCE hInstance, DWORD dwReason, LPVOID plvReserved)
DllMain	windll/windll.c	28;"	d	file:
DoWarnUserDupVol	macos/source/helpers.c	/^void DoWarnUserDupVol( char *FullPath )$/;"	f	signature:( char *FullPath )
Do_CRC	crc_i386.S	120;"	d	file:
Do_CRC	win32/crc_i386.asm	/^                Do_CRC                         ; c = (c >> 8) ^ table[c & 0xFF]$/;"	v
Do_CRC	win32/crc_i386.c	118;"	d	file:
Do_CRC	win32/crc_i386.c	123;"	d	file:
Do_CRC_4dword	win32/crc_i386.c	183;"	d	file:
Do_CRC_4lword	crc_i386.S	186;"	d	file:
Do_CRC_byte	crc_i386.S	131;"	d	file:
Do_CRC_byte	win32/crc_i386.c	129;"	d	file:
Do_CRC_byteof	crc_i386.S	136;"	d	file:
Do_CRC_byteof	win32/crc_i386.c	134;"	d	file:
Do_CRC_dword	win32/crc_i386.c	179;"	d	file:
Do_CRC_lword	crc_i386.S	183;"	d	file:
DosEnumAttribute	os2/os2zip.c	59;"	d	file:
DosFindFirst	os2/os2zip.c	47;"	d	file:
DosFindFirst	os2/os2zip.c	61;"	d	file:
DosMapCase	os2/os2zip.c	63;"	d	file:
DosQueryCurrentDir	os2/os2acl.c	192;"	d	file:
DosQueryCurrentDisk	os2/os2acl.c	193;"	d	file:
DosQueryCurrentDisk	os2/os2zip.c	50;"	d	file:
DosQueryFSAttach	os2/os2zip.c	51;"	d	file:
DosQueryFSInfo	os2/os2zip.c	53;"	d	file:
DosQueryPathInfo	os2/os2zip.c	55;"	d	file:
DosQueryProcAddr	os2/os2acl.c	190;"	d	file:
DosSetPathInfo	os2/os2zip.c	57;"	d	file:
DummyComment	windll/example.c	/^int WINAPI DummyComment(char far *szBuf)$/;"	f	signature:(char far *szBuf)
DummyPassword	windll/example.c	/^int WINAPI DummyPassword(LPSTR p, int n, LPCSTR m, LPCSTR name)$/;"	f	signature:(LPSTR p, int n, LPCSTR m, LPCSTR name)
DummyPrint	windll/example.c	/^int WINAPI DummyPrint(char far *buf, unsigned long size)$/;"	f	signature:(char far *buf, unsigned long size)
DuplicVolumeNote	macos/source/VolWarn.h	/^static char DuplicVolumeNote[] = {$/;"	v
EAID	win32/win32.c	46;"	d	file:
EBCDIC	cmsmvs/cmsmvs.h	42;"	d
EB_AT_FL_BADBITS	atheos/osdep.h	23;"	d
EB_AT_FL_NATURAL	atheos/osdep.h	22;"	d
EB_BE_FL_BADBITS	beos/osdep.h	21;"	d
EB_BE_FL_NATURAL	beos/osdep.h	20;"	d
EB_C_AT_LEN	atheos/osdep.h	20;"	d
EB_C_AT_SIZE	atheos/atheos.c	660;"	d	file:
EB_C_BE_LEN	beos/osdep.h	18;"	d
EB_C_BE_SIZE	beos/beos.c	673;"	d	file:
EB_C_JLEE_LEN	macos/source/extrafld.c	68;"	d	file:
EB_C_JLEE_SIZE	macos/source/extrafld.c	71;"	d	file:
EB_C_MAC3_SIZE	macos/source/extrafld.c	41;"	d	file:
EB_C_UT_SIZE	atheos/atheos.c	503;"	d	file:
EB_C_UT_SIZE	beos/beos.c	516;"	d	file:
EB_C_UT_SIZE	macos/source/extrafld.c	58;"	d	file:
EB_C_UT_SIZE	qdos/qdos.c	687;"	d	file:
EB_C_UT_SIZE	tandem/tanzip.c	617;"	d	file:
EB_C_UT_SIZE	unix/unix.c	592;"	d	file:
EB_C_UT_SIZE	win32/win32zip.c	1878;"	d	file:
EB_C_UX2_SIZE	atheos/atheos.c	588;"	d	file:
EB_C_UX2_SIZE	beos/beos.c	601;"	d	file:
EB_C_UX2_SIZE	qdos/qdos.c	691;"	d	file:
EB_C_UX2_SIZE	tandem/tanzip.c	619;"	d	file:
EB_C_UX2_SIZE	unix/unix.c	613;"	d	file:
EB_DEFLAT_EXTRA	zip.h	240;"	d
EB_HEADSIZE	vms/vms.h	160;"	d
EB_HEADSIZE	zip.h	236;"	d
EB_ID	zip.h	237;"	d
EB_IZVMS_BC00	vms/vms.h	183;"	d
EB_IZVMS_BCDEFL	vms/vms.h	186;"	d
EB_IZVMS_BCMASK	vms/vms.h	177;"	d
EB_IZVMS_BCSTOR	vms/vms.h	180;"	d
EB_LEN	zip.h	238;"	d
EB_L_AT_LEN	atheos/osdep.h	19;"	d
EB_L_AT_SIZE	atheos/atheos.c	659;"	d	file:
EB_L_BE_LEN	beos/osdep.h	17;"	d
EB_L_BE_SIZE	beos/beos.c	672;"	d	file:
EB_L_JLEE_LEN	macos/source/extrafld.c	67;"	d	file:
EB_L_JLEE_SIZE	macos/source/extrafld.c	70;"	d	file:
EB_L_MAC3_FINFO_LEN	macos/source/extrafld.c	36;"	d	file:
EB_L_MAC3_SIZE	macos/source/extrafld.c	40;"	d	file:
EB_L_THSIZE	theos/theos.c	486;"	d	file:
EB_L_TH_SIZE	theos/theos.c	487;"	d	file:
EB_L_UT_SIZE	atheos/atheos.c	502;"	d	file:
EB_L_UT_SIZE	beos/beos.c	515;"	d	file:
EB_L_UT_SIZE	macos/source/extrafld.c	57;"	d	file:
EB_L_UT_SIZE	qdos/qdos.c	686;"	d	file:
EB_L_UT_SIZE	tandem/tanzip.c	616;"	d	file:
EB_L_UT_SIZE	unix/unix.c	591;"	d	file:
EB_L_UT_SIZE	win32/win32zip.c	1877;"	d	file:
EB_L_UX2_SIZE	atheos/atheos.c	587;"	d	file:
EB_L_UX2_SIZE	beos/beos.c	600;"	d	file:
EB_L_UX2_SIZE	qdos/qdos.c	690;"	d	file:
EB_L_UX2_SIZE	tandem/tanzip.c	618;"	d	file:
EB_L_UX2_SIZE	unix/unix.c	612;"	d	file:
EB_M3_FL_COMPRESS	macos/source/extrafld.c	49;"	d	file:
EB_M3_FL_DATFRK	macos/source/extrafld.c	50;"	d	file:
EB_M3_FL_NOCHANGE	macos/source/extrafld.c	51;"	d	file:
EB_M3_FL_NOUTC	macos/source/extrafld.c	54;"	d	file:
EB_M3_FL_TIME64	macos/source/extrafld.c	53;"	d	file:
EB_M3_FL_UNCMPR	macos/source/extrafld.c	52;"	d	file:
EB_MAC3_HLEN	macos/source/extrafld.c	35;"	d	file:
EB_MAX_OF_VARDATA	macos/source/extrafld.c	38;"	d	file:
EB_MEMCMPR_HSIZ	zip.h	239;"	d
EB_SPARK_LEN	acorn/acornzip.c	490;"	d	file:
EB_SPARK_SIZE	acorn/acornzip.c	491;"	d	file:
EB_TANDEM_SIZE	tandem/tanzip.c	607;"	d	file:
EB_UTTIME_SIZE	acorn/acornzip.c	494;"	d	file:
EB_UT_FLAGS	zip.h	251;"	d
EB_UT_FL_ATIME	zip.h	254;"	d
EB_UT_FL_CTIME	zip.h	255;"	d
EB_UT_FL_MTIME	zip.h	253;"	d
EB_UT_LEN	zip.h	256;"	d
EB_UT_MINLEN	zip.h	250;"	d
EB_UT_TIME1	zip.h	252;"	d
EB_UX2_GID	zip.h	260;"	d
EB_UX2_MINLEN	zip.h	258;"	d
EB_UX2_UID	zip.h	259;"	d
EB_UX2_VALID	zip.h	261;"	d
EB_UX_ATIME	zip.h	243;"	d
EB_UX_FULLSIZE	zip.h	246;"	d
EB_UX_GID	zip.h	248;"	d
EB_UX_MINLEN	zip.h	242;"	d
EB_UX_MTIME	zip.h	244;"	d
EB_UX_UID	zip.h	247;"	d
EB_header	vms/vms.h	/^struct EB_header    \/* Common header of extra block *\/$/;"	s
EB_header::data	vms/vms.h	/^    uch data[1];$/;"	m	struct:EB_header	access:public
EB_header::size	vms/vms.h	/^    ush size;$/;"	m	struct:EB_header	access:public
EB_header::tag	vms/vms.h	/^{   ush tag;$/;"	m	struct:EB_header	access:public
EC64LOC	zip.h	143;"	d
EC64REC	zip.h	144;"	d
ECHO_MODE	tandem/tandem.c	418;"	d	file:
EFHEADER	os2/os2zip.c	/^EFHEADER, *PEFHEADER;$/;"	t	typeref:struct:__anon13	file:
EF_ACL	zip.h	224;"	d
EF_AOSVS	zip.h	229;"	d
EF_ATHEOS	zip.h	227;"	d
EF_BEOS	zip.h	226;"	d
EF_C_UNIX_SIZE	tandem/tanzip.c	621;"	d	file:
EF_C_UNIX_SIZE	unix/unix.c	615;"	d	file:
EF_C_UT_UX2_SIZE	qdos/qdos.c	693;"	d	file:
EF_C_UT_UX2_SIZE	qdos/qdos.c	696;"	d	file:
EF_IZUNIX	zip.h	220;"	d
EF_IZUNIX2	zip.h	221;"	d
EF_L_UNIX_SIZE	tandem/tanzip.c	620;"	d	file:
EF_L_UNIX_SIZE	unix/unix.c	614;"	d	file:
EF_L_UT_UX2_SIZE	qdos/qdos.c	692;"	d	file:
EF_L_UT_UX2_SIZE	qdos/qdos.c	695;"	d	file:
EF_MVS	zip.h	219;"	d
EF_NTSD	zip.h	225;"	d
EF_NTSD_C_HEADER	win32/nt.h	/^EF_NTSD_C_HEADER, *PEF_NTSD_C_HEADER;$/;"	t	typeref:struct:__anon4
EF_NTSD_C_LEN	win32/nt.h	27;"	d
EF_NTSD_L_HEADER	win32/nt.h	/^IZ_PACKED EF_NTSD_L_HEADER, *PEF_NTSD_L_HEADER;$/;"	t	typeref:struct:__anon5
EF_NTSD_L_LEN	win32/nt.h	50;"	d
EF_NTSD_MAX_VER_SUPPORT	win32/nt.h	16;"	d
EF_OS2EA	zip.h	223;"	d
EF_QDOS	zip.h	228;"	d
EF_SIZE_MAX	zip.h	235;"	d
EF_SPARK	zip.h	230;"	d
EF_SPARK_TOTALSIZE	acorn/acornzip.c	501;"	d	file:
EF_TANDEM	zip.h	232;"	d
EF_TANDEM_SIZE	tandem/tanzip.c	608;"	d	file:
EF_THEOS	zip.h	231;"	d
EF_TIME	zip.h	222;"	d
EF_VMCMS	zip.h	218;"	d
EINVAL	macos/source/unixlike.h	61;"	d
ELSE	amiga/deflate.a	/^    ELSE    ; !AMIGA$/;"	v
ELSE	amiga/deflate.a	/^    ELSE    ; !DYN_ALLOC$/;"	v
ELSE	human68k/deflate.s	/^    ELSE    ; !DYN_ALLOC$/;"	v
ELSE	win32/crc_i386.asm	/^    ELSE  ; NO_STD_STACKFRAME$/;"	v
ELSE	win32/crc_i386.asm	/^    ELSE ; __686 : optimize for Pentium Pro, Pentium II and compatible CPUs$/;"	v
ENAMETOOLONG	macos/source/unixlike.h	62;"	d
ENDBEG	zipfile.c	113;"	d	file:
ENDC	amiga/deflate.a	/^    ENDC    ; ?DYN_ALLOC$/;"	v
ENDC	amiga/deflate.a	/^    ENDC    ; CPUTEST$/;"	v
ENDC	amiga/deflate.a	/^    ENDC    ; DEBUG$/;"	v
ENDC	amiga/deflate.a	/^    ENDC    ; DYN_ALLOC$/;"	v
ENDC	amiga/deflate.a	/^    ENDC$/;"	v
ENDC	amiga/match_68.a	/^        ENDC ; AMIGA$/;"	v
ENDC	amiga/match_68.a	/^        ENDC ; CPUTEST$/;"	v
ENDC	amiga/match_68.a	/^        ENDC$/;"	v
ENDC	human68k/deflate.s	/^    ENDC    ; !CPU000$/;"	v
ENDC	human68k/deflate.s	/^    ENDC    ; ?DYN_ALLOC$/;"	v
ENDC	human68k/deflate.s	/^    ENDC    ; CPUTEST$/;"	v
ENDC	human68k/deflate.s	/^    ENDC$/;"	v
ENDCOM	zipfile.c	118;"	d	file:
ENDDSK	zipfile.c	112;"	d	file:
ENDHEAD	zip.h	142;"	d
ENDIF	win32/crc_i386.asm	/^    ENDIF ; ?NO_STD_STACKFRAME$/;"	v
ENDIF	win32/crc_i386.asm	/^    ENDIF ; ?__686$/;"	v
ENDIF	win32/gvmat64.asm	/^ENDIF$/;"	v
ENDM	amiga/deflate.a	/^        ENDM$/;"	v
ENDM	msdos/crc_i86.asm	/^        ENDM$/;"	v
ENDOFF	zipfile.c	117;"	d	file:
ENDSIG	zipfile.c	71;"	d	file:
ENDSIZ	zipfile.c	116;"	d	file:
ENDSUB	zipfile.c	114;"	d	file:
ENDTOT	zipfile.c	115;"	d	file:
END_BLOCK	trees.c	145;"	d	file:
ENVSIZE	amiga/filedate.c	166;"	d	file:
EOF	WHATSNEW	/^- On VMS, changed -V (\/VMS) processing to truncate file at EOF, allowing$/;"	v
EOSERR	amiga/filedate.c	131;"	d	file:
EPOCH_WDAY	timezone.c	71;"	d	file:
EPOCH_YEAR	timezone.c	72;"	d	file:
EQU	msdos/crc_i86.asm	/^        Alig_PARA        EQU    1       ; paragraph aligned code segment$/;"	v
EQU	msdos/crc_i86.asm	/^        Alig_PARA       EQU     0       ; word aligned code segment$/;"	v
EQU	msdos/crc_i86.asm	/^        Alig_PARA       EQU     1       ; paragraph aligned code segment$/;"	v
EQU	msdos/crc_i86.asm	/^        Align_Size       EQU    4       ; dword alignment on 32 bit processors$/;"	v
EQU	msdos/crc_i86.asm	/^        Align_Size      EQU     2       ; word alignment on 16 bit processors$/;"	v
EQU	msdos/crc_i86.asm	/^        Align_Size      EQU     4       ; dword alignment on 32 bit processors$/;"	v
EQU	msdos/crc_i86.asm	/^        Align_Size      EQU     4       ; dword alignment on Pentium II\/III\/IV$/;"	v
EQU	msdos/crc_i86.asm	/^        Align_Size      EQU     4       ; dword alignment on Pentium$/;"	v
EQU	msdos/match.asm	/^        Alig_PARA       EQU     0       ; word aligned code segment$/;"	v
EQU	msdos/match.asm	/^        Alig_PARA       EQU     1       ; paragraph aligned code segment$/;"	v
EQU	msdos/match.asm	/^        Align_Size      EQU     16      ; paragraph alignment on Pentium$/;"	v
EQU	msdos/match.asm	/^        Align_Size      EQU     2       ; word alignment on 16 bit processors$/;"	v
EQU	msdos/match.asm	/^        Align_Size      EQU     4       ; dword alignment on 32 bit processors$/;"	v
EQUAL	deflate.c	253;"	d	file:
ERR	vms/vms.c	92;"	d	file:
ERR	vms/vms.h	42;"	d
ERR	vms/vms_pk.c	85;"	d	file:
ERROR_INSUFFICIENT_BUFFER	win32/rsxntwin.h	77;"	d
ERROR_SUCCESS	win32/rsxntwin.h	76;"	d
ESRCH	amiga/filedate.c	130;"	d	file:
EXCLUDE	vms/zip_cli.cld	/^	Qualifier	EXCLUDE, NonNegatable, VALUE(required,list)$/;"	v
EXDEV	fileio.c	34;"	d	file:
EXDEV	macos/osdep.h	58;"	d
EXDEV	theos/_rename.c	14;"	d	file:
EXDEV	theos/osdep.h	58;"	d
EXIT	amiga/osdep.h	37;"	d
EXIT	tailor.h	865;"	d
EXIT	tandem/tandem.h	65;"	d
EXIT	vms/osdep.h	138;"	d
EXPENTRY	api.h	72;"	d
EXPENTRY	windll/example.h	24;"	d
EXTBSL	vms/vms.h	241;"	d
EXTCRC	zipfile.c	89;"	d	file:
EXTENSION_MAX	tandem/tandem.h	62;"	d
EXTHL	vms/vms.h	243;"	d
EXTL0	vms/vms_im.c	69;"	d	file:
EXTLEN	zipfile.c	91;"	d	file:
EXTLOCSIG	zipfile.c	72;"	d	file:
EXTRALEN	qdos/qdos.c	103;"	d	file:
EXTSIZ	zipfile.c	90;"	d	file:
Echon	ttyio.c	/^void Echon(__G)$/;"	f
EnviromentPair	macos/source/getenv.c	/^} EnviromentPair;$/;"	t	typeref:struct:_EnviromentPair	file:
EstimateCompletionTime	macos/source/macos.c	/^static long EstimateCompletionTime(const long progressMax,$/;"	f	file:	signature:(const long progressMax, const long progressSoFar, unsigned char curr_percent)
Everyone	proginfo/ntsd.txt	/^groups, like Administrators, Everyone, Network, Guests, etc.  These groups$/;"	v
ExcludeList	api.h	/^char **ExcludeList;     \/* Pointer to exclude file list array. Note that the last$/;"	m	struct:__anon30	access:public
ExcludeList	windll/windll.txt	/^char **ExcludeList;     \/* Pointer to exclude file list array. Note that the last$/;"	m	struct:__anon18	file:	access:public
ExcludeListCount	api.h	/^long ExcludeListCount;  \/* Count of file names in the include list array *\/$/;"	m	struct:__anon30	access:public
ExcludeListCount	windll/windll.txt	/^long ExcludeListCount;  \/* Count of file names in the include list array *\/$/;"	m	struct:__anon18	file:	access:public
Ext_ASCII_TO_Native	win32/osdep.h	424;"	d
FABL	vms/vms.h	232;"	d
FABSIG	vms/vms.h	218;"	d
FAB_NAM	vms/vms.h	124;"	d
FAB_NAM	vms/vms.h	87;"	d
FAB_OR_NAML	vms/vms.h	117;"	d
FAB_OR_NAML	vms/vms.h	80;"	d
FAB_OR_NAML_DNA	vms/vms.h	118;"	d
FAB_OR_NAML_DNA	vms/vms.h	81;"	d
FAB_OR_NAML_DNS	vms/vms.h	119;"	d
FAB_OR_NAML_DNS	vms/vms.h	82;"	d
FAB_OR_NAML_FNA	vms/vms.h	120;"	d
FAB_OR_NAML_FNA	vms/vms.h	83;"	d
FAB_OR_NAML_FNS	vms/vms.h	121;"	d
FAB_OR_NAML_FNS	vms/vms.h	84;"	d
FAC_IZ_ZIP	vms/vms.c	199;"	d	file:
FAILURE	amiga/filedate.c	162;"	d	file:
FAILURE	amiga/stat.c	47;"	d	file:
FALSE	crypt.c	40;"	d	file:
FALSE	tailor.h	303;"	d
FALSE	tops20/tops20.c	23;"	d	file:
FAST	deflate.c	107;"	d	file:
FAT$C_DIRECT	vms/vmsdefs.h	103;"	d
FAT$C_FIXED	vms/vmsdefs.h	92;"	d
FAT$C_INDEXED	vms/vmsdefs.h	102;"	d
FAT$C_LENGTH	vms/vmsdefs.h	78;"	d
FAT$C_RELATIVE	vms/vmsdefs.h	101;"	d
FAT$C_SEQUENTIAL	vms/vmsdefs.h	100;"	d
FAT$C_STREAM	vms/vmsdefs.h	95;"	d
FAT$C_STREAMCR	vms/vmsdefs.h	97;"	d
FAT$C_STREAMLF	vms/vmsdefs.h	96;"	d
FAT$C_UNDEFINED	vms/vmsdefs.h	91;"	d
FAT$C_VARIABLE	vms/vmsdefs.h	93;"	d
FAT$C_VFC	vms/vmsdefs.h	94;"	d
FAT$K_LENGTH	vms/vmsdefs.h	77;"	d
FAT$M_FORTRANCC	vms/vmsdefs.h	115;"	d
FAT$M_IMPLIEDCC	vms/vmsdefs.h	117;"	d
FAT$M_MSBRCW	vms/vmsdefs.h	123;"	d
FAT$M_NOSPAN	vms/vmsdefs.h	121;"	d
FAT$M_PRINTCC	vms/vmsdefs.h	119;"	d
FAT$S_FATDEF	vms/vmsdefs.h	79;"	d
FAT$S_FILEORG	vms/vmsdefs.h	98;"	d
FAT$S_RTYPE	vms/vmsdefs.h	89;"	d
FAT$V_FILEORG	vms/vmsdefs.h	99;"	d
FAT$V_FORTRANCC	vms/vmsdefs.h	114;"	d
FAT$V_IMPLIEDCC	vms/vmsdefs.h	116;"	d
FAT$V_MSBRCW	vms/vmsdefs.h	122;"	d
FAT$V_NOSPAN	vms/vmsdefs.h	120;"	d
FAT$V_PRINTCC	vms/vmsdefs.h	118;"	d
FAT$V_RTYPE	vms/vmsdefs.h	90;"	d
FATTR	msdos/msdos.c	20;"	d	file:
FATTR	msdos/msdos.c	36;"	d	file:
FATTR	msdos/msdos.c	61;"	d	file:
FA_LABEL	msdos/msdos.c	38;"	d	file:
FA_LABEL	msdos/msdos.c	62;"	d	file:
FBBSZ_M	tops20/tops20.c	480;"	d	file:
FBBSZ_S	tops20/tops20.c	479;"	d	file:
FCH$M_BADACL	vms/vmsdefs.h	183;"	d
FCH$M_BADBLOCK	vms/vmsdefs.h	185;"	d
FCH$M_CONTIG	vms/vmsdefs.h	187;"	d
FCH$M_CONTIGB	vms/vmsdefs.h	189;"	d
FCH$M_DIRECTORY	vms/vmsdefs.h	191;"	d
FCH$M_ERASE	vms/vmsdefs.h	193;"	d
FCH$M_LOCKED	vms/vmsdefs.h	195;"	d
FCH$M_MARKDEL	vms/vmsdefs.h	197;"	d
FCH$M_NOBACKUP	vms/vmsdefs.h	199;"	d
FCH$M_NOCHARGE	vms/vmsdefs.h	201;"	d
FCH$M_READCHECK	vms/vmsdefs.h	203;"	d
FCH$M_SPOOL	vms/vmsdefs.h	205;"	d
FCH$M_WRITCHECK	vms/vmsdefs.h	207;"	d
FCH$M_WRITEBACK	vms/vmsdefs.h	209;"	d
FCH$V_BADACL	vms/vmsdefs.h	182;"	d
FCH$V_BADBLOCK	vms/vmsdefs.h	184;"	d
FCH$V_CONTIG	vms/vmsdefs.h	186;"	d
FCH$V_CONTIGB	vms/vmsdefs.h	188;"	d
FCH$V_DIRECTORY	vms/vmsdefs.h	190;"	d
FCH$V_ERASE	vms/vmsdefs.h	192;"	d
FCH$V_LOCKED	vms/vmsdefs.h	194;"	d
FCH$V_MARKDEL	vms/vmsdefs.h	196;"	d
FCH$V_NOBACKUP	vms/vmsdefs.h	198;"	d
FCH$V_NOCHARGE	vms/vmsdefs.h	200;"	d
FCH$V_READCHECK	vms/vmsdefs.h	202;"	d
FCH$V_SPOOL	vms/vmsdefs.h	204;"	d
FCH$V_WRITCHECK	vms/vmsdefs.h	206;"	d
FCH$V_WRITEBACK	vms/vmsdefs.h	208;"	d
FEA2	os2/os2zip.c	/^FEA2, *PFEA2;$/;"	t	typeref:struct:__anon14	file:
FEA2LIST	os2/os2zip.c	/^FEA2LIST, *PFEA2LIST;$/;"	t	typeref:struct:__anon15	file:
FEALST	os2/os2zip.c	/^FEALST;$/;"	t	typeref:struct:__anon11	file:
FF	proginfo/txtvsbin.txt	/^  7 (BEL), 8 (BS), 11 (VT), 12 (FF), 26 (SUB), 27 (ESC)$/;"	v
FFIRST	msdos/msdos.c	21;"	d	file:
FFIRST	msdos/msdos.c	40;"	d	file:
FFIRST	msdos/msdos.c	63;"	d	file:
FGETCH	ttyio.h	188;"	d
FGETCH	ttyio.h	206;"	d
FGETCH	ttyio.h	211;"	d
FHOW_ID	vms/zipup.h	42;"	d
FIB$L_ACCTL	vms/vms.h	61;"	d
FIB$L_ACCTL	vms/vms.h	66;"	d
FIB$L_ACCTL	vms/vmsmunch.c	156;"	d	file:
FIB$L_ACCTL	vms/vmsmunch.c	160;"	d	file:
FIB$W_DID	vms/vms.h	59;"	d
FIB$W_DID	vms/vms.h	64;"	d
FIB$W_DID	vms/vmsmunch.c	154;"	d	file:
FIB$W_DID	vms/vmsmunch.c	158;"	d	file:
FIB$W_EXCTL	vms/vms.h	62;"	d
FIB$W_EXCTL	vms/vms.h	67;"	d
FIB$W_FID	vms/vms.h	60;"	d
FIB$W_FID	vms/vms.h	65;"	d
FIB$W_FID	vms/vmsmunch.c	155;"	d	file:
FIB$W_FID	vms/vmsmunch.c	159;"	d	file:
FILE	amiga/deflate.a	/^        xref    _stderr         ; pointer to FILE, which we pass to fputc$/;"	v
FILE	human68k/deflate.s	/^        xref    _stderr         ; pointer to FILE, which we pass to fputc$/;"	v
FILE_ATTRIBUTE_HIDDEN	win32/rsxntwin.h	38;"	d
FILE_ATTRIBUTE_SYSTEM	win32/rsxntwin.h	39;"	d
FILE_PERSISTENT_ACLS	win32/rsxntwin.h	43;"	d
FILE_SHARE_DELETE	win32/nt.c	54;"	d	file:
FILE_SHARE_DELETE	win32/rsxntwin.h	41;"	d
FILL_REQ	vms/vms_pk.c	171;"	d	file:
FIRST_GOOD_YEAR	timezone.c	74;"	d	file:
FIXED	windll/windll32.def	/^;CODE  PRELOAD FIXED$/;"	v
FIXSCAN_BUFSIZE	zipfile.c	3199;"	d	file:
FJN$M_AIJNL	vms/vmsdefs.h	288;"	d
FJN$M_ATJNL	vms/vmsdefs.h	289;"	d
FJN$M_BIJNL	vms/vmsdefs.h	287;"	d
FJN$M_JOURNAL_FILE	vms/vmsdefs.h	291;"	d
FJN$M_NEVER_RU	vms/vmsdefs.h	290;"	d
FJN$M_ONLY_RU	vms/vmsdefs.h	285;"	d
FJN$M_RUJNL	vms/vmsdefs.h	286;"	d
FJN$S_FJNDEF	vms/vmsdefs.h	292;"	d
FLAT	os2/match32.asm	/^        assume cs:CODE32, ds:FLAT, ss:FLAT$/;"	v
FLD	tops20/tops20.c	31;"	d	file:
FLUSH_B	amiga/deflate.a	/^        FLUSH_B #1                      ; sets our return value$/;"	v
FLUSH_BLOCK	deflate.c	578;"	d	file:
FNEXT	msdos/msdos.c	22;"	d	file:
FNEXT	msdos/msdos.c	41;"	d	file:
FNEXT	msdos/msdos.c	64;"	d	file:
FNMAX	zip.h	123;"	d
FNMAX	zip.h	125;"	d
FNV	api.h	/^  char **FNV;           \/* array of file names to zip up *\/$/;"	m	struct:__anon31	access:public
FOPM	amiga/osdep.h	114;"	d
FOPM	atari/osdep.h	10;"	d
FOPM	cmsmvs/cmsmvs.h	107;"	d
FOPM	macos/osdep.h	65;"	d
FOPM	msdos/osdep.h	139;"	d
FOPM	novell/osdep.h	134;"	d
FOPM	os2/osdep.h	99;"	d
FOPM	tailor.h	413;"	d
FOPM	tandem/tandem.h	71;"	d
FOPM	tops20/osdep.h	24;"	d
FOPM	unix/osdep.h	72;"	d
FOPM	vms/osdep.h	167;"	d
FOPM	vms/osdep.h	173;"	d
FOPM	win32/osdep.h	270;"	d
FOPM_ID	vms/osdep.h	146;"	d
FOPR	amiga/osdep.h	113;"	d
FOPR	atari/osdep.h	9;"	d
FOPR	cmsmvs/cmsmvs.h	106;"	d
FOPR	macos/osdep.h	64;"	d
FOPR	msdos/osdep.h	138;"	d
FOPR	novell/osdep.h	133;"	d
FOPR	os2/osdep.h	98;"	d
FOPR	tailor.h	412;"	d
FOPR	tandem/tandem.h	70;"	d
FOPR	tops20/osdep.h	23;"	d
FOPR	unix/osdep.h	71;"	d
FOPR	vms/osdep.h	168;"	d
FOPR	vms/osdep.h	174;"	d
FOPR	win32/osdep.h	269;"	d
FOPR_EX	tailor.h	425;"	d
FOPR_EX	tailor.h	427;"	d
FOPR_ID	vms/osdep.h	147;"	d
FOPW	amiga/osdep.h	115;"	d
FOPW	atari/osdep.h	11;"	d
FOPW	cmsmvs/cmsmvs.h	109;"	d
FOPW	cmsmvs/cmsmvs.h	111;"	d
FOPW	macos/osdep.h	66;"	d
FOPW	msdos/osdep.h	140;"	d
FOPW	novell/osdep.h	135;"	d
FOPW	os2/osdep.h	100;"	d
FOPW	tailor.h	414;"	d
FOPW	tandem/tandem.h	72;"	d
FOPW	tops20/osdep.h	25;"	d
FOPW	unix/osdep.h	73;"	d
FOPW	vms/osdep.h	169;"	d
FOPW	vms/osdep.h	175;"	d
FOPW	win32/osdep.h	271;"	d
FOPWT	tandem/tandem.h	73;"	d
FOPW_ID	vms/osdep.h	148;"	d
FOPW_TMP	cmsmvs/cmsmvs.h	117;"	d
FOPW_TMP	tailor.h	418;"	d
FORCE_UNIX_OVER_WIN32	tailor.h	19;"	d
FREE	README.CR	/^    LIKE ANYTHING ELSE THAT IS FREE, ZIP, UNZIP AND THEIR ASSOCIATED$/;"	v
FRESHEN	vms/zip_cli.cld	/^	Qualifier	FRESHEN, NonNegatable$/;"	v
FRESHEN	zip.c	79;"	d	file:
FSHasFSSpecCalls	macos/source/macstuff.c	/^static  Boolean FSHasFSSpecCalls(void)$/;"	f	file:	signature:(void)
FSMakeFSSpecCompat	macos/source/macstuff.c	/^pascal  OSErr   FSMakeFSSpecCompat(short vRefNum,$/;"	f	signature:(short vRefNum, long dirID, ConstStr255Param fileName, FSSpec *spec)
FS_FAT_	win32/osdep.h	420;"	d
FS_HPFS_	win32/osdep.h	421;"	d
FS_NTFS_	win32/osdep.h	422;"	d
FS_PERSISTENT_ACLS	win32/rsxntwin.h	47;"	d
FSpBumpDate	macos/source/macstuff.c	/^pascal  OSErr   FSpBumpDate(const FSSpec *spec)$/;"	f	signature:(const FSSpec *spec)
FSpChangeCreatorType	macos/source/macstuff.c	/^pascal  OSErr   FSpChangeCreatorType(const FSSpec *spec,$/;"	f	signature:(const FSSpec *spec, OSType creator, OSType fileType)
FSpDTGetComment	macos/source/macstuff.c	/^pascal  OSErr   FSpDTGetComment(const FSSpec *spec,$/;"	f	signature:(const FSSpec *spec, Str255 comment)
FSpDTSetComment	macos/source/macstuff.c	/^pascal  OSErr   FSpDTSetComment(const FSSpec *spec,$/;"	f	signature:(const FSSpec *spec, ConstStr255Param comment)
FSpFindFolder	macos/source/macstuff.c	/^FSpFindFolder($/;"	f	signature:( short vRefNum, OSType folderType, Boolean createFolder, FSSpec *spec)
FSpFindFolder	macos/source/pathname.c	/^FSpFindFolder($/;"	f	signature:( short vRefNum, OSType folderType, Boolean createFolder, FSSpec *spec)
FSpFindFolder_Name	macos/source/getenv.c	/^OSErr FSpFindFolder_Name($/;"	f	signature:( short vRefNum, OSType folderType, Boolean createFolder, FSSpec *spec, unsigned char *name)
FSpGetDInfo	macos/source/macstuff.c	/^pascal  OSErr FSpGetDInfo(const FSSpec *spec,$/;"	f	signature:(const FSSpec *spec, DInfo *fndrInfo)
FSpGetDefaultDir	macos/source/macstuff.c	/^int FSpGetDefaultDir(FSSpecPtr dirSpec) \/* On return the default directory. *\/$/;"	f	signature:(FSSpecPtr dirSpec)
FSpGetDirectoryID	macos/source/macstuff.c	/^pascal  OSErr   FSpGetDirectoryID(const FSSpec *spec,$/;"	f	signature:(const FSSpec *spec, long *theDirID, Boolean *isDirectory)
FSpGetFullPath	macos/source/macstuff.c	/^pascal  OSErr   FSpGetFullPath(const FSSpec *spec,$/;"	f	signature:(const FSSpec *spec, short *fullPathLength, Handle *fullPath)
FSpLocationFromFullPath	macos/source/macstuff.c	/^pascal OSErr FSpLocationFromFullPath(short fullPathLength,$/;"	f	signature:(short fullPathLength, const void *fullPath, FSSpec *spec)
FSpPathFromLocation	macos/source/macstuff.c	/^FSpPathFromLocation($/;"	f	signature:( FSSpec *spec, int *length, Handle *fullPath)
FSpRecurseDirectory	macos/source/recurse.c	/^pascal  OSErr   FSpRecurseDirectory(const FSSpec *spec,$/;"	f	signature:(const FSSpec *spec, unsigned short maxLevels)
FSpSetDefaultDir	macos/source/macstuff.c	/^int FSpSetDefaultDir(FSSpecPtr dirSpec) \/* The new default directory. *\/$/;"	f	signature:(FSSpecPtr dirSpec)
FSusesLocalTime	win32/win32.c	/^local int FSusesLocalTime(const char *path)$/;"	f	signature:(const char *path)
FSusesLocalTimeW	win32/win32.c	/^local int FSusesLocalTimeW(const wchar_t *path)$/;"	f	signature:(const wchar_t *path)
FTQUANTA_PER_UT_H	win32/win32.c	356;"	d	file:
FTQUANTA_PER_UT_L	win32/win32.c	355;"	d	file:
FTW_D	atari/atari.c	235;"	d	file:
FTW_DNR	atari/atari.c	236;"	d	file:
FTW_F	atari/atari.c	234;"	d	file:
FTW_NS	atari/atari.c	237;"	d	file:
FZOFFT_FMT	tailor.h	772;"	d
FZOFFT_HEX_DOT_WID	tailor.h	783;"	d
FZOFFT_HEX_WID	tailor.h	782;"	d
FZOFFT_HEX_WID_VALUE	tailor.h	775;"	d
FZOFFT_HEX_WID_VALUE	tailor.h	777;"	d
FZOFFT_LEN	util.c	1098;"	d	file:
FZOFFT_NUM	util.c	1097;"	d	file:
Far	tailor.h	494;"	d
Far	windll/structs.h	15;"	d
File	win32/vc6/zip.dsw	/^Microsoft Developer Studio Workspace File, Format Version 6.00$/;"	v
File	win32/vc6bz2/zip.dsw	/^Microsoft Developer Studio Workspace File, Format Version 6.00$/;"	v
File	windll/visualc/dll/zip32z64.dsw	/^Microsoft Developer Studio Workspace File, Format Version 6.00$/;"	v
File	windll/visualc/lib/zip32z64.dsw	/^Microsoft Developer Studio Workspace File, Format Version 6.00$/;"	v
FileDate	amiga/filedate.c	/^LONG FileDate(filename, u)$/;"	f
FileName	macos/source/macglob.h	/^    char            FileName[NAME_MAX];$/;"	m	struct:__anon17	access:public
FileTime2utime	win32/win32.c	/^local int FileTime2utime(FILETIME *pft, time_t *ut)$/;"	f	signature:(FILETIME *pft, time_t *ut)
Files	proginfo/txtvsbin.txt	/^A Fast Method of Identifying Plain Text Files$/;"	v
FindDesktopFolder	macos/source/pathname.c	/^void FindDesktopFolder(char *Path)$/;"	f	signature:(char *Path)
FindNewExtractFolder	macos/source/pathname.c	/^char *FindNewExtractFolder(char *ExtractPath, Boolean uniqueFolder)$/;"	f	signature:(char *ExtractPath, Boolean uniqueFolder)
Flag	WHATSNEW	/^  General Purpose Bit Flag, bit 11, UTF-8 flag, that indicates UTF-8$/;"	v
FoundDirectories	macos/source/macglob.h	/^    unsigned long   FoundDirectories;$/;"	m	struct:__anon17	access:public
FoundFiles	macos/source/macglob.h	/^    unsigned long   FoundFiles;$/;"	m	struct:__anon17	access:public
Free	util.c	/^int Free(x)$/;"	f
FreeArgVee	api.c	/^void FreeArgVee(void)$/;"	f	signature:(void)
FreeUpMemory	windll/example.c	/^void FreeUpMemory(void)$/;"	f	signature:(void)
Freq	trees.c	230;"	d	file:
FullPath	macos/source/macglob.h	/^    char            FullPath[NAME_MAX];$/;"	m	struct:__anon17	access:public
FullPath	macos/source/recurse.c	/^    char                    *FullPath;$/;"	m	struct:RecurseGlobals	file:	access:public
FullPathLen	macos/source/recurse.c	/^    short                   FullPathLen;$/;"	m	struct:RecurseGlobals	file:	access:public
GEALST	os2/os2zip.c	/^GEALST;$/;"	t	typeref:struct:__anon12	file:
GETNAM_MAX	fileio.c	104;"	d	file:
GET_RTYPE	vms/vmsmunch.h	44;"	d
GET_TIMES	vms/vmsmunch.h	42;"	d
GLOBAL	crypt.c	83;"	d	file:
GLOBAL	crypt.c	85;"	d	file:
GLOBAL	crypt.c	87;"	d	file:
GLOBAL	ttyio.c	48;"	d	file:
GLOBAL	ttyio.c	50;"	d	file:
GLOBAL	ttyio.c	52;"	d	file:
GLOBALS	globals.c	16;"	d	file:
GLOBALS	vms/vms_msg_gen.c	19;"	d	file:
GMTDelta	macos/source/mactime.c	/^static long GMTDelta(void)$/;"	f	file:	signature:(void)
GMT_TO_LCT	tandem/tandem.c	473;"	d	file:
GMT_TO_LST	tandem/tandem.c	474;"	d	file:
GNJFN	tops20/tops20.c	34;"	d	file:
GOT_IOCTL_H	ttyio.c	112;"	d	file:
GROUP_SECURITY_INFORMATION	win32/rsxntwin.h	123;"	d
GTTY	ttyio.c	129;"	d	file:
GTTY	ttyio.c	145;"	d	file:
GTTY	ttyio.c	153;"	d	file:
GVTC	vms/vms.c	55;"	d	file:
GVTC	vms/vms.c	57;"	d	file:
GVTC	vms/vmsmunch.c	186;"	d	file:
GVTC	vms/vmsmunch.c	188;"	d	file:
Gailly	amiga/deflate.a	/^; material is based on deflate.c, by Gailly, Rommel, and Igor Mandrichenko.$/;"	v
Gailly	human68k/deflate.s	/^; this material is based on deflate.c, by Gailly, Rommel, and Igor Mandrichenko.$/;"	v
GetACL	os2/os2zip.c	/^void GetACL(char *path, char **bufptr, size_t *size,$/;"	f	signature:(char *path, char **bufptr, size_t *size, char **cbufptr, size_t *csize)
GetAppName	macos/source/pathname.c	/^char *GetAppName(void)$/;"	f	signature:(void)
GetCatInfoNoName	macos/source/macstuff.c	/^pascal  OSErr GetCatInfoNoName(short vRefNum,$/;"	f	signature:(short vRefNum, long dirID, ConstStr255Param name, CInfoPBPtr pb)
GetComment	amiga/amiga.c	/^char *GetComment(char *filename)$/;"	f	signature:(char *filename)
GetComment	macos/source/macos.c	/^char *GetComment(char *filename)$/;"	f	signature:(char *filename)
GetCommentFromDesktopFile	macos/source/macstuff.c	/^static  OSErr   GetCommentFromDesktopFile(short vRefNum,$/;"	f	file:	signature:(short vRefNum, long dirID, ConstStr255Param name, Str255 comment)
GetCommentID	macos/source/macstuff.c	/^static  OSErr   GetCommentID(short vRefNum,$/;"	f	file:	signature:(short vRefNum, long dirID, ConstStr255Param name, short *commentID)
GetCompletePath	macos/source/pathname.c	/^char *GetCompletePath(char *CompletePath, const char *name, FSSpec *Spec,$/;"	f	signature:(char *CompletePath, const char *name, FSSpec *Spec, OSErr *err)
GetDInfo	macos/source/macstuff.c	/^pascal  OSErr GetDInfo(short vRefNum,$/;"	f	signature:(short vRefNum, long dirID, ConstStr255Param name, DInfo *fndrInfo)
GetDesktopFileName	macos/source/macstuff.c	/^static  OSErr   GetDesktopFileName(short vRefNum,$/;"	f	file:	signature:(short vRefNum, Str255 desktopName)
GetDirAttribs	win32/win32zip.c	57;"	d	file:
GetDirAttribsW	win32/win32zip.c	55;"	d	file:
GetDirName	macos/source/macstuff.c	/^pascal  OSErr   GetDirName(short vRefNum,$/;"	f	signature:(short vRefNum, long dirID, Str31 name)
GetDirectoryID	macos/source/macstuff.c	/^pascal  OSErr   GetDirectoryID(short vRefNum,$/;"	f	signature:(short vRefNum, long dirID, ConstStr255Param name, long *theDirID, Boolean *isDirectory)
GetDriveType	win32/rsxntwin.h	60;"	d
GetEAs	os2/os2zip.c	/^void GetEAs(char *path, char **bufptr, size_t *size,$/;"	f	signature:(char *path, char **bufptr, size_t *size, char **cbufptr, size_t *csize)
GetExtraTime	os2/os2zip.c	/^int GetExtraTime(struct zlist far *z, iztimes *z_utim)$/;"	f	signature:(struct zlist far *z, iztimes *z_utim)
GetExtraTime	qdos/qdos.c	/^local int GetExtraTime(struct zlist far *z, iztimes *z_utim, unsigned ut_flg)$/;"	f	signature:(struct zlist far *z, iztimes *z_utim, unsigned ut_flg)
GetExtraTime	win32/win32zip.c	/^local int GetExtraTime(struct zlist far *z, iztimes *z_utim)$/;"	f	signature:(struct zlist far *z, iztimes *z_utim)
GetFileMode	atari/atari.c	/^char GetFileMode(char *name)$/;"	f	signature:(char *name)
GetFileMode	msdos/msdos.c	/^int GetFileMode(char *name)$/;"	f	signature:(char *name)
GetFileMode	msdos/msdos.c	27;"	d	file:
GetFileMode	msdos/msdos.c	30;"	d	file:
GetFileMode	msdos/msdos.c	69;"	d	file:
GetFileMode	os2/os2zip.c	/^int GetFileMode(char *name)$/;"	f	signature:(char *name)
GetFileMode	win32/win32.c	/^int GetFileMode(char *name)$/;"	f	signature:(char *name)
GetFileModeW	win32/win32.c	/^int GetFileModeW(wchar_t *namew)$/;"	f	signature:(wchar_t *namew)
GetFileTime	os2/os2zip.c	/^ulg GetFileTime(char *name)$/;"	f	signature:(char *name)
GetFilename	macos/source/pathname.c	/^char *GetFilename(char *FileName, const char *FilePath)$/;"	f	signature:(char *FileName, const char *FilePath)
GetFilenameFromPathname	macos/source/macstuff.c	/^pascal  OSErr   GetFilenameFromPathname(ConstStr255Param pathname,$/;"	f	signature:(ConstStr255Param pathname, Str255 filename)
GetFullPath	macos/source/macstuff.c	/^pascal  OSErr   GetFullPath(short vRefNum,$/;"	f	signature:(short vRefNum, long dirID, ConstStr255Param name, short *fullPathLength, Handle *fullPath)
GetFullPathFromID	macos/source/pathname.c	/^char *GetFullPathFromID(char *CompletePath, short vRefNum, long dirID,$/;"	f	signature:(char *CompletePath, short vRefNum, long dirID, ConstStr255Param name, OSErr *err)
GetFullPathFromSpec	macos/source/pathname.c	/^char *GetFullPathFromSpec(char *FullPath, FSSpec *Spec, OSErr *err)$/;"	f	signature:(char *FullPath, FSSpec *Spec, OSErr *err)
GetGMToffsetMac	macos/source/mactime.c	/^Boolean GetGMToffsetMac(unsigned long mactime, long *UTCoffset)$/;"	f	signature:(unsigned long mactime, long *UTCoffset)
GetLongNameEA	os2/os2zip.c	/^char *GetLongNameEA(const char *name)$/;"	f	signature:(const char *name)
GetLongPathEA	os2/os2zip.c	/^char *GetLongPathEA(const char *name)$/;"	f	signature:(const char *name)
GetLongPathEA	win32/win32.c	/^char *GetLongPathEA(char *name)$/;"	f	signature:(char *name)
GetLongPathEAW	win32/win32.c	/^wchar_t *GetLongPathEAW(wchar_t *name)$/;"	f	signature:(wchar_t *name)
GetNextDirEntry	win32/win32zip.c	/^local struct zdirscan *GetNextDirEntry(d)$/;"	f
GetNextDirEntryW	win32/win32zip.c	/^local struct zdirscanw *GetNextDirEntryW(dw)$/;"	f
GetObjectLocation	macos/source/macstuff.c	/^pascal  OSErr   GetObjectLocation(short vRefNum,$/;"	f	signature:(short vRefNum, long dirID, ConstStr255Param pathname, short *realVRefNum, long *realParID, Str255 realName, Boolean *isDirectory)
GetPlatformLocalTimezone	amiga/filedate.c	/^int GetPlatformLocalTimezone(sp, fill_tzstate_from_rules)$/;"	f
GetPlatformLocalTimezone	win32/win32.c	/^int GetPlatformLocalTimezone(register struct state * ZCONST sp,$/;"	f	signature:(register struct state * ZCONST sp, void (*fill_tzstate_from_rules)(struct state * ZCONST sp_res, ZCONST struct rule * ZCONST start, ZCONST struct rule * ZCONST end))
GetRemotePrivilegesGet	win32/nt.c	/^static VOID GetRemotePrivilegesGet(char *FileName, PDWORD dwRemotePrivileges)$/;"	f	file:	signature:(char *FileName, PDWORD dwRemotePrivileges)
GetSD	win32/win32zip.c	/^local void GetSD(char *path, char **bufptr, ush *size,$/;"	f	signature:(char *path, char **bufptr, ush *size, char **cbufptr, ush *csize)
GetTheFileTime	win32/win32.c	/^long GetTheFileTime(char *name, iztimes *z_ut)$/;"	f	signature:(char *name, iztimes *z_ut)
GetTimeMac	macos/source/mactime.c	/^static time_t GetTimeMac(void)$/;"	f	file:	signature:(void)
GetVolFileSystemID	macos/source/macstuff.c	/^pascal  OSErr   GetVolFileSystemID(ConstStr255Param pathname,$/;"	f	signature:(ConstStr255Param pathname, short vRefNum, short *fileSystemID)
GetVolumeFromPath	macos/source/pathname.c	/^unsigned short GetVolumeFromPath(const char *FullPath, char *VolumeName)$/;"	f	signature:(const char *FullPath, char *VolumeName)
GetVolumeInfoNoName	macos/source/macstuff.c	/^pascal  OSErr   GetVolumeInfoNoName(ConstStr255Param pathname,$/;"	f	signature:(ConstStr255Param pathname, short vRefNum, HParmBlkPtr pb)
GetWorkArea	novell/Netware.c	/^char *GetWorkArea(void)$/;"	f	signature:(void)
GetZipCopyright	macos/source/macos.c	/^char *GetZipCopyright(void)$/;"	f	signature:(void)
GetZipVersionLocal	macos/source/macos.c	/^char *GetZipVersionLocal(void)$/;"	f	signature:(void)
GetZipVersionsInfo	macos/source/macos.c	/^char *GetZipVersionsInfo(void)$/;"	f	signature:(void)
Greek	proginfo/txtvsbin.txt	/^like Greek, Cyrillic or Asian, make extensive use of the bytes within$/;"	v
Guests	proginfo/ntsd.txt	/^groups, like Administrators, Everyone, Network, Guests, etc.  These groups$/;"	v
H	win32/gvmat64.asm	/^COMM    prev:WORD:08000H$/;"	v
HANDLE_AMIGA_SFX	amiga/osdep.h	34;"	d
HASH_BITS	deflate.c	89;"	d	file:
HASH_BITS	deflate.c	92;"	d	file:
HASH_BITS	deflate.c	95;"	d	file:
HASH_MASK	deflate.c	100;"	d	file:
HASH_SIZE	deflate.c	99;"	d	file:
HAS_OPENDIR	msdos/osdep.h	166;"	d
HAS_OPENDIR	novell/osdep.h	161;"	d
HAVE_FSEEKABLE	win32/osdep.h	71;"	d
HAVE_STRCASECMP	vms/vmszip.c	36;"	d	file:
HAVE_SYS_TERMIO_H	ttyio.c	79;"	d	file:
HAVE_SYS_TERMIO_H	ttyio.c	86;"	d	file:
HAVE_TERMIOS_H	ttyio.c	56;"	d	file:
HAVE_TERMIOS_H	ttyio.c	64;"	d	file:
HAVE_TERMIO_H	ttyio.c	76;"	d	file:
HAVE_TERMIO_H	ttyio.c	83;"	d	file:
HAVE_WORKING_GETCH	ttyio.h	100;"	d
HAVE_WORKING_GETCH	ttyio.h	106;"	d
HAVE_WORKING_GETCH	ttyio.h	112;"	d
HAVE_WORKING_GETCH	ttyio.h	119;"	d
HAVE_WORKING_GETCH	ttyio.h	143;"	d
HAVE_WORKING_GETCH	ttyio.h	150;"	d
HAVE_WORKING_GETCH	ttyio.h	167;"	d
HAVE_WORKING_GETCH	ttyio.h	178;"	d
HAVE_WORKING_GETCH	ttyio.h	85;"	d
HAVE_WORKING_GETCH	ttyio.h	93;"	d
HEAP_SIZE	trees.c	235;"	d	file:
HELPERS_H	macos/source/helpers.h	10;"	d
HFILE_ERROR	win32/rsxntwin.h	45;"	d
HGetVInfo	macos/source/macstuff.c	/^pascal  OSErr   HGetVInfo(short volReference,$/;"	f	signature:(short volReference, StringPtr volName, short *vRefNum, unsigned long *freeBytes, unsigned long *totalBytes)
HGetVolParms	macos/source/macstuff.c	/^pascal  OSErr   HGetVolParms(ConstStr255Param volName,$/;"	f	signature:(ConstStr255Param volName, short vRefNum, GetVolParmsInfoBuffer *volParmsInfo, long *infoSize)
HIDD_SYS_BITS	win32/win32zip.c	36;"	d	file:
HOURSPERDAY	timezone.c	63;"	d	file:
HP	vms/zip_msg.msg	/^! Because the facility code was formally assigned by HP, the .FACILITY$/;"	v
H_SHIFT	deflate.c	178;"	d	file:
HaveGMToffset	macos/source/macglob.h	/^    Boolean     HaveGMToffset;$/;"	m	struct:__anon17	access:public
Head	amiga/deflate.a	/^        MOVINT  Head,d0                 ; parm for longest_match$/;"	v
Head	amiga/deflate.a	/^        UP_HASH Head,\\2$/;"	v
Head	amiga/deflate.a	/^        add.l   Head,Head               ; assert upper word is zero before add$/;"	v
Head	amiga/deflate.a	/^        moveq   #0,Head                 ; ditto for hash_head$/;"	v
Head	human68k/deflate.s	/^        MOVINT  Head,d0                 ; parm for longest_match$/;"	v
Head	human68k/deflate.s	/^        UP_HASH Head,_2$/;"	v
Head	human68k/deflate.s	/^        add.l   Head,Head               ; assert upper word is zero before add$/;"	v
Head	human68k/deflate.s	/^        move.w  (_1),Head               ; hash_head = head[ins_h]$/;"	v
Head	human68k/deflate.s	/^        moveq   #0,Head                 ; ditto for hash_head$/;"	v
HighPart	win32/rsxntwin.h	/^    LONG HighPart;$/;"	m	struct:_LUID	access:public
History	tandem/HISTORY	/^Tandem Port History$/;"	v
ID	acorn/riscos.h	/^  short         ID;$/;"	m	struct:__anon10	access:public
ID_2	acorn/riscos.h	/^  int           ID_2;$/;"	m	struct:__anon10	access:public
IFC	amiga/deflate.a	/^    IFC     '\\1','#0'$/;"	v
II	win32/crc_i386.asm	/^;   (like the Pentium Pro, Pentium II, and probably some Pentium clones).$/;"	v
INCL_DOS	os2/os2acl.c	58;"	d	file:
INCL_DOSERRORS	os2/os2acl.c	59;"	d	file:
INCL_DOSERRORS	os2/os2zip.c	34;"	d	file:
INCL_DOSMEMMGR	api.c	38;"	d	file:
INCL_DOSNLS	os2/os2zip.c	33;"	d	file:
INCL_NOPM	os2/os2acl.c	57;"	d	file:
INCL_NOPM	os2/os2zip.c	32;"	d	file:
INCSTR	tailor.h	367;"	d
INDEX	zipsplit.c	31;"	d	file:
INDEX	zipsplit.c	38;"	d	file:
INDEX	zipsplit.c	44;"	d	file:
INDEX	zipsplit.c	49;"	d	file:
INIT	vms/vms_im.c	245;"	d	file:
INITIAL_BUFF_SIZE	atheos/atheos.c	377;"	d	file:
INITIAL_BUFF_SIZE	beos/beos.c	360;"	d	file:
INSERT_STRING	deflate.c	289;"	d	file:
INT16	amiga/deflate.a	/^;;     IFD    INT16$/;"	v
INT16	human68k/deflate.s	/^;;     IFD    INT16$/;"	v
INTERNAL_DELIMITER	tandem/tandem.h	126;"	d
INTERNAL_DELIMITER_STR	tandem/tandem.h	135;"	d
INTERNAL_NODE	tandem/tandem.h	127;"	d
INTERNAL_NODE_STR	tandem/tandem.h	136;"	d
INTERN_TO_ISO	win32/osdep.h	378;"	d
INTERN_TO_ISO	win32/osdep.h	389;"	d
INTERN_TO_OEM	win32/osdep.h	379;"	d
INTERN_TO_OEM	win32/osdep.h	390;"	d
INTSIZE	amiga/deflate.a	/^        addq    #2*INTSIZE,sp$/;"	v
INTSIZE	amiga/deflate.a	/^        addq    #4+INTSIZE,sp$/;"	v
INTSIZE	human68k/deflate.s	/^        addq    #2*INTSIZE,sp$/;"	v
INTSIZE	human68k/deflate.s	/^        addq    #4+INTSIZE,sp$/;"	v
INVALID_WIN32_FILE_ATTRIBS	win32/win32zip.c	53;"	d	file:
IN_VALUE_LIST	fileio.c	3699;"	d	file:
IPos	deflate.c	/^typedef unsigned IPos;$/;"	t	file:
ISO_TO_INTERN	win32/osdep.h	376;"	d
ISO_TO_INTERN	win32/osdep.h	387;"	d
IZTZ_DEFINESTDGLOBALS	amiga/osdep.h	95;"	d
IZTZ_DEFINESTDGLOBALS	win32/osdep.h	481;"	d
IZTZ_GETLOCALETZINFO	amiga/osdep.h	23;"	d
IZTZ_GETLOCALETZINFO	timezone.c	52;"	d	file:
IZTZ_GETLOCALETZINFO	win32/osdep.h	499;"	d
IZTZ_GETLOCALETZINFO	win32/osdep.h	501;"	d
IZTZ_SETLOCALTZINFO	amiga/osdep.h	65;"	d
IZ_CHECK_TZ	amiga/osdep.h	19;"	d
IZ_CHECK_TZ	macos/osdep.h	51;"	d
IZ_CHECK_TZ	msdos/osdep.h	82;"	d
IZ_CHECK_TZ	novell/osdep.h	82;"	d
IZ_CHECK_TZ	os2/osdep.h	48;"	d
IZ_COMPANY_NAME	revision.h	32;"	d
IZ_CRCOPTIM_UNFOLDTBL	crc32.c	40;"	d	file:
IZ_CRCOPTIM_UNFOLDTBL	vms/osdep.h	107;"	d
IZ_CRC_BE_OPTIMIZ	crc32.h	36;"	d
IZ_CRC_BE_OPTIMIZ	vms/osdep.h	101;"	d
IZ_CRC_BE_OPTIMIZ	win32/osdep.h	339;"	d
IZ_CRC_LE_OPTIMIZ	vms/osdep.h	104;"	d
IZ_CRC_LE_OPTIMIZ	win32/osdep.h	342;"	d
IZ_IMP	tailor.h	203;"	d
IZ_IMP	win32/osdep.h	326;"	d
IZ_IMP	win32/osdep.h	328;"	d
IZ_IMP	win32/osdep.h	331;"	d
IZ_MKTIME_ONLY	util.c	26;"	d	file:
IZ_PACKED	win32/osdep.h	576;"	d
IZ_PACKED	win32/osdep.h	578;"	d
IZ_PWLEN	crypt.h	118;"	d
IZ_PW_CANCEL	zip.h	270;"	d
IZ_PW_CANCELALL	zip.h	271;"	d
IZ_PW_ENTERED	zip.h	269;"	d
IZ_PW_ERROR	zip.h	272;"	d
IZ_PW_SKIPVERIFY	zip.h	273;"	d
IZ_SIGNATURE	vms/vms.h	217;"	d
IZ_UT_FLAGS	qdos/qdos.c	864;"	d	file:
IZ_UT_FLAGS	qdos/qdos.c	867;"	d	file:
IZ_UT_FLAGS	qdos/qdos.c	870;"	d	file:
IZ_VERSION_SYMBOLS_ONLY	win32/zip.rc	5;"	d	file:
IZ_VERSION_SYMBOLS_ONLY	win32/zip.rc	7;"	d	file:
IZ_block	vms/vms.h	/^struct IZ_block                 \/* Extra field block header structure *\/$/;"	s
IZ_block::bid	vms/vms.h	/^    ulg bid;$/;"	m	struct:IZ_block	access:public
IZ_block::body	vms/vms.h	/^    uch body[1];                \/* The actual size is unknown *\/$/;"	m	struct:IZ_block	access:public
IZ_block::flags	vms/vms.h	/^    ush flags;$/;"	m	struct:IZ_block	access:public
IZ_block::length	vms/vms.h	/^    ush length;$/;"	m	struct:IZ_block	access:public
IZ_block::reserved	vms/vms.h	/^    ulg reserved;$/;"	m	struct:IZ_block	access:public
IZ_block::sig	vms/vms.h	/^    ush sig;$/;"	m	struct:IZ_block	access:public
IZ_block::size	vms/vms.h	/^    ush size;$/;"	m	struct:IZ_block	access:public
IgnoreEnvironment	macos/source/getenv.c	/^Boolean IgnoreEnvironment    = false;  \/* used by dialog.c and initfunc.c$/;"	v
IncludeInvisible	macos/source/macglob.h	/^    Boolean         IncludeInvisible;$/;"	m	struct:__anon17	access:public
IncludeList	api.h	/^char **IncludeList;     \/* Pointer to include file list array. Note that the last$/;"	m	struct:__anon30	access:public
IncludeList	windll/windll.txt	/^char **IncludeList;     \/* Pointer to include file list array. Note that the last$/;"	m	struct:__anon18	file:	access:public
IncludeListCount	api.h	/^long IncludeListCount;  \/* Count of file names in the include list array *\/$/;"	m	struct:__anon30	access:public
IncludeListCount	windll/windll.txt	/^long IncludeListCount;  \/* Count of file names in the include list array *\/$/;"	m	struct:__anon18	file:	access:public
InformProgress	macos/source/macos.c	/^void InformProgress(const long progressMax, const long progressSoFar )$/;"	f	signature:(const long progressMax, const long progressSoFar )
InitLocalPrivileges	win32/nt.c	/^static VOID InitLocalPrivileges(VOID)$/;"	f	file:
Initialize	win32/nt.c	/^static BOOL Initialize(VOID)$/;"	f	file:
InterlockedExchangePointer	win32/nt.c	59;"	d	file:
IsFileNameValid	os2/os2zip.c	/^int IsFileNameValid(char *name)$/;"	f	signature:(char *name)
IsFileNameValid	win32/win32.c	/^int IsFileNameValid(x)$/;"	f
IsFileSystemFAT	os2/os2zip.c	/^int IsFileSystemFAT(char *dir)$/;"	f	signature:(char *dir)
IsFileSystemOldFAT	win32/win32.c	/^int IsFileSystemOldFAT(char *dir)$/;"	f	signature:(char *dir)
IsFileSystemOldFATW	win32/win32.c	/^int IsFileSystemOldFATW(wchar_t *dir)$/;"	f	signature:(wchar_t *dir)
IsNT	windll/example.c	/^BOOL IsNT(VOID)$/;"	f
IsZipFile	macos/source/recurse.c	/^Boolean IsZipFile(char *filen)$/;"	f	signature:(char *filen)
JFNS	tops20/tops20.c	33;"	d	file:
JPI$_RMS_DFMBC	vms/vms.c	695;"	d	file:
JPI$_RMS_DFMBFSDK	vms/vms.c	699;"	d	file:
JPI$_RMS_EXTEND_SIZE	vms/vms.c	691;"	d	file:
JSYS_CLASS	tops20/tops20.c	30;"	d	file:
JULIAN_DAY	timezone.h	30;"	d
January	msdos/crc_i86.asm	/^; In January 2007, the "hand-made" memory model setup section has been guarded$/;"	v
JohnnyLee_EF	macos/source/pathname.h	50;"	d
KByte	vms/vms_im.c	679;"	d	file:
KByte	vms/vms_pk.c	323;"	d	file:
KIND	README.CR	/^    UTILITIES ARE PROVIDED AS IS AND COME WITH NO WARRANTY OF ANY KIND,$/;"	v
Kbyte	vms/vms_im.c	61;"	d	file:
Kienitz	amiga/crc_68.a	/^; crc_68 created by Paul Kienitz, last modified 04 Jan 96.$/;"	v
Kienitz	amiga/match_68.a	/^; Paul Kienitz, partially derived from a simpler version by Carsten Steger,$/;"	v
Kienitz	human68k/crc_68.s	/^; crc_68 created by Paul Kienitz, last modified 04 Jan 96.$/;"	v
LARGE_FILE_SUPPORT	amiga/osdep.h	29;"	d
LARGE_FILE_SUPPORT	unix/osdep.h	14;"	d
LARGE_FILE_SUPPORT	win32/osdep.h	114;"	d
LARGE_FILE_SUPPORT	win32/osdep.h	117;"	d
LARGE_FILE_SUPPORT	win32/osdep.h	187;"	d
LAST_GOOD_YEAR	timezone.c	75;"	d	file:
LAST_KNOWN_COMPMETHOD	zip.h	333;"	d
LAST_KNOWN_COMPMETHOD	zip.h	335;"	d
LEAP	amiga/filedate.c	182;"	d	file:
LENGTH_CODES	trees.c	139;"	d	file:
LF	proginfo/txtvsbin.txt	/^  9 (TAB), 10 (LF), 13 (CR), 20 (SPACE) to 255$/;"	v
LF	proginfo/txtvsbin.txt	/^some portable whitespace such as TAB, CR or LF, otherwise the file is$/;"	v
LF	zip.h	264;"	d
LFLAGS2	unix/configure	/^            LFLAGS2="${LFLAGS2} ${lf}"$/;"	v
LFLAGS2	unix/configure	/^    LFLAGS2="${LFLAGS2} ${OPT}"$/;"	v
LG	fileio.c	/^ ulg LG(uch* p) { return ((ulg)(SH(p)) | ((ulg)(SH((p)+2)) << 16)); }$/;"	f	signature:(uch* p)
LG	fileio.c	1552;"	d	file:
LG	zipfile.c	/^ ulg LG(uch* p) { return ((ulg)(SH(p)) | ((ulg)(SH((p)+2)) << 16)); }$/;"	f	signature:(uch* p)
LG	zipfile.c	51;"	d	file:
LIB_BZIP2_OPTS	vms/descrip_src.mms	/^LIB_BZIP2_OPTS = LIB_BZIP2:LIBBZ2_NS.OLB \/library,$/;"	v
LIB_BZIP2_OPTS	vms/descrip_src.mms	/^LIB_BZIP2_OPTS =$/;"	v
LICENSE	acorn/match.s	/^; See the accompanying file LICENSE, version 1999-Oct-05 or later$/;"	v
LICENSE	acorn/sendbits.s	/^; See the accompanying file LICENSE, version 1999-Oct-05 or later$/;"	v
LICENSE	acorn/swiven.s	/^; See the accompanying file LICENSE, version 1999-Oct-05 or later$/;"	v
LICENSE	amiga/crc_68.a	/^; See the accompanying file LICENSE, version 2000-Apr-09 or later$/;"	v
LICENSE	amiga/deflate.a	/^; See the accompanying file LICENSE, version 1999-Oct-05 or later$/;"	v
LICENSE	amiga/match.a	/^; See the accompanying file LICENSE, version 1999-Oct-05 or later$/;"	v
LICENSE	amiga/match_68.a	/^; See the accompanying file LICENSE, version 1999-Oct-05 or later$/;"	v
LICENSE	human68k/crc_68.s	/^; See the accompanying file LICENSE, version 2000-Apr-09 or later$/;"	v
LICENSE	human68k/deflate.s	/^; See the accompanying file LICENSE, version 1999-Oct-05 or later$/;"	v
LICENSE	msdos/crc_i86.asm	/^; See the accompanying file LICENSE, version 2000-Apr-09 or later$/;"	v
LICENSE	msdos/match.asm	/^; See the accompanying file LICENSE, version 2007-Mar-04 or later$/;"	v
LICENSE	os2/match32.asm	/^; See the accompanying file LICENSE, version 2005-Feb-10 or later$/;"	v
LICENSE	qdos/config.s	/^; See the accompanying file LICENSE, version 1999-Oct-05 or later$/;"	v
LICENSE	qdos/crc68.s	/^; See the accompanying file LICENSE, version 2000-Apr-09 or later$/;"	v
LICENSE	qdos/match.s	/^; See the accompanying file LICENSE, version 1999-Oct-05 or later$/;"	v
LICENSE	win32/crc_i386.asm	/^; See the accompanying file LICENSE, version 2000-Apr-09 or later$/;"	v
LICENSE	win32/crc_lcc.asm	/^; See the accompanying file LICENSE, version 2000-Apr-09 or later$/;"	v
LICENSE	win32/lm32_lcc.asm	/^; See the accompanying file LICENSE, version 1999-Oct-05 or later$/;"	v
LICENSE	win32/match32.asm	/^; See the accompanying file LICENSE, version 2005-Feb-10 or later$/;"	v
LITERALS	trees.c	142;"	d	file:
LIT_BUFSIZE	trees.c	174;"	d	file:
LIT_BUFSIZE	trees.c	177;"	d	file:
LIT_BUFSIZE	trees.c	179;"	d	file:
LLG	fileio.c	1554;"	d	file:
LLG	zipfile.c	53;"	d	file:
LLONG64	win32/win32.c	/^   typedef __int64              LLONG64;$/;"	t	file:
LLONG64	win32/win32.c	/^   typedef long long            LLONG64;$/;"	t	file:
LOCAL_ZIP	vms/build_zip.com	/^$!     If editing this procedure to set LOCAL_ZIP, be sure to use only$/;"	v
LOCCRC	zipfile.c	81;"	d	file:
LOCDAT	zipfile.c	80;"	d	file:
LOCEXT	zipfile.c	85;"	d	file:
LOCFLG	zipfile.c	77;"	d	file:
LOCHEAD	zip.h	140;"	d
LOCHOW	zipfile.c	78;"	d	file:
LOCLEN	zipfile.c	83;"	d	file:
LOCNAM	zipfile.c	84;"	d	file:
LOCSIG	zipfile.c	69;"	d	file:
LOCSIZ	zipfile.c	82;"	d	file:
LOCTIM	zipfile.c	79;"	d	file:
LOCVER	zipfile.c	76;"	d	file:
LOG_DEBUG	macos/ZipLib.h	78;"	d
LOG_DEBUG	macos/ZipSx.h	80;"	d
LONGID	qdos/qdos.c	102;"	d	file:
LPVOLUMECAPS	win32/nt.h	/^} VOLUMECAPS, *PVOLUMECAPS, *LPVOLUMECAPS;$/;"	t	typeref:struct:__anon6
LPZCL	api.h	/^} ZCL, _far *LPZCL;$/;"	t	typeref:struct:__anon31
LPZCL	windll/windll.txt	/^} ZCL, _far *LPZCL;$/;"	t	typeref:struct:__anon19	file:
LPZIPUSERFUNCTIONS	api.h	/^} ZIPUSERFUNCTIONS, far * LPZIPUSERFUNCTIONS;$/;"	t	typeref:struct:__anon32
LPZIPUSERFUNCTIONS	windll/windll.txt	/^} ZIPUSERFUNCTIONS, far * LPZIPUSERFUNCTIONS;$/;"	t	typeref:struct:__anon20	file:
LPZPOPT	api.h	/^} ZPOPT, _far *LPZPOPT;$/;"	t	typeref:struct:__anon30
LPZPOPT	windll/windll.txt	/^} ZPOPT, _far *LPZPOPT;$/;"	t	typeref:struct:__anon18	file:
LSSTAT	tailor.h	732;"	d
LSSTAT	tailor.h	735;"	d
LSSTAT	tailor.h	748;"	d
LSSTAT	tailor.h	751;"	d
LSSTATW	tailor.h	737;"	d
LSSTATW	tailor.h	753;"	d
LSTAT	tailor.h	731;"	d
LSTAT	tailor.h	734;"	d
LSTAT	tailor.h	747;"	d
LSTAT	tailor.h	750;"	d
LUID	win32/rsxntwin.h	/^} LUID, *PLUID;$/;"	t	typeref:struct:_LUID
LUID_AND_ATTRIBUTES	win32/rsxntwin.h	/^    } LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES;$/;"	t	typeref:struct:_LUID_AND_ATTRIBUTES
L_CODES	trees.c	148;"	d	file:
Label	vms/zip_cli.cld	/^	Parameter	P1, Label=ZIPFILE, Prompt="Zip file"$/;"	v
Label	vms/zip_cli.cld	/^	Parameter	P2, Label=INFILE, VALUE(list), Prompt="Files to Zip"$/;"	v
LastDir	qdos/qdos.c	/^char *LastDir(char *ws)$/;"	f	signature:(char *ws)
LastMatchGood	win32/gvmat64.asm	/^LastMatchGood:$/;"	v
Len	trees.c	233;"	d	file:
LenMaximum	win32/gvmat64.asm	/^        jge LenMaximum$/;"	v
Lib	win32/gvmat64.asm	/^; to compile this file for zLib, I use option:$/;"	v
Limit	amiga/deflate.a	/^        moveq   #0,Limit                ; so adding to Scan_Ini works$/;"	v
Limit	human68k/deflate.s	/^        moveq   #0,Limit                ; so adding to Scan_Ini works$/;"	v
LineNumber	macos/source/getenv.c	/^static unsigned LineNumber   = 0;$/;"	v	file:
Linux	TODO	/^- Extended attributes for Windows, Linux, and Mac OS X.$/;"	v
Linux	WHATSNEW	/^- Extended attributes for Windows, Linux, and Mac OS X.$/;"	v
ListAllKeyValues	macos/source/getenv.c	/^static char ListAllKeyValues = 0;$/;"	v	file:
Look	amiga/deflate.a	/^        and.l   #$FFFF,Look             ; make sure Look is valid as long$/;"	v
Look	amiga/deflate.a	/^; strstart, lookahead, and window must be cached in Strst, Look, and Window:$/;"	v
Look	amiga/deflate.a	/^; we exclude More, WindTop, SlidIx, Look, Strst, Window, a4 and a7.$/;"	v
Look	human68k/deflate.s	/^        and.l   #$FFFF,Look             ; make sure Look is valid as long$/;"	v
Look	human68k/deflate.s	/^; strstart, lookahead, and window must be cached in Strst, Look, and Window:$/;"	v
Look	human68k/deflate.s	/^; we exclude More, WindTop, SlidIx, Look, Strst, Window, a4 and a7.$/;"	v
LookupLoop	win32/gvmat64.asm	/^        jmp LookupLoop$/;"	v
LookupLoop1	win32/gvmat64.asm	/^        jnz LookupLoop1$/;"	v
LookupLoopIsZero	win32/gvmat64.asm	/^        jmp LookupLoopIsZero$/;"	v
LookupPrivilegeValue	win32/rsxntwin.h	117;"	d
LowPart	win32/rsxntwin.h	/^    DWORD LowPart;$/;"	m	struct:_LUID	access:public
Luid	win32/rsxntwin.h	/^    LUID Luid;$/;"	m	struct:_LUID_AND_ATTRIBUTES	access:public
MACOS	macos/ZipLib.h	23;"	d
MACOS	macos/ZipSx.h	22;"	d
MACOS	macos/osdep.h	13;"	d
MACOS	proginfo/ZipPorts	/^      it:  AMIGA, ATARI_ST, __human68k__, MACOS, MSDOS, MVS, OS2, TOPS20,$/;"	v
MACOS_TO_UNIX	macos/source/mactime.h	44;"	d
MACRO	amiga/deflate.a	/^;;CAL_SH  MACRO                   ; macro for calling zcalloc()$/;"	v
MACRO	amiga/deflate.a	/^CAL_SH  MACRO                   ; Okay, we're back to using regular calloc()...$/;"	v
MACRO	human68k/deflate.s	/^;;CAL_SH  MACRO                   ; macro for calling zcalloc()$/;"	v
MACZIP	macos/ZipLib.h	24;"	d
MACZIP	macos/ZipSx.h	24;"	d
MAKEF	unix/Makefile	/^MAKEF = -f unix\/Makefile$/;"	v
MARK	zipnote.c	33;"	d	file:
MARKE	zipnote.c	34;"	d	file:
MARKZ	zipnote.c	35;"	d	file:
MARK_CRCTAB_EMPTY	crc32.c	105;"	d	file:
MARK_CRCTAB_FILLED	crc32.c	104;"	d	file:
MATCH	human68k/human68k.c	18;"	d	file:
MATCH	msdos/osdep.h	128;"	d
MATCH	msdos/osdep.h	130;"	d
MATCH	novell/Netware.c	37;"	d	file:
MATCH	novell/osdep.h	123;"	d
MATCH	novell/osdep.h	125;"	d
MATCH	win32/osdep.h	505;"	d
MATCH	win32/osdep.h	507;"	d
MATCH	zip.h	129;"	d
MATCHW	win32/osdep.h	510;"	d
MATCH_TEXT	msdos/match.asm	/^        assume  cs: MATCH_TEXT, ds: DGROUP$/;"	v
MAXCOM	zip.c	70;"	d	file:
MAXEXT	acorn/riscos.c	17;"	d	file:
MAXFILENAMELEN	acorn/riscos.h	27;"	d
MAXFILEPARTLEN	tandem/tandem.h	60;"	d
MAXNAMLEN	os2/os2zip.h	14;"	d
MAXPATHLEN	acorn/riscos.h	26;"	d
MAXPATHLEN	cmsmvs/cmsmvs.h	64;"	d
MAXPATHLEN	os2/os2zip.h	15;"	d
MAXPATHLEN	tandem/tandem.h	61;"	d
MAXSEG_64K	deflate.c	121;"	d	file:
MAX_ARGS	macos/source/helpers.h	55;"	d
MAX_BITS	trees.c	133;"	d	file:
MAX_BL_BITS	trees.c	136;"	d	file:
MAX_COMMAND	macos/source/getenv.c	73;"	d	file:
MAX_DIST	match.S	57;"	d	file:
MAX_DIST	msdos/match.asm	/^        sub     dx,MAX_DIST             ; limit = strstart-MAX_DIST$/;"	v
MAX_DIST	os2/match32.asm	/^        sub     edx,MAX_DIST            ; limit = strstart-MAX_DIST$/;"	v
MAX_DIST	win32/match32.asm	/^        sub     edx,MAX_DIST            ; limit = strstart-MAX_DIST$/;"	v
MAX_DIST	zip.h	116;"	d
MAX_EDIT_READ	tandem/tandem.h	56;"	d
MAX_ESCAPE_BYTES	fileio.c	3148;"	d	file:
MAX_LARGE_READ	tandem/tandem.h	57;"	d
MAX_LARGE_READ_EXPAND	tandem/tandem.h	58;"	d
MAX_MATCH	match.S	55;"	d	file:
MAX_MATCH	zip.h	100;"	d
MAX_NORMAL_READ	tandem/tandem.h	55;"	d
MAX_PTR	msdos/msdos.c	692;"	d	file:
MAX_READ_BYTES	vms/vms_im.c	680;"	d	file:
MAX_READ_BYTES	vms/vms_pk.c	324;"	d	file:
MB	proginfo/perform.dos	/^Cx486DX-40, VL-bus, 8MB; IDE hard disk;$/;"	v
MB	proginfo/perform.dos	/^DOS 6.2, HIMEM, EMM386 NOEMS NOVCPI, SMARTDRV 3MB, write back.$/;"	v
MBSCHR	tailor.h	351;"	d
MBSCHR	tailor.h	361;"	d
MBSRCHR	tailor.h	352;"	d
MBSRCHR	tailor.h	362;"	d
MB_CLEN	zip.h	1048;"	d
MB_CLEN	zip.h	1052;"	d
MB_CUR_MAX	win32/osdep.h	448;"	d
MB_CUR_MAX	win32/osdep.h	451;"	d
MB_CUR_MAX	win32/osdep.h	456;"	d
MB_NEXTCHAR	zip.h	1049;"	d
MB_NEXTCHAR	zip.h	1053;"	d
MC68020	human68k/deflate.s	/^;;;     MACHINE MC68020$/;"	v
MEDIUM_MEM	amiga/osdep.h	14;"	d
MEMCOMPRESS_HEADER	atheos/atheos.c	662;"	d	file:
MEMCOMPRESS_OVERHEAD	atheos/atheos.c	664;"	d	file:
MEMCOMPRESS_OVERHEAD	beos/beos.c	679;"	d	file:
MEMCOMPRESS_OVERHEAD	macos/source/extrafld.c	47;"	d	file:
MEMORY16	msdos/osdep.h	60;"	d
MEMORY16	msdos/osdep.h	67;"	d
MEMORY16	novell/osdep.h	60;"	d
MEMORY16	novell/osdep.h	67;"	d
MEMORY16	os2/osdep.h	33;"	d
MET	zip.txt	/^              The  format is TTThhDDD, where TTT is the time zone such as MET,$/;"	v
MFD	vms/vmszip.c	886;"	d	file:
MINSPERHOUR	amiga/filedate.c	187;"	d	file:
MINSPERHOUR	timezone.c	62;"	d	file:
MINSPERHOUR	win32/win32.c	1021;"	d	file:
MIN_LOOKAHEAD	match.S	56;"	d	file:
MIN_LOOKAHEAD	zip.h	111;"	d
MIN_MATCH	amiga/deflate.a	/^        addq    #MIN_MATCH,Match_Ini    ; optimizes inner loop$/;"	v
MIN_MATCH	amiga/match.a	/^        lea     _window+MIN_MATCH,Match_Ini$/;"	v
MIN_MATCH	amiga/match_68.a	/^        addq    #MIN_MATCH,Match_Ini$/;"	v
MIN_MATCH	human68k/deflate.s	/^        addq    #MIN_MATCH,Match_Ini    ; optimizes inner loop$/;"	v
MIN_MATCH	human68k/match.s	/^        lea     _window+MIN_MATCH,Match_Ini$/;"	v
MIN_MATCH	match.S	54;"	d	file:
MIN_MATCH	qdos/match.s	/^        lea     _window+MIN_MATCH,a4$/;"	v
MIN_MATCH	zip.h	99;"	d
MMK	vms/install_vms.txt	/^          MMS \/DESCRIP = [.VMS]DESCRIP.MMS      ! Or, with MMK, ...$/;"	v
MODERN	amiga/amiga.h	30;"	d
MONSPERYEAR	timezone.c	69;"	d	file:
MONTH_NTH_DAY_OF_WEEK	timezone.h	32;"	d
MOVE	vms/zip_cli.cld	/^	Qualifier	MOVE, NonNegatable$/;"	v
MSC	msdos/osdep.h	46;"	d
MSC	novell/osdep.h	46;"	d
MSC	os2/osdep.h	18;"	d
MSC	win32/osdep.h	17;"	d
MSC_INLINE_ASM_32BIT_SUPPORT	win32/crc_i386.c	100;"	d	file:
MSC_INLINE_ASM_32BIT_SUPPORT	win32/crc_i386.c	93;"	d	file:
MSDOS	INSTALL	/^     The steps for installation under VMS, MSDOS, OS\/2, NT, Amiga and$/;"	v
MSDOS	INSTALL	/^     wide range of systems:  Unix, VMS, MSDOS, OS\/2, NT, Amiga, Atari,$/;"	v
MSDOS	TODO	/^- on MSDOS, zip386.exe does not like "zip -bc: foo ..."$/;"	v
MSDOS	macos/README.TXT	/^VMS, MSDOS, OS\/2, Windows 9x, Windows NT, Atari, Macintosh,$/;"	v
MSDOS	msdos/osdep.h	33;"	d
MSDOS	novell/osdep.h	33;"	d
MSDOS	os2/osdep.h	87;"	d
MSDOS	proginfo/ZipPorts	/^      it:  AMIGA, ATARI_ST, __human68k__, MACOS, MSDOS, MVS, OS2, TOPS20,$/;"	v
MSDOS	proginfo/infozip.who	/^Christian Spieler       spieler@ikp.tu-darmstadt.de     VMS, MSDOS, emx, djgpp,$/;"	v
MSDOS	vms/VMS_ZIP.RNH	/^systems, including UNIX, VMS,  MSDOS, OS\/2, Windows 9x\/NT\/XP, Minix, Atari,$/;"	v
MSDOS	vms/zip_cli.help	/^systems, including UNIX, VMS,  MSDOS, OS\/2, Windows 9x\/NT\/XP, Minix,$/;"	v
MSDOS	win32/osdep.h	62;"	d
MSDOS16	msdos/osdep.h	66;"	d
MSDOS16	novell/osdep.h	66;"	d
MSDOS_DIR_ATTR	tailor.h	433;"	d
MSDOS_HIDDEN_ATTR	tailor.h	432;"	d
MSDOS_INVALID_ATTR	msdos/msdos.c	96;"	d	file:
MSG_FAC_SPEC	vms/vms.c	206;"	d	file:
MSG_FAC_SPEC	vms/vms.c	211;"	d	file:
MSWIN	msdos/osdep.h	59;"	d
MSWIN	novell/osdep.h	59;"	d
MSWIN	win32/osdep.h	298;"	d
MSWIN	windll/example.h	31;"	d
MSWIN	windll/windll.h	20;"	d
MULTIBYTE_GETOPTNS	zip.h	1043;"	d
MVS	proginfo/ZipPorts	/^      it:  AMIGA, ATARI_ST, __human68k__, MACOS, MSDOS, MVS, OS2, TOPS20,$/;"	v
MY_ZCALLOC	msdos/osdep.h	106;"	d
MY_ZCALLOC	novell/osdep.h	106;"	d
MY_ZCALLOC	os2/osdep.h	73;"	d
MY_ZCALLOC	tailor.h	877;"	d
MacFopen	macos/source/macopen.c	/^FILE *MacFopen(const char *path, const char *mode)$/;"	f	signature:(const char *path, const char *mode)
MacFtime2UnixFtime	macos/source/mactime.c	/^time_t MacFtime2UnixFtime(unsigned long macftime)$/;"	f	signature:(unsigned long macftime)
MacOS_2_Unix	macos/source/mactime.c	/^const unsigned long MacOS_2_Unix = 2082844800L;$/;"	v
MacOpen	macos/source/macopen.c	/^int MacOpen(const char *path,int oflag, ...)$/;"	f	signature:(const char *path,int oflag, ...)
MacPathEnd	macos/source/macos.c	/^static const char MacPathEnd = ':';   \/* the Macintosh dir separator *\/$/;"	v	file:
MacRoman_to_WinCP1252	macos/source/charmap.h	/^ZCONST unsigned char MacRoman_to_WinCP1252[128] = {$/;"	v
MacZip	macos/source/macos.c	/^MacZipGlobals   MacZip;$/;"	v
MacZipGlobals	macos/source/macglob.h	/^} MacZipGlobals;$/;"	t	typeref:struct:__anon17
MacZipMode	macos/source/macglob.h	/^    short       MacZipMode;$/;"	m	struct:__anon17	access:public
Macintosh	amiga/deflate.a	/^; On the Macintosh, I believe GetEnvironment() provides the information.$/;"	v
Macintosh	human68k/deflate.s	/^; On the Macintosh, I believe GetEnvironment() provides the information.$/;"	v
Macintosh	macos/README.TXT	/^VMS, MSDOS, OS\/2, Windows 9x, Windows NT, Atari, Macintosh,$/;"	v
Macintosh	vms/VMS_ZIP.RNH	/^Macintosh, Amiga, and Acorn RISC OS.  It is analogous to a combination of$/;"	v
Macintosh	vms/zip_cli.help	/^Atari, Macintosh, Amiga, and Acorn RISC OS.  It is analogous to a$/;"	v
Mactime	macos/source/mactime.c	/^static time_t Mactime(time_t *timer)$/;"	f	file:	signature:(time_t *timer)
MakeCompatibleString	macos/source/helpers.c	/^void MakeCompatibleString(char *MacOS_Str,$/;"	f	signature:(char *MacOS_Str, const char SpcChar1, const char SpcChar2, const char SpcChar3, const char SpcChar4, short CurrTextEncodingBase)
MakeFilenameShorter	macos/source/pathname.c	/^char *MakeFilenameShorter(const char *LongFilename)$/;"	f	signature:(const char *LongFilename)
Makefile	CHANGES	/^ 7. remove zilog entry from unix\/Makefile (Onno)$/;"	f
MatchL	amiga/deflate.a	/^        cmp.w   #MIN_MATCH,MatchL       ; is the match only three bytes?$/;"	v
MatchL	amiga/deflate.a	/^        dbra    MatchL,finsertmatch$/;"	v
MatchL	amiga/deflate.a	/^        moveq   #0,MatchL               ; not needed?$/;"	v
MatchL	amiga/deflate.a	/^        moveq   #MIN_MATCH-1,MatchL     ; mark the current match as no good$/;"	v
MatchL	amiga/deflate.a	/^fstml:  move.w  d0,MatchL               ; valid length of match$/;"	v
MatchL	amiga/deflate.a	/^stml:   move.w  d0,MatchL               ; valid length of match$/;"	v
MatchL	human68k/deflate.s	/^        cmp.w   #MIN_MATCH,MatchL       ; is the match only three bytes?$/;"	v
MatchL	human68k/deflate.s	/^        moveq   #0,MatchL               ; not needed?$/;"	v
MatchL	human68k/deflate.s	/^        moveq   #MIN_MATCH-1,MatchL     ; mark the current match as no good$/;"	v
MatchL	human68k/deflate.s	/^fstml:  move.w  d0,MatchL               ; valid length of match$/;"	v
MatchL	human68k/deflate.s	/^stml:   move.w  d0,MatchL               ; valid length of match$/;"	v
Match_Ini	amiga/deflate.a	/^        addq    #MIN_MATCH,Match_Ini    ; optimizes inner loop$/;"	v
Match_Ini	human68k/deflate.s	/^        addq    #MIN_MATCH,Match_Ini    ; optimizes inner loop$/;"	v
Max	trees.c	464;"	d	file:
Md_UTCoffs	macos/source/macglob.h	/^    long            Md_UTCoffs; \/* offset "local time - UTC" for ModDate *\/$/;"	m	struct:__anon17	access:public
Minix	vms/VMS_ZIP.RNH	/^systems, including UNIX, VMS,  MSDOS, OS\/2, Windows 9x\/NT\/XP, Minix, Atari,$/;"	v
Minix	vms/zip_cli.help	/^systems, including UNIX, VMS,  MSDOS, OS\/2, Windows 9x\/NT\/XP, Minix,$/;"	v
ModDate	macos/source/macglob.h	/^    time_t          ModDate;$/;"	m	struct:__anon17	access:public
More	amiga/deflate.a	/^        MOVINT  More,-(sp)              ; assert More's upper word is zero$/;"	v
More	amiga/deflate.a	/^        move.l  _window_size,More       ; <= 64K$/;"	v
More	amiga/deflate.a	/^        sub.l   Strst,More              ; Strst is already valid as long$/;"	v
More	amiga/deflate.a	/^; we exclude More, WindTop, SlidIx, Look, Strst, Window, a4 and a7.$/;"	v
More	human68k/deflate.s	/^        move.l  (_window_size,pc),More  ; <= 64K$/;"	v
More	human68k/deflate.s	/^        sub.l   Strst,More              ; Strst is already valid as long$/;"	v
More	human68k/deflate.s	/^; we exclude More, WindTop, SlidIx, Look, Strst, Window, a4 and a7.$/;"	v
NAMELEN	cmsmvs/mvs.h	11;"	d
NAMELEN	tandem/tandem.h	75;"	d
NAME_MAX	macos/ZipLib.h	41;"	d
NAME_MAX	macos/ZipSx.h	40;"	d
NAME_MAX	macos/source/pathname.h	61;"	d
NAME_MAX	macos/source/unixlike.h	20;"	d
NAM_B_DEV	vms/vms.h	102;"	d
NAM_B_DEV	vms/vms.h	139;"	d
NAM_B_DIR	vms/vms.h	104;"	d
NAM_B_DIR	vms/vms.h	141;"	d
NAM_B_NAME	vms/vms.h	106;"	d
NAM_B_NAME	vms/vms.h	143;"	d
NAM_B_TYPE	vms/vms.h	108;"	d
NAM_B_TYPE	vms/vms.h	145;"	d
NAM_B_VER	vms/vms.h	110;"	d
NAM_B_VER	vms/vms.h	147;"	d
NAM_DID	vms/vms.h	125;"	d
NAM_DID	vms/vms.h	88;"	d
NAM_DVI	vms/vms.h	126;"	d
NAM_DVI	vms/vms.h	89;"	d
NAM_ESA	vms/vms.h	127;"	d
NAM_ESA	vms/vms.h	90;"	d
NAM_ESL	vms/vms.h	128;"	d
NAM_ESL	vms/vms.h	91;"	d
NAM_ESS	vms/vms.h	129;"	d
NAM_ESS	vms/vms.h	92;"	d
NAM_FID	vms/vms.h	130;"	d
NAM_FID	vms/vms.h	93;"	d
NAM_FNB	vms/vms.h	131;"	d
NAM_FNB	vms/vms.h	94;"	d
NAM_L_DEV	vms/vms.h	103;"	d
NAM_L_DEV	vms/vms.h	140;"	d
NAM_L_DIR	vms/vms.h	105;"	d
NAM_L_DIR	vms/vms.h	142;"	d
NAM_L_NAME	vms/vms.h	107;"	d
NAM_L_NAME	vms/vms.h	144;"	d
NAM_L_TYPE	vms/vms.h	109;"	d
NAM_L_TYPE	vms/vms.h	146;"	d
NAM_L_VER	vms/vms.h	111;"	d
NAM_L_VER	vms/vms.h	148;"	d
NAM_MAXRSS	vms/vms.h	135;"	d
NAM_MAXRSS	vms/vms.h	98;"	d
NAM_M_EXP_DEV	vms/vms.h	100;"	d
NAM_M_EXP_DEV	vms/vms.h	137;"	d
NAM_M_SYNCHK	vms/vms.h	101;"	d
NAM_M_SYNCHK	vms/vms.h	138;"	d
NAM_NOP	vms/vms.h	136;"	d
NAM_NOP	vms/vms.h	99;"	d
NAM_RSA	vms/vms.h	132;"	d
NAM_RSA	vms/vms.h	95;"	d
NAM_RSL	vms/vms.h	133;"	d
NAM_RSL	vms/vms.h	96;"	d
NAM_RSS	vms/vms.h	134;"	d
NAM_RSS	vms/vms.h	97;"	d
NAM_STRUCT	vms/vms.h	115;"	d
NAM_STRUCT	vms/vms.h	78;"	d
NBITS	vms/vms_im.c	876;"	d	file:
NEED__ISINDST	win32/osdep.h	496;"	d
NEXTBYTE	crypt.h	154;"	d
NEXTBYTE	crypt.h	156;"	d
NIL	deflate.c	104;"	d	file:
NL	zipsplit.c	26;"	d	file:
NL	zipsplit.c	28;"	d	file:
NLM_SignalHandler	novell/signal.c	/^void NLM_SignalHandler(int sig)$/;"	f	signature:(int sig)
NLM_exiting	novell/signal.c	/^int NLM_exiting = FALSE;$/;"	v
NLM_mainThreadGroupID	novell/signal.c	/^int NLM_mainThreadGroupID;$/;"	v
NLM_threadCnt	novell/signal.c	/^int NLM_threadCnt = 0;$/;"	v
NLMexit	novell/signal.c	/^void NLMexit(void)$/;"	f	signature:(void)
NLMsignals	novell/signal.c	/^void NLMsignals(void)$/;"	f	signature:(void)
NON_OPTION_ARG	fileio.c	3700;"	d	file:
NOVCPI	proginfo/perform.dos	/^DOS 6.2, HIMEM, EMM386 NOEMS NOVCPI, SMARTDRV 3MB, write back.$/;"	v
NO_ALIGN	win32/crc_i386.asm	/^;   by defining NO_ALIGN, thus allowing to use .model flat. There is no need$/;"	v
NO_ASM	win32/osdep.h	295;"	d
NO_FCNTL_H	acorn/osdep.h	13;"	d
NO_FCNTL_H	cmsmvs/cmsmvs.h	46;"	d
NO_FCNTL_H	ttyio.c	93;"	d	file:
NO_FCNTL_H	vms/osdep.h	27;"	d
NO_INT64	win32/win32.c	349;"	d	file:
NO_LARGE_FILE_SUPPORT	amiga/osdep.h	27;"	d
NO_MKTEMP	acorn/osdep.h	15;"	d
NO_MKTEMP	cmsmvs/cmsmvs.h	66;"	d
NO_MKTEMP	macos/osdep.h	32;"	d
NO_MKTEMP	msdos/osdep.h	165;"	d
NO_MKTEMP	novell/osdep.h	160;"	d
NO_MKTEMP	os2/osdep.h	130;"	d
NO_MKTEMP	os2/osdep.h	170;"	d
NO_MKTEMP	tandem/tandem.h	20;"	d
NO_MKTEMP	win32/osdep.h	588;"	d
NO_MKTIME	amiga/amiga.c	69;"	d	file:
NO_MKTIME	msdos/osdep.h	214;"	d
NO_MKTIME	novell/osdep.h	203;"	d
NO_MKTIME	win32/osdep.h	274;"	d
NO_PROTO	tailor.h	173;"	d
NO_PROTO	tops20/osdep.h	13;"	d
NO_RMDIR	amiga/osdep.h	92;"	d
NO_RMDIR	cmsmvs/cmsmvs.h	65;"	d
NO_RMDIR	tandem/tandem.h	19;"	d
NO_STD_STACKFRAME	win32/crc_i386.asm	/^    IFNDEF NO_STD_STACKFRAME$/;"	v
NO_SYMLINKS	acorn/osdep.h	12;"	d
NO_SYMLINKS	macos/osdep.h	34;"	d
NO_SYMLINKS	msdos/osdep.h	124;"	d
NO_SYMLINKS	tops20/osdep.h	14;"	d
NO_SYMLINKS	vms/osdep.h	129;"	d
NO_TERMIO	atari/osdep.h	14;"	d
NO_TERMIO	tops20/osdep.h	15;"	d
NO_TYPEDEF_VOID	vms/osdep.h	25;"	d
NO_UNISTD_H	acorn/osdep.h	14;"	d
NO_UNISTD_H	amiga/osdep.h	91;"	d
NO_UNISTD_H	cmsmvs/cmsmvs.h	45;"	d
NO_UNISTD_H	msdos/osdep.h	51;"	d
NO_UNISTD_H	novell/osdep.h	51;"	d
NO_UNISTD_H	os2/osdep.h	126;"	d
NO_UNISTD_H	os2/osdep.h	169;"	d
NO_UNISTD_H	tandem/tandem.h	18;"	d
NO_UNISTD_H	vms/osdep.h	128;"	d
NO_UNISTD_H	win32/osdep.h	318;"	d
NO_UNROLLED_LOOPS	win32/crc_i386.asm	/^;      unrolled loops                NO_UNROLLED_LOOPS$/;"	v
NO_ZIPUP_H	vms/vms.c	31;"	d	file:
NSK_APPEND	tandem/tandem.h	108;"	d
NSK_EDITFILECODE	tandem/tandem.h	52;"	d
NSK_ENTRYSEQUENCED	tandem/tandem.h	49;"	d
NSK_EXCLUSIVE	tandem/tandem.h	110;"	d
NSK_KEYSEQUENCED	tandem/tandem.h	50;"	d
NSK_LARGE_READ_EXPAND	tandem/tandem.h	120;"	d
NSK_NOUPDATEOPENTIME	tandem/tandem.h	114;"	d
NSK_NO_DELIMITER	tandem/tandem.h	116;"	d
NSK_OBJECTFILECODE	tandem/tandem.h	51;"	d
NSK_PROCESSEXCLUSIVE	tandem/tandem.h	111;"	d
NSK_PROTECTED	tandem/tandem.h	112;"	d
NSK_RDONLY	tandem/tandem.h	106;"	d
NSK_RDWR	tandem/tandem.h	105;"	d
NSK_RELATIVE	tandem/tandem.h	48;"	d
NSK_SHARED	tandem/tandem.h	109;"	d
NSK_SPACE_FILL	tandem/tandem.h	118;"	d
NSK_TRIM_TRAILING_SPACE	tandem/tandem.h	119;"	d
NSK_UNSTRUCTURED	tandem/tandem.h	47;"	d
NSK_UNSTRUCTUREDACCESS	tandem/tandem.h	113;"	d
NSK_USE_FF_DELIMITER	tandem/tandem.h	117;"	d
NSK_WRONLY	tandem/tandem.h	107;"	d
NSK_ZIPFILECODE	tandem/tandem.h	53;"	d
NT	INSTALL	/^     The steps for installation under VMS, MSDOS, OS\/2, NT, Amiga and$/;"	v
NT	INSTALL	/^     wide range of systems:  Unix, VMS, MSDOS, OS\/2, NT, Amiga, Atari,$/;"	v
NT	macos/README.TXT	/^VMS, MSDOS, OS\/2, Windows 9x, Windows NT, Atari, Macintosh,$/;"	v
NTSD_BUFFERSIZE	win32/nt.h	53;"	d
NTSD_EAS	win32/osdep.h	286;"	d
NT_QUANTA_PER_UNIX	win32/win32.c	354;"	d	file:
NT_TZBUG_WORKAROUND	win32/osdep.h	277;"	d
NT_TZBUG_WORKAROUND	win32/osdep.h	280;"	d
NULL	cmsmvs/cmsmvs.h	56;"	d
NULL	tandem/tandem.h	34;"	d
NULL	vms/vms.c	96;"	d	file:
NULL	vms/vms_pk.c	89;"	d	file:
NUM_HOSTS	tailor.h	852;"	d
NetAccessAdd	os2/os2acl.c	/^APIRET16 (* APIENTRY16 NetAccessAdd)(PCHAR16 pszServer,$/;"	v
NetAccessAdd	os2/os2acl.c	/^USHORT (APIENTRY *NetAccessAdd)(PSZ pszServer,$/;"	v
NetAccessAdd	os2/os2acl.c	/^USHORT NetAccessAdd(PSZ pszServer, USHORT sLevel,$/;"	f	signature:(PSZ pszServer, USHORT sLevel, PVOID pbBuffer, USHORT cbBuffer)
NetAccessGetInfo	os2/os2acl.c	/^APIRET16 (* APIENTRY16 NetAccessGetInfo)(PCHAR16 pszServer, PCHAR16 pszResource,$/;"	v
NetAccessGetInfo	os2/os2acl.c	/^USHORT (APIENTRY *NetAccessGetInfo)(PSZ pszServer, PSZ pszResource,$/;"	v
NetAccessGetInfo	os2/os2acl.c	/^USHORT NetAccessGetInfo(PSZ pszServer, PSZ pszResource, USHORT sLevel,$/;"	f	signature:(PSZ pszServer, PSZ pszResource, USHORT sLevel, PVOID pbBuffer, USHORT cbBuffer, PUSHORT pcbTotalAvail)
NetAccessSetInfo	os2/os2acl.c	/^APIRET16 (* APIENTRY16 NetAccessSetInfo)(PCHAR16 pszServer, PCHAR16 pszResource,$/;"	v
NetAccessSetInfo	os2/os2acl.c	/^USHORT (APIENTRY *NetAccessSetInfo)(PSZ pszServer, PSZ pszResource,$/;"	v
NetAccessSetInfo	os2/os2acl.c	/^USHORT NetAccessSetInfo(PSZ pszServer, PSZ pszResource, USHORT sLevel,$/;"	f	signature:(PSZ pszServer, PSZ pszResource, USHORT sLevel, PVOID pbBuffer, USHORT cbBuffer, USHORT sParmNum)
Network	proginfo/ntsd.txt	/^groups, like Administrators, Everyone, Network, Guests, etc.  These groups$/;"	v
NewZipMode_EF	macos/source/pathname.h	51;"	d
Next_Byte	msdos/crc_i86.asm	/^        jnz     Next_Byte               ;  clocks, one less than this code$/;"	v
Next_Four	msdos/crc_i86.asm	/^        jnz     Next_Four               ;  clocks, one less than this code$/;"	v
NoFork	macos/source/macglob.h	20;"	d
NoFork	macos/source/pathname.h	57;"	d
No_Fours	msdos/crc_i86.asm	/^        jz      No_Fours$/;"	v
NonNegatable	vms/zip_cli.cld	/^	Qualifier	EXCLUDE, NonNegatable, VALUE(required,list)$/;"	v
Notify	macos/ZipLib.h	83;"	d
Notify	macos/ZipSx.h	85;"	d
OBJA	unix/configure	/^        OBJA="$OBJA crc_i386.o"$/;"	v
OBUF_SZ	zipup.c	1432;"	d	file:
OBUF_SZ	zipup.c	1740;"	d	file:
OEM_TO_INTERN	win32/osdep.h	377;"	d
OEM_TO_INTERN	win32/osdep.h	388;"	d
OF	crc32.h	22;"	d
OF	tailor.h	178;"	d
OF	tailor.h	181;"	d
OFT	tailor.h	179;"	d
OFT	tailor.h	182;"	d
OLDROUTINELOCATIONS	macos/ZipLib.h	27;"	d
OLDROUTINELOCATIONS	macos/ZipSx.h	27;"	d
OLDROUTINENAMES	macos/ZipLib.h	26;"	d
OLDROUTINENAMES	macos/ZipSx.h	26;"	d
OLD_COMPRESS	vms/vms_im.c	43;"	d	file:
OLD_STATUS	vms/vms.c	209;"	d	file:
ONENAMELEN	amiga/amigazip.c	48;"	d	file:
ONENAMELEN	msdos/msdos.c	175;"	d	file:
ONENAMELEN	msdos/msdos.c	177;"	d	file:
ONENAMELEN	win32/win32zip.c	615;"	d	file:
OPT	unix/configure	/^  OPT=""$/;"	v
OPTIONERR_BUF_SIZE	fileio.c	3713;"	d	file:
OPT_C	vms/cmdline.c	512;"	d	file:
OPT_C2	vms/cmdline.c	514;"	d	file:
OPT_C2N	vms/cmdline.c	515;"	d	file:
OPT_C5	vms/cmdline.c	516;"	d	file:
OPT_C5N	vms/cmdline.c	517;"	d	file:
OPT_CN	vms/cmdline.c	513;"	d	file:
OPT_DB	vms/cmdline.c	978;"	d	file:
OPT_DC	vms/cmdline.c	979;"	d	file:
OPT_DD	vms/cmdline.c	980;"	d	file:
OPT_DF	vms/cmdline.c	648;"	d	file:
OPT_DG	vms/cmdline.c	981;"	d	file:
OPT_DS	vms/cmdline.c	982;"	d	file:
OPT_DU	vms/cmdline.c	983;"	d	file:
OPT_DV	vms/cmdline.c	984;"	d	file:
OPT_FD	vms/cmdline.c	633;"	d	file:
OPT_FS	vms/cmdline.c	702;"	d	file:
OPT_FZ	vms/cmdline.c	1214;"	d	file:
OPT_H2	vms/cmdline.c	729;"	d	file:
OPT_IC	vms/cmdline.c	606;"	d	file:
OPT_ICN	vms/cmdline.c	607;"	d	file:
OPT_LA	vms/cmdline.c	1063;"	d	file:
OPT_LF	vms/cmdline.c	1064;"	d	file:
OPT_LI	vms/cmdline.c	1065;"	d	file:
OPT_MM	vms/cmdline.c	1256;"	d	file:
OPT_NW	vms/cmdline.c	1229;"	d	file:
OPT_S	vms/cmdline.c	1106;"	d	file:
OPT_SB	vms/cmdline.c	1107;"	d	file:
OPT_SC	vms/cmdline.c	1165;"	d	file:
OPT_SD	vms/cmdline.c	1166;"	d	file:
OPT_SF	vms/cmdline.c	1167;"	d	file:
OPT_SO	vms/cmdline.c	1168;"	d	file:
OPT_SP	vms/cmdline.c	1108;"	d	file:
OPT_SV	vms/cmdline.c	1109;"	d	file:
OPT_TT	vms/cmdline.c	1271;"	d	file:
OPT_W	vms/cmdline.c	1230;"	d	file:
OPT_X	vms/cmdline.c	1389;"	d	file:
OPT_XN	vms/cmdline.c	1390;"	d	file:
OPT_ZB	vms/cmdline.c	1293;"	d	file:
OPT_ZD	vms/cmdline.c	1294;"	d	file:
OPT_ZS	vms/cmdline.c	1295;"	d	file:
OS	INSTALL	/^     The steps for installation under VMS, MSDOS, OS\/2, NT, Amiga and$/;"	v
OS	INSTALL	/^     wide range of systems:  Unix, VMS, MSDOS, OS\/2, NT, Amiga, Atari,$/;"	v
OS	macos/README.TXT	/^Amiga, Acorn RISC OS, and other systems.$/;"	v
OS	macos/README.TXT	/^VMS, MSDOS, OS\/2, Windows 9x, Windows NT, Atari, Macintosh,$/;"	v
OS	vms/VMS_ZIP.RNH	/^systems, including UNIX, VMS,  MSDOS, OS\/2, Windows 9x\/NT\/XP, Minix, Atari,$/;"	v
OS	vms/zip_cli.help	/^systems, including UNIX, VMS,  MSDOS, OS\/2, Windows 9x\/NT\/XP, Minix,$/;"	v
OS2	os2/osdep.h	10;"	d
OS2	proginfo/ZipPorts	/^      it:  AMIGA, ATARI_ST, __human68k__, MACOS, MSDOS, MVS, OS2, TOPS20,$/;"	v
OS_CODE	tailor.h	800;"	d
OS_CODE	tailor.h	803;"	d
OS_CODE	tailor.h	807;"	d
OS_CODE	tailor.h	810;"	d
OS_CODE	tailor.h	813;"	d
OS_CODE	tailor.h	816;"	d
OS_CODE	tailor.h	821;"	d
OS_CODE	tailor.h	824;"	d
OS_CODE	tailor.h	827;"	d
OS_CODE	tailor.h	830;"	d
OS_CODE	tailor.h	833;"	d
OS_CODE	tailor.h	836;"	d
OS_CODE	tailor.h	839;"	d
OS_CODE	tailor.h	842;"	d
OS_CODE	tailor.h	845;"	d
OS_CODE	tailor.h	849;"	d
OS_CODE	tailor.h	856;"	d
OS_CODE	tailor.h	860;"	d
OS_NAME	unix/unix.c	830;"	d	file:
OS_NAME1	msdos/msdos.c	931;"	d	file:
OS_NAME2	msdos/msdos.c	937;"	d	file:
OVERRIDE_BACKUP	win32/nt.h	55;"	d
OVERRIDE_RESTORE	win32/nt.h	56;"	d
OVERRIDE_SACL	win32/nt.h	57;"	d
OWNER_SECURITY_INFORMATION	win32/rsxntwin.h	122;"	d
O_APPEND	macos/source/unixlike.h	74;"	d
O_BINARY	amiga/amiga.h	36;"	d
O_BINARY	amiga/amiga.h	45;"	d
O_BINARY	qdos/qdos.c	627;"	d	file:
O_BINARY	unix/zipup.h	15;"	d
O_BINARY	win32/zipup.h	18;"	d
O_CREAT	macos/source/unixlike.h	75;"	d
O_EXCL	macos/source/unixlike.h	76;"	d
O_RAW	amiga/zipup.h	13;"	d
O_RDONLY	atari/zipup.h	10;"	d
O_RDONLY	qdos/zipup.h	10;"	d
O_RDONLY	tandem/zipup.h	10;"	d
O_RDONLY	theos/zipup.h	10;"	d
O_RDONLY	tops20/tops20.c	24;"	d	file:
O_RDONLY	tops20/zipup.h	9;"	d
O_RDONLY	unix/zipup.h	12;"	d
O_RDONLY	win32/zipup.h	15;"	d
O_T20_WILD	tops20/tops20.c	25;"	d	file:
O_TRUNC	macos/source/unixlike.h	77;"	d
O_UNCONVERTED	tops20/zipup.h	10;"	d
OemToAnsi	win32/osdep.h	352;"	d
OnLine	macos/source/macstuff.c	/^pascal  OSErr   OnLine(FSSpecPtr volumes,$/;"	f	signature:(FSSpecPtr volumes, short reqVolCount, short *actVolCount, short *volIndex)
OpenDirScan	win32/win32zip.c	/^local zDIRSCAN *OpenDirScan(n)$/;"	f
OpenDirScanW	win32/win32zip.c	/^local zDIRSCANW *OpenDirScanW(nw)$/;"	f
Options	api.c	/^ZPOPT Options;$/;"	v
P1	vms/zip_cli.cld	/^	Parameter	P1, Label=ZIPFILE, Prompt="Zip file"$/;"	v
P3	vms/collect_deps.com	/^$!    collect all source file dependencies specified by P3,$/;"	v
PACL	win32/rsxntwin.h	/^typedef ACL *PACL;$/;"	t
PAD	acorn/acornzip.c	15;"	d	file:
PAD	amiga/amigazip.c	16;"	d	file:
PAD	aosvs/aosvs.c	19;"	d	file:
PAD	atari/atari.c	21;"	d	file:
PAD	atheos/atheos.c	30;"	d	file:
PAD	beos/beos.c	37;"	d	file:
PAD	cmsmvs/cmsmvs.c	38;"	d	file:
PAD	fileio.c	50;"	d	file:
PAD	fileio.c	52;"	d	file:
PAD	human68k/human68k.c	20;"	d	file:
PAD	msdos/msdos.c	78;"	d	file:
PAD	novell/Netware.c	44;"	d	file:
PAD	os2/os2.c	19;"	d	file:
PAD	qdos/qfileio.c	31;"	d	file:
PAD	theos/theos.c	36;"	d	file:
PAD	tops20/tops20.c	19;"	d	file:
PAD	unix/unix.c	45;"	d	file:
PAD	vms/vms_im.c	76;"	d	file:
PAD	vms/vms_im.c	78;"	d	file:
PAD	win32/win32zip.c	34;"	d	file:
PAD0	vms/vms_im.c	81;"	d	file:
PAGESIZE	zipup.c	48;"	d	file:
PARSE	WHATSNEW	/^- On VMS (recent, non-VAX), with SET PROCESS \/PARSE = EXTEND,$/;"	v
PARSE_STYLE	vms/NOTES.TXT	/^sufficiently recent C RTL, and SET PROCESS \/PARSE_STYLE = EXTENDED.$/;"	v
PASCAL	win32/rsxntwin.h	27;"	d
PASSWD_FROM_STDIN	cmsmvs/cmsmvs.h	59;"	d
PASSWD_FROM_STDIN	macos/osdep.h	33;"	d
PASSWD_FROM_STDIN	tandem/tandem.h	44;"	d
PATHCUT	macos/osdep.h	60;"	d
PATHCUT	zipfile.c	358;"	d	file:
PATHNAME_H	macos/source/pathname.h	10;"	d
PATH_END	acorn/acornzip.c	16;"	d	file:
PATH_END	amiga/amigazip.c	17;"	d	file:
PATH_END	aosvs/aosvs.c	20;"	d	file:
PATH_END	atari/atari.c	22;"	d	file:
PATH_END	atheos/atheos.c	31;"	d	file:
PATH_END	beos/beos.c	38;"	d	file:
PATH_END	cmsmvs/cmsmvs.c	39;"	d	file:
PATH_END	macos/source/macos.c	48;"	d	file:
PATH_END	msdos/msdos.c	79;"	d	file:
PATH_END	novell/Netware.c	45;"	d	file:
PATH_END	os2/os2.c	20;"	d	file:
PATH_END	qdos/qfileio.c	32;"	d	file:
PATH_END	tops20/tops20.c	16;"	d	file:
PATH_END	unix/unix.c	46;"	d	file:
PATH_END	win32/win32zip.c	35;"	d	file:
PATH_MAX	api.h	19;"	d
PATH_MAX	api.h	23;"	d
PATH_START	tops20/tops20.c	15;"	d	file:
PBXGetVolInfoSync	macos/source/macstuff.c	/^pascal OSErr PBXGetVolInfoSync(XVolumeParamPtr paramBlock)$/;"	f	signature:(XVolumeParamPtr paramBlock)
PC_MAX_RND	zipup.c	276;"	d	file:
PC_MAX_SAFE	zipup.c	275;"	d	file:
PEFHEADER	os2/os2zip.c	/^EFHEADER, *PEFHEADER;$/;"	t	typeref:struct:__anon13	file:
PEF_NTSD_C_HEADER	win32/nt.h	/^EF_NTSD_C_HEADER, *PEF_NTSD_C_HEADER;$/;"	t	typeref:struct:__anon4
PEF_NTSD_L_HEADER	win32/nt.h	/^IZ_PACKED EF_NTSD_L_HEADER, *PEF_NTSD_L_HEADER;$/;"	t	typeref:struct:__anon5
PERR	ziperr.h	112;"	d
PFEA2	os2/os2zip.c	/^FEA2, *PFEA2;$/;"	t	typeref:struct:__anon14	file:
PFEA2LIST	os2/os2zip.c	/^FEA2LIST, *PFEA2LIST;$/;"	t	typeref:struct:__anon15	file:
PK_FLDHDR_SIZE	vms/vms.h	340;"	d
PK_HEADER_SIZE	vms/vms.h	350;"	d
PK_SIGNATURE	vms/vms.h	327;"	d
PK_def_info	vms/vms_pk.c	/^static PK_info_t PK_def_info =$/;"	v	file:
PK_field	vms/vms.h	/^struct PK_field$/;"	s
PK_field::size	vms/vms.h	/^    ush         size;$/;"	m	struct:PK_field	access:public
PK_field::tag	vms/vms.h	/^    ush         tag;$/;"	m	struct:PK_field	access:public
PK_field::value	vms/vms.h	/^    byte        value[1];$/;"	m	struct:PK_field	access:public
PK_header	vms/vms.h	/^struct PK_header$/;"	s
PK_header::crc32	vms/vms.h	/^    ulg crc32;$/;"	m	struct:PK_header	access:public
PK_header::data	vms/vms.h	/^    byte data[1];$/;"	m	struct:PK_header	access:public
PK_header::size	vms/vms.h	/^    ush size;$/;"	m	struct:PK_header	access:public
PK_header::tag	vms/vms.h	/^    ush tag;$/;"	m	struct:PK_header	access:public
PK_info_t	vms/vms.h	/^} PK_info_t;$/;"	t	typeref:struct:__anon23
PK_info_t	vms/vms.h	/^} PK_info_t;$/;"	t	typeref:struct:__anon24
PKi	vms/vms_pk.c	/^    PK_info_t           PKi;$/;"	m	struct:__anon22	file:	access:public
PLUID	win32/rsxntwin.h	/^} LUID, *PLUID;$/;"	t	typeref:struct:_LUID
PLUID_AND_ATTRIBUTES	win32/rsxntwin.h	/^    } LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES;$/;"	t	typeref:struct:_LUID_AND_ATTRIBUTES
POSTINCSTR	tailor.h	349;"	d
POSTINCSTR	tailor.h	359;"	d
PREINCSTR	tailor.h	348;"	d
PREINCSTR	tailor.h	358;"	d
PRESTART_HOOK	amiga/amiga.c	86;"	d	file:
PROCNAME	acorn/osdep.h	17;"	d
PROCNAME	amiga/osdep.h	35;"	d
PROCNAME	atari/osdep.h	16;"	d
PROCNAME	human68k/osdep.h	21;"	d
PROCNAME	macos/osdep.h	115;"	d
PROCNAME	msdos/osdep.h	135;"	d
PROCNAME	novell/osdep.h	130;"	d
PROCNAME	os2/osdep.h	92;"	d
PROCNAME	qdos/osdep.h	31;"	d
PROCNAME	vms/osdep.h	31;"	d
PROCNAME	win32/osdep.h	67;"	d
PROCNAME	zip.c	1259;"	d	file:
PSECURITY_DESCRIPTOR	win32/rsxntwin.h	/^typedef PVOID PSECURITY_DESCRIPTOR;$/;"	t
PSECURITY_DESCRIPTOR_CONTROL	win32/rsxntwin.h	/^typedef WORD SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL;$/;"	t
PSECURITY_INFORMATION	win32/rsxntwin.h	/^typedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION;$/;"	t
PSID	win32/rsxntwin.h	/^typedef PVOID PSID;$/;"	t
PSTR16	os2/os2acl.c	73;"	d	file:
PSTR16	os2/os2acl.c	76;"	d	file:
PSTR16	os2/os2acl.c	81;"	d	file:
PTOKEN_PRIVILEGES	win32/rsxntwin.h	/^} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;$/;"	t	typeref:struct:_TOKEN_PRIVILEGES
PTR	msdos/crc_i86.asm	/^        cmp     WORD PTR [bp+8+LCOD_OFS],0      ; buf == NULL ?$/;"	v
PTR	msdos/crc_i86.asm	/^        enter   WORD PTR 0,0$/;"	v
PTR	msdos/crc_i86.asm	/^        les     di,DWORD PTR [bp+8+LCOD_OFS]    ;buf$/;"	v
PTR	msdos/crc_i86.asm	/^        mov     WORD PTR [bp+10+LDAT_OFS+LCOD_OFS],cx$/;"	v
PTR	msdos/crc_i86.asm	/^        mov     ax,WORD PTR [bp+4+LCOD_OFS]     ;crc$/;"	v
PTR	msdos/crc_i86.asm	/^        mov     ax,WORD PTR [bp+8+LCOD_OFS]     ; buf$/;"	v
PTR	msdos/crc_i86.asm	/^        mov     cx,WORD PTR [bp+10+LCOD_OFS]    ;len$/;"	v
PTR	msdos/crc_i86.asm	/^        mov     cx,WORD PTR [bp+12+LCOD_OFS]    ;len$/;"	v
PTR	msdos/crc_i86.asm	/^        mov     di,WORD PTR [bp+8+LCOD_OFS]     ;buf$/;"	v
PTR	msdos/crc_i86.asm	/^        or      ax,WORD PTR [bp+10+LCOD_OFS]    ;     == NULL ?$/;"	v
PTR16	os2/os2acl.c	74;"	d	file:
PTR16	os2/os2acl.c	77;"	d	file:
PTR16	os2/os2acl.c	82;"	d	file:
PToCCpy	macos/source/helpers.c	/^char *PToCCpy(unsigned char *pstr, char *cstr)$/;"	f	signature:(unsigned char *pstr, char *cstr)
PUTBYTE	trees.c	409;"	d	file:
PUTC	ttyio.c	43;"	d	file:
PUTLG	zipfile.c	59;"	d	file:
PUTLLG	zipfile.c	62;"	d	file:
PUTLOCAL_REWRITE	zip.h	991;"	d
PUTLOCAL_WRITE	zip.h	990;"	d
PUTSH	zipfile.c	58;"	d	file:
PUTSHORT	trees.c	402;"	d	file:
PVOLUMECAPS	win32/nt.h	/^} VOLUMECAPS, *PVOLUMECAPS, *LPVOLUMECAPS;$/;"	t	typeref:struct:__anon6
PWLEN	crypt.h	120;"	d
P_WAIT	zip.c	48;"	d	file:
ParseArguments	macos/source/helpers.c	/^int ParseArguments(char *s, char ***arg)$/;"	f	signature:(char *s, char ***arg)
ParseLine	macos/source/getenv.c	/^EnviromentPair *ParseLine(char *line)$/;"	f	signature:(char *line)
ParseString	api.c	/^int ParseString(LPSTR s, unsigned int ArgC)$/;"	f	signature:(LPSTR s, unsigned int ArgC)
Parse_TZ	timezone.c	/^static int Parse_TZ(name, sp)$/;"	f	file:
Pattern	macos/source/macglob.h	/^    char            Pattern[NAME_MAX];$/;"	m	struct:__anon17	access:public
Pos	deflate.c	/^  typedef unsigned Pos; \/* must be at least 32 bits *\/$/;"	t	file:
Prev	amiga/deflate.a	/^        move.w  Head,(Prev,\\2.l)        ; prev[str_start & WMASK] = hash_head$/;"	v
Prev	amiga/deflate.a	/^WindTop equr    Prev                    ; local variable used for sliding$/;"	v
Prev	human68k/deflate.s	/^        move.w  Head,(Prev,_2.l)        ; prev[str_start & WMASK] = hash_head$/;"	v
Prev	human68k/deflate.s	/^WindTop reg     Prev                    ; local variable used for sliding$/;"	v
PrevL	amiga/deflate.a	/^        dbra    PrevL,insertmatch$/;"	v
PrevL	amiga/deflate.a	/^        moveq   #0,PrevL                ; not needed?$/;"	v
PrevL	amiga/deflate.a	/^        subq.w  #3,PrevL                ; convert for dbra (prev_length - 2)$/;"	v
PrevL	amiga/deflate.a	/^SlidIx  equr    PrevL                   ; local variable used for sliding$/;"	v
PrevL	human68k/deflate.s	/^        dbra    PrevL,insertmatch$/;"	v
PrevL	human68k/deflate.s	/^        moveq   #0,PrevL                ; not needed?$/;"	v
PrevL	human68k/deflate.s	/^SlidIx  reg     PrevL                   ; local variable used for sliding$/;"	v
PrevM	amiga/deflate.a	/^        ; CHECK_MATCH   Strst-1,PrevM,PrevL$/;"	v
PrevM	human68k/deflate.s	/^        ; CHECK_MATCH   Strst-1,PrevM,PrevL$/;"	v
PrintArguments	macos/source/helpers.c	/^void PrintArguments(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
PrintFileInfo	macos/source/extrafld.c	/^static void PrintFileInfo(void)$/;"	f	file:	signature:(void)
PrintStatProgress	macos/source/macos.c	/^void PrintStatProgress(char *msg)$/;"	f	signature:(char *msg)
PrintUserHFSerr	macos/source/helpers.c	/^int PrintUserHFSerr(int cond, int err, char *msg2)$/;"	f	signature:(int cond, int err, char *msg2)
PrivilegeCount	win32/rsxntwin.h	/^    DWORD PrivilegeCount;$/;"	m	struct:_TOKEN_PRIVILEGES	access:public
Privileges	win32/rsxntwin.h	/^    LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];$/;"	m	struct:_TOKEN_PRIVILEGES	access:public
Pro	win32/crc_i386.asm	/^    ELSE ; __686 : optimize for Pentium Pro, Pentium II and compatible CPUs$/;"	v
Pro	win32/crc_i386.asm	/^;   (like the Pentium Pro, Pentium II, and probably some Pentium clones).$/;"	v
Pro	win32/crc_i386.asm	/^__686   EQU     1 ; optimize for Pentium Pro, Pentium II and compatible CPUs$/;"	v
ProcessDirectory	macos/source/recurse.c	/^static void ProcessDirectory(RecurseGlobals *Globals,$/;"	f	file:	signature:(RecurseGlobals *Globals, Boolean IncludeItem, long DirID)
ProcessFiles	macos/source/recurse.c	/^static void ProcessFiles(RecurseGlobals *Globals,$/;"	f	file:	signature:(RecurseGlobals *Globals, Boolean hasDataFork, Boolean hasResourceFork)
ProcessItem	macos/source/recurse.c	/^static void ProcessItem(RecurseGlobals *Globals, long DirID)$/;"	f	file:	signature:(RecurseGlobals *Globals, long DirID)
Prompt	vms/zip_cli.cld	/^	Parameter	P1, Label=ZIPFILE, Prompt="Zip file"$/;"	v
Prompt	vms/zip_cli.cld	/^	Parameter	P2, Label=INFILE, VALUE(list), Prompt="Files to Zip"$/;"	v
QDOS	qdos/IZREADME.SMS	/^IZREADME_SMS (IZREADME.SMS): Info-ZIP for SMS\/QDOS,   last revised: 15-Jun-1998$/;"	v
QDOS_FLMAX	qdos/qdos.c	83;"	d	file:
QDOSexit	qdos/qdos.c	/^void QDOSexit(void)$/;"	f	signature:(void)
QTHasFSSpecCalls	macos/source/macstuff.c	/^static  Boolean QTHasFSSpecCalls(void)$/;"	f	file:	signature:(void)
RABL	vms/vms.h	233;"	d
RAND_HEAD_LEN	crypt.h	122;"	d
READONLY	acorn/match.s	/^                AREA    |C$$code|, CODE, READONLY$/;"	v
READONLY	acorn/sendbits.s	/^        AREA    |Asm$$Code|, CODE, READONLY$/;"	v
READONLY	acorn/swiven.s	/^                AREA    |C$$code|, CODE, READONLY$/;"	v
READ_REST_ARGS_VERBATIM	fileio.c	3703;"	d	file:
REALLY_SHORT_SYMS	tops20/osdep.h	18;"	d
RECFMs	proginfo/fileinfo.cms	/^     CMS supports only two RECFMs, V and F.  [note that MVS supports$/;"	v
RECLEN	cmsmvs/mvs.h	33;"	d
RECORD	cmsmvs/mvs.h	/^} RECORD;$/;"	t	typeref:struct:__anon21
REENTRANT	amiga/osdep.h	55;"	d
REENTRANT	win32/osdep.h	301;"	d
REPZ_11_138	trees.c	211;"	d	file:
REPZ_3_10	trees.c	208;"	d	file:
REP_3_6	trees.c	205;"	d	file:
RESL	vms/vms.h	242;"	d
RESTORE_RTYPE	vms/vmsmunch.h	46;"	d
RETURN	tailor.h	868;"	d
RETURN	tandem/tandem.h	66;"	d
RETURN	vms/osdep.h	139;"	d
RET_EOF	theos/theos.c	40;"	d	file:
RET_EOF	vms/vms_im.c	59;"	d	file:
RET_ERROR	theos/theos.c	38;"	d	file:
RET_ERROR	vms/vms_im.c	57;"	d	file:
RET_SUCCESS	theos/theos.c	39;"	d	file:
RET_SUCCESS	vms/vms_im.c	58;"	d	file:
REVDATE	revision.h	25;"	d
REV_BE	crc32.h	52;"	d
REV_BE	crc32.h	57;"	d
RISCOS	acorn/osdep.h	11;"	d
RMS_DEQ_DEFAULT	vms/vms.c	653;"	d	file:
RMS_MBC_DEFAULT	vms/vms.c	654;"	d	file:
RMS_MBF_DEFAULT	vms/vms.c	655;"	d	file:
ROUNDED_TIME	human68k/osdep.h	19;"	d
ROUNDED_TIME	msdos/osdep.h	134;"	d
ROUNDED_TIME	novell/osdep.h	129;"	d
ROUNDED_TIME	os2/osdep.h	96;"	d
ROUNDED_TIME	tailor.h	380;"	d
Raiter	win32/gvmat64.asm	/^;        from Brian Raiter, written 1998$/;"	v
Raiter	win32/readme.a64	/^and modifying asm686 (1998), optimised assembly code from Brian Raiter,$/;"	v
RawCountOfItems	macos/source/macglob.h	/^    unsigned long   RawCountOfItems;$/;"	m	struct:__anon17	access:public
Rcount	globals.c	/^unsigned Rcount = 0;            \/* number of -R include patterns *\/$/;"	v
ReadNumString	util.c	/^uzoff_t ReadNumString( numstring )$/;"	f
Real2RfDfFilen	macos/source/pathname.c	/^char *Real2RfDfFilen(char *RfDfFilen, const char *RealPath,$/;"	f	signature:(char *RfDfFilen, const char *RealPath, short CurrentFork, short MacZipMode, Boolean DataForkOnly)
RecurseDirectory	macos/source/recurse.c	/^pascal  OSErr   RecurseDirectory(short vRefNum,$/;"	f	signature:(short vRefNum, long thedirID, ConstStr255Param name, unsigned short maxLevels)
RecurseDirectoryLevel	macos/source/recurse.c	/^static  void    RecurseDirectoryLevel(long DirID, RecurseGlobals *Globals)$/;"	f	file:	signature:(long DirID, RecurseGlobals *Globals)
RecurseGlobals	macos/source/recurse.c	/^struct RecurseGlobals$/;"	s	file:
RecurseGlobals	macos/source/recurse.c	/^typedef struct RecurseGlobals RecurseGlobals;$/;"	t	typeref:struct:RecurseGlobals	file:
RecurseGlobals::FullPath	macos/source/recurse.c	/^    char                    *FullPath;$/;"	m	struct:RecurseGlobals	file:	access:public
RecurseGlobals::FullPathLen	macos/source/recurse.c	/^    short                   FullPathLen;$/;"	m	struct:RecurseGlobals	file:	access:public
RecurseGlobals::cPB	macos/source/recurse.c	/^    CInfoPBRec              cPB;            \/* the parameter block used for$/;"	m	struct:RecurseGlobals	file:	access:public
RecurseGlobals::currentLevel	macos/source/recurse.c	/^    unsigned short          currentLevel;   \/* The current level$/;"	m	struct:RecurseGlobals	file:	access:public
RecurseGlobals::itemName	macos/source/recurse.c	/^    unsigned char           *itemName;      \/* the name of the current item *\/$/;"	m	struct:RecurseGlobals	file:	access:public
RecurseGlobals::maxLevels	macos/source/recurse.c	/^    unsigned short          maxLevels;      \/* Maximum levels to$/;"	m	struct:RecurseGlobals	file:	access:public
RecurseGlobals::quitFlag	macos/source/recurse.c	/^    Boolean                 quitFlag;       \/* set to true if filter wants to$/;"	m	struct:RecurseGlobals	file:	access:public
RecurseGlobals::result	macos/source/recurse.c	/^    OSErr                   result;         \/* temporary holder of results -$/;"	m	struct:RecurseGlobals	file:	access:public
RecurseGlobals::vRefNum	macos/source/recurse.c	/^    short                   vRefNum;$/;"	m	struct:RecurseGlobals	file:	access:public
RecurseGlobalsPtr	macos/source/recurse.c	/^typedef RecurseGlobals *RecurseGlobalsPtr;$/;"	t	file:
ReqVers	amiga/filedate.c	165;"	d	file:
ResourceFork	macos/source/macglob.h	18;"	d
ResourceFork	macos/source/pathname.h	55;"	d
ResourceMark	macos/source/pathname.c	/^const char  ResourceMark[] = "XtraStuf.mac:";  \/* see also macos.c *\/$/;"	v
RfDfFilen2Real	macos/source/pathname.c	/^char *RfDfFilen2Real(char *RealFn, const char *RfDfFilen, short MacZipMode,$/;"	f	signature:(char *RealFn, const char *RfDfFilen, short MacZipMode, Boolean DataForkOnly, short *CurrentFork)
Rommel	amiga/deflate.a	/^; material is based on deflate.c, by Gailly, Rommel, and Igor Mandrichenko.$/;"	v
Rommel	human68k/deflate.s	/^; this material is based on deflate.c, by Gailly, Rommel, and Igor Mandrichenko.$/;"	v
RootPath	win32/nt.h	/^    char RootPath[MAX_PATH+1];  \/* path to network \/ filesystem *\/$/;"	m	struct:__anon6	access:public
SACL_SECURITY_INFORMATION	win32/rsxntwin.h	125;"	d
SAS	amiga/match.a	/^; This code will run with registerized parameters too, unless SAS$/;"	v
SAS	qdos/match.s	/^; This code will run with registerized parameters too, unless SAS$/;"	v
SBSZ	tailor.h	463;"	d
SBSZ	tandem/tanzip.h	35;"	d
SBSZ	tandem/tanzip.h	40;"	d
SCAN_BUFSIZE	zipfile.c	4006;"	d	file:
SCAN_BUFSIZE	zipfile.c	4013;"	d	file:
SCAN_BUFSIZE	zipfile.c	4014;"	d	file:
SCAN_BUFSIZE	zipfile.c	4017;"	d	file:
SCAN_BUFSIZE	zipfile.c	4018;"	d	file:
SECSPERDAY	amiga/filedate.c	189;"	d	file:
SECSPERDAY	timezone.c	68;"	d	file:
SECSPERHOUR	amiga/filedate.c	188;"	d	file:
SECSPERHOUR	timezone.c	67;"	d	file:
SECSPERHOUR	win32/win32.c	1022;"	d	file:
SECSPERMIN	amiga/filedate.c	186;"	d	file:
SECSPERMIN	timezone.c	61;"	d	file:
SECSPERMIN	win32/win32.c	1020;"	d	file:
SECURITY_DESCRIPTOR_CONTROL	win32/rsxntwin.h	/^typedef WORD SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL;$/;"	t
SECURITY_INFORMATION	win32/rsxntwin.h	/^typedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION;$/;"	t
SEEK_CUR	tailor.h	299;"	d
SEEK_CUR	vms/unixio_gcc.h	19;"	d
SEEK_END	vms/unixio_gcc.h	23;"	d
SEEK_SET	tailor.h	295;"	d
SEEK_SET	vms/unixio_gcc.h	15;"	d
SETLOCALE	tailor.h	354;"	d
SETLOCALE	tailor.h	364;"	d
SET_FILE_BUFFERED	tandem/tandem.h	99;"	d
SET_FILE_BUFFERSIZE	tandem/tandem.h	101;"	d
SET_FILE_MAXEXTENTS	tandem/tandem.h	100;"	d
SET_FILE_OWNER	tandem/tandem.h	98;"	d
SET_FILE_SECURITY	tandem/tandem.h	97;"	d
SET_LARGE_TRANSFERS	tandem/tandem.h	102;"	d
SET_TIMES	vms/vmsmunch.h	43;"	d
SE_BACKUP_NAME	win32/rsxntwin.h	134;"	d
SE_DACL_PRESENT	win32/rsxntwin.h	128;"	d
SE_PRIVILEGE_ENABLED	win32/rsxntwin.h	131;"	d
SE_RESTORE_NAME	win32/rsxntwin.h	135;"	d
SE_SACL_PRESENT	win32/rsxntwin.h	129;"	d
SE_SECURITY_NAME	win32/rsxntwin.h	133;"	d
SH	fileio.c	/^ ush SH(uch* p) { return ((ush)(uch)((p)[0]) | ((ush)(uch)((p)[1]) << 8)); }$/;"	f	signature:(uch* p)
SH	fileio.c	1551;"	d	file:
SH	zipfile.c	/^ ush SH(uch* p) { return ((ush)(uch)((p)[0]) | ((ush)(uch)((p)[1]) << 8)); }$/;"	f	signature:(uch* p)
SH	zipfile.c	50;"	d	file:
SHELL	qdos/Makefile.qlzip	/^SHELL = \/bin\/sh$/;"	v
SHORTID	qdos/qdos.c	101;"	d	file:
SH_DENYNO	win32/zipup.h	21;"	d
SIGIOERR	proginfo/fileinfo.cms	/^     a truncation, it sets errno and raises SIGIOERR, if SIGIOERR is not$/;"	v
SIZE	msdos/match.asm	/^        and     si,WSIZE-1              ; not needed if WSIZE=32768$/;"	v
SIZE	os2/match32.asm	/^        and     esi,WSIZE-1             ; not needed if WSIZE=32768$/;"	v
SKIP_MASK	cmsmvs/mvs.h	31;"	d
SKIP_VALUE_ARG	fileio.c	3696;"	d	file:
SLOW	deflate.c	108;"	d	file:
SMALLEST	trees.c	574;"	d	file:
SPARKID	acorn/riscos.h	73;"	d
SPARKID_2	acorn/riscos.h	74;"	d
SPLIT_MAXPATH	fileio.c	2031;"	d	file:
SS$_BADPARAM	vms/vmsmunch.c	173;"	d	file:
SS$_NORMAL	vms/vmsmunch.c	172;"	d	file:
SSTAT	msdos/osdep.h	167;"	d
SSTAT	novell/osdep.h	162;"	d
SSTAT	tailor.h	725;"	d
SSTAT	tailor.h	744;"	d
SSTAT	vms/osdep.h	137;"	d
SSTAT	win32/osdep.h	565;"	d
SSTAT	win32/osdep.h	567;"	d
SSTATW	tailor.h	727;"	d
SSTATW	win32/osdep.h	569;"	d
START_VALUE_LIST	fileio.c	3698;"	d	file:
STATIC_TREES	trees.c	168;"	d	file:
STDIO_BUF_SIZE	windll/windll.c	113;"	d	file:
STOP_VALUE_LIST	fileio.c	3701;"	d	file:
STORE	zip.h	329;"	d
STORED_BLOCK	trees.c	167;"	d	file:
STTY	ttyio.c	130;"	d	file:
STTY	ttyio.c	146;"	d	file:
STTY	ttyio.c	154;"	d	file:
SUB	proginfo/txtvsbin.txt	/^  7 (BEL), 8 (BS), 11 (VT), 12 (FF), 26 (SUB), 27 (ESC)$/;"	v
SUCCESS	amiga/filedate.c	161;"	d	file:
SUCCESS	amiga/stat.c	46;"	d	file:
SWAPW	vms/vms_pk.c	289;"	d	file:
SYI$_VERSION	vms/vms.h	45;"	d
S_IARCHIVE	amiga/z-stat.h	65;"	d
S_IDELETE	amiga/z-stat.h	69;"	d
S_IEGRP	theos/stat.h	48;"	d
S_IEUSR	theos/stat.h	42;"	d
S_IEXEC	acorn/riscos.h	93;"	d
S_IEXEC	cmsmvs/cstat.h	28;"	d
S_IEXEC	macos/source/unixlike.h	55;"	d
S_IEXEC	theos/stat.h	59;"	d
S_IEXECUTE	amiga/z-stat.h	68;"	d
S_IFBLK	cmsmvs/cstat.h	24;"	d
S_IFBLK	theos/stat.h	24;"	d
S_IFCHR	cmsmvs/cstat.h	23;"	d
S_IFCHR	theos/stat.h	20;"	d
S_IFDIR	acorn/riscos.h	89;"	d
S_IFDIR	amiga/z-stat.h	48;"	d
S_IFDIR	cmsmvs/cstat.h	21;"	d
S_IFDIR	theos/stat.h	22;"	d
S_IFIFO	cmsmvs/cstat.h	22;"	d
S_IFIFO	theos/stat.h	19;"	d
S_IFIND	theos/stat.h	28;"	d
S_IFKEY	theos/stat.h	27;"	d
S_IFLIB	theos/stat.h	23;"	d
S_IFLNK	tailor.h	385;"	d
S_IFLNK	win32/osdep.h	609;"	d
S_IFMT	acorn/riscos.h	87;"	d
S_IFMT	amiga/z-stat.h	59;"	d
S_IFMT	cmsmvs/cstat.h	20;"	d
S_IFMT	os2/os2zip.c	72;"	d	file:
S_IFMT	os2/osdep.h	122;"	d
S_IFMT	theos/stat.h	18;"	d
S_IFMT	win32/osdep.h	583;"	d
S_IFP16	theos/stat.h	31;"	d
S_IFP32	theos/stat.h	32;"	d
S_IFR16	theos/stat.h	30;"	d
S_IFREG	acorn/riscos.h	90;"	d
S_IFREG	amiga/z-stat.h	49;"	d
S_IFREG	cmsmvs/cstat.h	25;"	d
S_IFREG	theos/stat.h	25;"	d
S_IFREL	theos/stat.h	26;"	d
S_IFRND	theos/stat.h	29;"	d
S_IFSOCK	theos/stat.h	21;"	d
S_IHIDDEN	amiga/z-stat.h	62;"	d
S_IMODF	theos/stat.h	38;"	d
S_INHID	theos/stat.h	39;"	d
S_IPURE	amiga/z-stat.h	64;"	d
S_IREAD	acorn/riscos.h	95;"	d
S_IREAD	amiga/z-stat.h	66;"	d
S_IREAD	cmsmvs/cstat.h	26;"	d
S_IREAD	macos/source/unixlike.h	53;"	d
S_IREAD	theos/stat.h	58;"	d
S_IRGRP	theos/stat.h	49;"	d
S_IROTH	theos/stat.h	54;"	d
S_IRUSR	theos/stat.h	43;"	d
S_IRWXG	theos/stat.h	47;"	d
S_IRWXO	theos/stat.h	53;"	d
S_IRWXU	theos/stat.h	41;"	d
S_ISBLK	theos/stat.h	84;"	d
S_ISCHR	theos/stat.h	83;"	d
S_ISCRIPT	amiga/z-stat.h	63;"	d
S_ISDIR	theos/stat.h	82;"	d
S_ISGID	theos/stat.h	35;"	d
S_ISIND	theos/stat.h	89;"	d
S_ISKEY	theos/stat.h	88;"	d
S_ISLIB	theos/stat.h	81;"	d
S_ISLNK	theos/stat.h	91;"	d
S_ISPRG	theos/stat.h	90;"	d
S_ISREG	theos/stat.h	80;"	d
S_ISREL	theos/stat.h	87;"	d
S_ISSEQ	theos/stat.h	86;"	d
S_ISUID	theos/stat.h	34;"	d
S_ISVTX	theos/stat.h	36;"	d
S_IWGRP	theos/stat.h	50;"	d
S_IWOTH	theos/stat.h	55;"	d
S_IWRITE	acorn/riscos.h	94;"	d
S_IWRITE	amiga/z-stat.h	67;"	d
S_IWRITE	cmsmvs/cstat.h	27;"	d
S_IWRITE	macos/source/unixlike.h	54;"	d
S_IWRITE	qdos/qfileio.c	19;"	d	file:
S_IWRITE	qdos/qfileio.c	21;"	d	file:
S_IWRITE	theos/stat.h	60;"	d
S_IWRITE	unix/unix.c	19;"	d	file:
S_IWRITE	unix/unix.c	21;"	d	file:
S_IWRITE	unix/unix.c	25;"	d	file:
S_IWUSR	theos/stat.h	44;"	d
S_IXGRP	theos/stat.h	51;"	d
S_IXOTH	theos/stat.h	56;"	d
S_IXUSR	theos/stat.h	45;"	d
SavLen	crc_i386.S	144;"	d	file:
SavLen	win32/crc_i386.c	140;"	d	file:
SavLen	win32/crc_i386.c	165;"	d	file:
Save_DS	msdos/crc_i86.asm	/^ifdef Save_DS$/;"	v
Save_DS	msdos/match.asm	/^ifdef Save_DS$/;"	v
Sbz1	win32/rsxntwin.h	/^    BYTE  Sbz1;$/;"	m	struct:_ACL	access:public
Sbz2	win32/rsxntwin.h	/^    WORD   Sbz2;$/;"	m	struct:_ACL	access:public
Scan	amiga/deflate.a	/^        sub.l   Scan_Ini,Scan           ; assert: difference is 16 bits$/;"	v
Scan	human68k/deflate.s	/^        sub.l   Scan_Ini,Scan           ; assert: difference is 16 bits$/;"	v
Scan_End	amiga/deflate.a	/^        moveq   #0,Scan_End             ; likewise$/;"	v
Scan_End	human68k/deflate.s	/^        moveq   #0,Scan_End             ; likewise$/;"	v
Scan_Start	amiga/deflate.a	/^        moveq   #0,Scan_Start           ; clear 2nd & 4th bytes, use 1st & 3rd$/;"	v
Scan_Start	amiga/deflate.a	/^        swap    Scan_Start              ; swap is faster than 8 bit shift$/;"	v
Scan_Start	amiga/match_68.a	/^        moveq   #0,Scan_Start       ; clear 2nd and 4th bytes, use 1st & 3rd$/;"	v
Scan_Start	human68k/deflate.s	/^        moveq   #0,Scan_Start           ; clear 2nd & 4th bytes, use 1st & 3rd$/;"	v
Scan_Start	human68k/deflate.s	/^        swap    Scan_Start              ; swap is faster than 8 bit shift$/;"	v
Scan_Test	amiga/deflate.a	/^        moveq   #((MAX_MATCH-MIN_MATCH)\/16),Scan_Test     ; value = 15$/;"	v
Scan_Test	amiga/deflate.a	/^        moveq   #((MAX_MATCH-MIN_MATCH)\/2),Scan_Test    ; value = 127$/;"	v
Scan_Test	amiga/deflate.a	/^        moveq   #0,Scan_Test            ; likewise$/;"	v
Scan_Test	human68k/deflate.s	/^        moveq   #((MAX_MATCH-MIN_MATCH)\/16),Scan_Test     ; value = 15$/;"	v
Scan_Test	human68k/deflate.s	/^        moveq   #((MAX_MATCH-MIN_MATCH)\/2),Scan_Test    ; value = 127$/;"	v
Scan_Test	human68k/deflate.s	/^        moveq   #0,Scan_Test            ; likewise$/;"	v
SearchDir	macos/source/macglob.h	/^    char            SearchDir[NAME_MAX];$/;"	m	struct:__anon17	access:public
SearchLevels	macos/source/macglob.h	/^    unsigned short  SearchLevels;$/;"	m	struct:__anon17	access:public
SearchPath	win32/rsxntwin.h	72;"	d
Security	proginfo/extrafld.txt	/^              Science and RSA Data Security, Inc., April 1992.$/;"	v
SecurityGet	win32/nt.c	/^BOOL SecurityGet($/;"	f	signature:( char *resource, PVOLUMECAPS VolumeCaps, unsigned char *buffer, DWORD *cbBuffer )
ServiceApplication	api.h	/^  DLLSERVICE *ServiceApplication;$/;"	m	struct:__anon32	access:public
ServiceApplication	windll/windll.txt	/^DLLSERVICE *ServiceApplication;$/;"	m	struct:__anon20	file:	access:public
ServiceApplication64	api.h	/^  DLLSERVICE *ServiceApplication64;$/;"	m	struct:__anon32	access:public
ServiceApplication64	windll/windll.txt	/^DLLSERVICE *ServiceApplication64;$/;"	m	struct:__anon20	file:	access:public
ServiceApplication64_No_Int64	api.h	/^  DLLSERVICE_NO_INT64 *ServiceApplication64_No_Int64;$/;"	m	struct:__anon32	access:public
ServiceApplication64_No_Int64	windll/windll.txt	/^DLLSERVICE_NO_INT64 *ServiceApplication64_No_Int64;$/;"	m	struct:__anon20	file:	access:public
SetFileMode	msdos/msdos.c	28;"	d	file:
SetFileMode	msdos/msdos.c	70;"	d	file:
SetFileMode	msdos/msdos.c	74;"	d	file:
SetFileTime	os2/os2zip.c	/^void SetFileTime(char *path, ulg stamp)$/;"	f	signature:(char *path, ulg stamp)
SetVolumeLabel	win32/rsxntwin.h	54;"	d
Set_LineNum	macos/source/getenv.c	/^void Set_LineNum(unsigned ln)$/;"	f	signature:(unsigned ln)
ShowAllKeyValues	macos/source/getenv.c	/^void ShowAllKeyValues(void)$/;"	f	signature:(void)
ShowCounter	macos/source/macos.c	/^void ShowCounter(Boolean reset)$/;"	f	signature:(Boolean reset)
SlidIx	amiga/deflate.a	/^        dbra    SlidIx,slide$/;"	v
SlidIx	amiga/deflate.a	/^; we exclude More, WindTop, SlidIx, Look, Strst, Window, a4 and a7.$/;"	v
SlidIx	human68k/deflate.s	/^        dbra    SlidIx,slide$/;"	v
SlidIx	human68k/deflate.s	/^; we exclude More, WindTop, SlidIx, Look, Strst, Window, a4 and a7.$/;"	v
Spieler	msdos/crc_i86.asm	/^; Created by Christian Spieler, last modified 07 Jan 2007.$/;"	v
StatingProgress	macos/source/macglob.h	/^    Boolean         StatingProgress;$/;"	m	struct:__anon17	access:public
Steger	amiga/match_68.a	/^; Paul Kienitz, partially derived from a simpler version by Carsten Steger,$/;"	v
StoreFoldersAlso	macos/source/macglob.h	/^    Boolean         StoreFoldersAlso;  \/* internal switch is true if '-r' is set *\/$/;"	m	struct:__anon17	access:public
StoreFullPath	macos/source/macglob.h	/^    Boolean         StoreFullPath;$/;"	m	struct:__anon17	access:public
StrCalloc	macos/source/helpers.c	/^char *StrCalloc(unsigned short size)$/;"	f	signature:(unsigned short size)
StrFree	macos/source/helpers.c	/^char *StrFree(char *strPtr)$/;"	f	signature:(char *strPtr)
StringLower	os2/os2zip.c	/^char *StringLower(char *szArg)$/;"	f	signature:(char *szArg)
StringLower	win32/win32.c	/^char *StringLower(char *szArg)$/;"	f	signature:(char *szArg)
StripPartialDir	macos/source/macos.c	/^char *StripPartialDir(char *CompletePath,$/;"	f	signature:(char *CompletePath, const char *PartialPath, const char *FullPath)
Strst	amiga/deflate.a	/^        ; CHECK_MATCH   Strst,match_start,MatchL$/;"	v
Strst	amiga/deflate.a	/^        MOVINT  Strst,_strstart         ; ct_tally reads this variable$/;"	v
Strst	amiga/deflate.a	/^        MOVINT  Strst,_strstart$/;"	v
Strst	amiga/deflate.a	/^        moveq   #0,Strst                ; Strst must be valid as a long$/;"	v
Strst	amiga/deflate.a	/^        moveq   #0,Strst                ; make sure strstart is valid as a long$/;"	v
Strst	amiga/deflate.a	/^; strstart, lookahead, and window must be cached in Strst, Look, and Window:$/;"	v
Strst	amiga/deflate.a	/^; we exclude More, WindTop, SlidIx, Look, Strst, Window, a4 and a7.$/;"	v
Strst	human68k/deflate.s	/^        ; CHECK_MATCH   Strst,match_start,MatchL$/;"	v
Strst	human68k/deflate.s	/^        MOVINT  Strst,_strstart         ; ct_tally reads this variable$/;"	v
Strst	human68k/deflate.s	/^        MOVINT  Strst,_strstart$/;"	v
Strst	human68k/deflate.s	/^        moveq   #0,Strst                ; Strst must be valid as a long$/;"	v
Strst	human68k/deflate.s	/^        moveq   #0,Strst                ; make sure strstart is valid as a long$/;"	v
Strst	human68k/deflate.s	/^; strstart, lookahead, and window must be cached in Strst, Look, and Window:$/;"	v
Strst	human68k/deflate.s	/^; we exclude More, WindTop, SlidIx, Look, Strst, Window, a4 and a7.$/;"	v
Strst	human68k/deflate.s	/^FWREGS  reg     d2-d5\/a2-a6             ; does NOT include Look and Strst$/;"	v
System	proginfo/extrafld.txt	/^          FWKCS, and FWKCS Contents_Signature System, are$/;"	v
SystemSevenOrLater	macos/ZipLib.h	28;"	d
SystemSevenOrLater	macos/ZipSx.h	28;"	d
TAB	proginfo/txtvsbin.txt	/^some portable whitespace such as TAB, CR or LF, otherwise the file is$/;"	v
TANDEM	tandem/tandem.h	13;"	d
TANDEM_BLOCKSIZE	tandem/tandem.h	54;"	d
TANDEM_DELIMITER	tandem/tandem.h	124;"	d
TANDEM_DELIMITER_STR	tandem/tandem.h	133;"	d
TANDEM_EXTENSION	tandem/tandem.h	123;"	d
TANDEM_EXTENSION_STR	tandem/tandem.h	132;"	d
TANDEM_NODE	tandem/tandem.h	125;"	d
TANDEM_NODE_STR	tandem/tandem.h	134;"	d
TANDEM_WILD_1	tandem/tandem.h	128;"	d
TANDEM_WILD_2	tandem/tandem.h	129;"	d
TB	zip30f.ann	/^  so many bytes read, settable from KB to TB, allowing progress to be$/;"	v
TEMPL_FMT	zipsplit.c	32;"	d	file:
TEMPL_FMT	zipsplit.c	39;"	d	file:
TEMPL_FMT	zipsplit.c	45;"	d	file:
TEMPL_FMT	zipsplit.c	50;"	d	file:
TEMPL_SIZ	zipsplit.c	33;"	d	file:
TEMPL_SIZ	zipsplit.c	40;"	d	file:
TEMPL_SIZ	zipsplit.c	46;"	d	file:
TEMPL_SIZ	zipsplit.c	51;"	d	file:
THIS_ARG_DONE	fileio.c	3697;"	d	file:
TIME_ZONE_ID_INVALID	win32/rsxntwin.h	35;"	d
TIME_ZONE_ID_UNKNOWN	win32/rsxntwin.h	32;"	d
TMAX	zipsplit.c	91;"	d	file:
TM_HOUR_MAX	timezone.c	714;"	d	file:
TM_MDAY_MAX	timezone.c	711;"	d	file:
TM_MIN_MAX	timezone.c	717;"	d	file:
TM_MON_MAX	timezone.c	708;"	d	file:
TM_SEC_MAX	timezone.c	720;"	d	file:
TM_YEAR_BASE	timezone.c	73;"	d	file:
TM_YEAR_MAX	timezone.c	705;"	d	file:
TOKEN_ADJUST_PRIVILEGES	win32/rsxntwin.h	110;"	d
TOKEN_PRIVILEGES	win32/rsxntwin.h	/^} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;$/;"	t	typeref:struct:_TOKEN_PRIVILEGES
TOKEN_QUERY	win32/rsxntwin.h	109;"	d
TOO_FAR	deflate.c	112;"	d	file:
TOPS20	proginfo/ZipPorts	/^      it:  AMIGA, ATARI_ST, __human68k__, MACOS, MSDOS, MVS, OS2, TOPS20,$/;"	v
TOPS20	tops20/osdep.h	10;"	d
TRUE	tailor.h	307;"	d
TRUE	tops20/tops20.c	22;"	d	file:
TTRLEN	cmsmvs/mvs.h	32;"	d
TTThhDDD	zip.txt	/^              The  format is TTThhDDD, where TTT is the time zone such as MET,$/;"	v
TZDEFAULT	timezone.c	59;"	d	file:
TZDEFRULESTRING	timezone.c	58;"	d	file:
TZ_MAX_CHARS	timezone.h	24;"	d
TZ_MAX_CHARS	timezone.h	26;"	d
TZ_MAX_TIMES	timezone.h	21;"	d
TZ_MAX_TYPES	timezone.h	22;"	d
TempZipFileSpec	macos/source/macglob.h	/^    FSSpec          TempZipFileSpec;$/;"	m	struct:__anon17	access:public
TempZipFullPath	macos/source/macglob.h	/^    char            TempZipFullPath[NAME_MAX];$/;"	m	struct:__anon17	access:public
Time_Est_strings	macos/source/macos.c	/^static char *Time_Est_strings[] = {$/;"	v	file:
TomBrownZipIt1_EF	macos/source/pathname.h	48;"	d
TomBrownZipIt2_EF	macos/source/pathname.h	49;"	d
Trace	crypt.c	103;"	d	file:
Trace	crypt.c	105;"	d	file:
Trace	zip.h	567;"	d
Trace	zip.h	573;"	d
Trace	zip.h	582;"	d
Tracec	zip.h	570;"	d
Tracec	zip.h	576;"	d
Tracec	zip.h	585;"	d
Tracecv	zip.h	571;"	d
Tracecv	zip.h	577;"	d
Tracecv	zip.h	586;"	d
Tracev	zip.h	568;"	d
Tracev	zip.h	574;"	d
Tracev	zip.h	583;"	d
Tracevv	zip.h	569;"	d
Tracevv	zip.h	575;"	d
Tracevv	zip.h	584;"	d
TruncFilename	macos/source/pathname.c	/^char *TruncFilename(char *DirPath, const char *FilePath)$/;"	f	signature:(char *DirPath, const char *FilePath)
UIDGID_ARE_16B	unix/unix.c	605;"	d	file:
UIDGID_ARE_16B	unix/unix.c	610;"	d	file:
UINT_MAX	vms/vmszip.c	210;"	d	file:
ULLNG64	win32/win32.c	/^   typedef unsigned __int64     ULLNG64;$/;"	t	file:
ULLNG64	win32/win32.c	/^   typedef unsigned long long   ULLNG64;$/;"	t	file:
UNALIGNED_OK	amiga/osdep.h	52;"	d
UNALIGNED_OK	tailor.h	441;"	d
UNALIGNED_OK	tailor.h	444;"	d
UNICODE_SUPPORT	tailor.h	34;"	d
UNICODE_SUPPORT	win32/osdep.h	243;"	d
UNIX	proginfo/ZipPorts	/^      UNIX, VMS, WIN32.  Zip is moving in the same direction.  New ports$/;"	v
UNIX	tailor.h	23;"	d
UNIX	vms/VMS_ZIP.RNH	/^systems, including UNIX, VMS,  MSDOS, OS\/2, Windows 9x\/NT\/XP, Minix, Atari,$/;"	v
UNIX	vms/zip_cli.help	/^systems, including UNIX, VMS,  MSDOS, OS\/2, Windows 9x\/NT\/XP, Minix,$/;"	v
UNIX_TIME_SMAX_HI	win32/win32.c	361;"	d	file:
UNIX_TIME_SMAX_LO	win32/win32.c	362;"	d	file:
UNIX_TIME_SMIN_HI	win32/win32.c	359;"	d	file:
UNIX_TIME_SMIN_LO	win32/win32.c	360;"	d	file:
UNIX_TIME_UMAX_HI	win32/win32.c	357;"	d	file:
UNIX_TIME_UMAX_LO	win32/win32.c	358;"	d	file:
UNIX_TIME_ZERO_HI	win32/win32.c	352;"	d	file:
UNIX_TIME_ZERO_LO	win32/win32.c	353;"	d	file:
UNIX_TO_MACOS	macos/source/mactime.h	45;"	d
UNKNOWN	zip.h	212;"	d
UNLEN	os2/os2acl.c	64;"	d	file:
UNX_ENFMT	macos/source/unixlike.h	35;"	d
UNX_IFBLK	macos/source/unixlike.h	27;"	d
UNX_IFCHR	macos/source/unixlike.h	29;"	d
UNX_IFDIR	macos/source/unixlike.h	28;"	d
UNX_IFIFO	macos/source/unixlike.h	30;"	d
UNX_IFLNK	macos/source/unixlike.h	25;"	d
UNX_IFMT	macos/source/unixlike.h	23;"	d
UNX_IFREG	macos/source/unixlike.h	26;"	d
UNX_IFSOCK	macos/source/unixlike.h	24;"	d
UNX_IRGRP	macos/source/unixlike.h	43;"	d
UNX_IROTH	macos/source/unixlike.h	48;"	d
UNX_IRUSR	macos/source/unixlike.h	38;"	d
UNX_IRWXG	macos/source/unixlike.h	42;"	d
UNX_IRWXO	macos/source/unixlike.h	47;"	d
UNX_IRWXU	macos/source/unixlike.h	37;"	d
UNX_ISGID	macos/source/unixlike.h	33;"	d
UNX_ISUID	macos/source/unixlike.h	32;"	d
UNX_ISVTX	macos/source/unixlike.h	34;"	d
UNX_IWGRP	macos/source/unixlike.h	44;"	d
UNX_IWOTH	macos/source/unixlike.h	49;"	d
UNX_IWUSR	macos/source/unixlike.h	39;"	d
UNX_IXGRP	macos/source/unixlike.h	45;"	d
UNX_IXOTH	macos/source/unixlike.h	50;"	d
UNX_IXUSR	macos/source/unixlike.h	40;"	d
UPDATE	vms/zip_cli.cld	/^	Qualifier	UPDATE, NonNegatable$/;"	v
UPDATE	zip.c	78;"	d	file:
UPDATE_HASH	deflate.c	279;"	d	file:
USE_CASE_MAP	amiga/osdep.h	32;"	d
USE_CASE_MAP	atari/osdep.h	15;"	d
USE_CASE_MAP	cmsmvs/cmsmvs.h	67;"	d
USE_CASE_MAP	human68k/osdep.h	17;"	d
USE_CASE_MAP	macos/osdep.h	38;"	d
USE_CASE_MAP	msdos/osdep.h	132;"	d
USE_CASE_MAP	novell/osdep.h	127;"	d
USE_CASE_MAP	os2/osdep.h	91;"	d
USE_CASE_MAP	qdos/osdep.h	29;"	d
USE_CASE_MAP	tandem/tanzip.h	14;"	d
USE_CASE_MAP	vms/osdep.h	30;"	d
USE_CASE_MAP	win32/osdep.h	66;"	d
USE_EF_UT_TIME	amiga/osdep.h	33;"	d
USE_EF_UT_TIME	atheos/osdep.h	17;"	d
USE_EF_UT_TIME	beos/osdep.h	15;"	d
USE_EF_UT_TIME	macos/osdep.h	48;"	d
USE_EF_UT_TIME	msdos/osdep.h	77;"	d
USE_EF_UT_TIME	novell/osdep.h	77;"	d
USE_EF_UT_TIME	os2/osdep.h	43;"	d
USE_EF_UT_TIME	qdos/osdep.h	30;"	d
USE_EF_UT_TIME	tandem/tandem.h	25;"	d
USE_EF_UT_TIME	tandem/tandem.h	28;"	d
USE_EF_UT_TIME	unix/osdep.h	79;"	d
USE_EF_UT_TIME	vms/osdep.h	112;"	d
USE_EF_UT_TIME	win32/osdep.h	283;"	d
USE_POSIX_TERMIOS	ttyio.c	100;"	d	file:
USE_POSIX_TERMIOS	ttyio.c	61;"	d	file:
USE_SIOUX	macos/ZipSx.h	23;"	d
USE_STACKFRAME	crc_i386.S	84;"	d	file:
USE_SYSV_TERMIO	ttyio.c	106;"	d	file:
USE_SYSV_TERMIO	ttyio.c	72;"	d	file:
USE_ZIPMAIN	cmsmvs/cmsmvs.h	52;"	d
USE_ZIPMAIN	macos/osdep.h	36;"	d
USE_ZIPMAIN	windll/windll.h	24;"	d
USE_ZLIB	os2/match32.asm	/^    IFNDEF USE_ZLIB$/;"	v
USE_ZLIB	win32/match32.asm	/^    IFNDEF USE_ZLIB$/;"	v
USING_DEFAULT_LARGE_FILE_SUPPORT	tailor.h	159;"	d
UTF8_BIT	zipfile.c	169;"	d	file:
UTF8_PATH_EF_TAG	zipfile.c	162;"	d	file:
UTIL	globals.c	18;"	d	file:
UTIL	zipcloak.c	22;"	d	file:
UTIL	zipnote.c	17;"	d	file:
UTIL	zipsplit.c	17;"	d	file:
U_INT	os2/os2acl.c	/^typedef ULONG U_INT;$/;"	t	file:
U_INT	os2/os2acl.c	/^typedef USHORT U_INT;$/;"	t	file:
UnKnown_EF	macos/source/pathname.h	47;"	d
UnZip	vms/NOTES.TXT	/^every version of VMS, MMS (or MMK), Zip, and UnZip, on every file$/;"	v
UnZip	win32/crc_i386.asm	/^; crc_i386.asm, optimized CRC calculation function for Zip and UnZip,$/;"	v
UnZip	win32/crc_lcc.asm	/^; crc_lcc.asm, optimized CRC calculation function for Zip and UnZip,$/;"	v
Unicode	WHATSNEW	/^  Unicode, and UT time.$/;"	v
Unicode	proginfo/infozip.who	/^Ed Gordon               -                               Zip 3.0, VB, Unicode,$/;"	v
Unix	INSTALL	/^     wide range of systems:  Unix, VMS, MSDOS, OS\/2, NT, Amiga, Atari,$/;"	v
Unix	WHATSNEW	/^  Windows, Unix, and VMS using the bzip2 library.  A new option, -Z cm,$/;"	v
Unix	proginfo/infozip.who	/^Steven Schweda                                          VMS, Unix, large files$/;"	v
Unix2ql	qdos/qdos.c	/^char * Unix2ql (char *qlname, char **dot)$/;"	f	signature:(char *qlname, char **dot)
UnixFtime2MacFtime	macos/source/mactime.c	/^unsigned long UnixFtime2MacFtime(time_t unxftime)$/;"	f	signature:(time_t unxftime)
Unzip	acorn/swiven.s	/^; SWI veneers used by Zip\/Unzip$/;"	v
UpdCRC_dword	win32/crc_i386.c	141;"	d	file:
UpdCRC_dword	win32/crc_i386.c	166;"	d	file:
UpdCRC_dword_sh	win32/crc_i386.c	152;"	d	file:
UpdCRC_dword_sh	win32/crc_i386.c	171;"	d	file:
UpdCRC_lword	crc_i386.S	145;"	d	file:
UpdCRC_lword_sh	crc_i386.S	156;"	d	file:
UpdateTimeToComplete	macos/source/macos.c	/^static void UpdateTimeToComplete(void)$/;"	f	file:	signature:(void)
UserStop	macos/source/macos.c	/^void UserStop(void)$/;"	f	signature:(void)
VALID_TIMEZONE	amiga/osdep.h	101;"	d
VALID_TIMEZONE	zip.c	2505;"	d	file:
VALUE	win32/zip.rc	/^            VALUE "CompanyName", IZ_COMPANY_NAME "\\0"$/;"	v
VALUE	win32/zip.rc	/^            VALUE "FileDescription", "Info-ZIP Zip for Win32 console\\0"$/;"	v
VALUE	win32/zip.rc	/^            VALUE "FileVersion", VERSION "\\0"$/;"	v
VALUE	win32/zip.rc	/^            VALUE "InternalName", "zip\\0"$/;"	v
VALUE	win32/zip.rc	/^            VALUE "LegalCopyright", "Copyright  Info-ZIP 1997 - 2008\\0"$/;"	v
VALUE	win32/zip.rc	/^            VALUE "OriginalFilename", "zip.exe\\0"$/;"	v
VALUE	win32/zip.rc	/^            VALUE "ProductName", "Zip\\0"$/;"	v
VALUE	win32/zip.rc	/^            VALUE "ProductVersion", VERSION "\\0"$/;"	v
VALUE	win32/zip.rc	/^        VALUE "Translation", 0x409, 1200$/;"	v
VALUE	windll/windll.rc	/^            VALUE "CompanyName", IZ_COMPANY_NAME "\\0"$/;"	v
VALUE	windll/windll.rc	/^            VALUE "FileDescription", "Info-ZIP's Zip dll\\0"$/;"	v
VALUE	windll/windll.rc	/^            VALUE "FileVersion", VERSION "\\0"$/;"	v
VALUE	windll/windll.rc	/^            VALUE "InternalName", "Zip32z64\\0"$/;"	v
VALUE	windll/windll.rc	/^            VALUE "LegalCopyright", "Info-ZIP 1997 - 2008\\0"$/;"	v
VALUE	windll/windll.rc	/^            VALUE "OriginalFilename", "ZIP32Z64.DLL\\0"$/;"	v
VALUE	windll/windll.rc	/^            VALUE "ProductName", "Info-ZIP's WiZ\\0"$/;"	v
VALUE	windll/windll.rc	/^            VALUE "ProductVersion", VERSION "\\0"$/;"	v
VALUE	windll/windll.rc	/^        VALUE "Translation", 0x409, 1200$/;"	v
VB	proginfo/infozip.who	/^Ed Gordon               -                               Zip 3.0, VB, Unicode,$/;"	v
VBZipBas	windll/VBz64/VBZIP.vbw	/^VBZipBas = 26, -4, 716, 492, $/;"	v
VBZipBas	windll/Vb/VBZIP.vbw	/^VBZipBas = 44, 44, 659, 489, $/;"	v
VB_Name	windll/VBz64/VBZipBas.bas	/^Attribute VB_Name = "VBZipBas"$/;"	v
VB_Name	windll/Vb/VBZipBas.bas	/^Attribute VB_Name = "VBZipBas"$/;"	v
VERSIG	vms/vms.h	226;"	d
VERSION	revision.h	24;"	d
VFatFileTime2utime	win32/win32.c	/^local int VFatFileTime2utime(const FILETIME *pft, time_t *ut)$/;"	f	signature:(const FILETIME *pft, time_t *ut)
VMS	INSTALL	/^     The steps for installation under VMS, MSDOS, OS\/2, NT, Amiga and$/;"	v
VMS	INSTALL	/^     wide range of systems:  Unix, VMS, MSDOS, OS\/2, NT, Amiga, Atari,$/;"	v
VMS	README	/^Testing for Zip 3.0 has focused mainly on Unix, VMS, Max OS X, and Win32,$/;"	v
VMS	macos/README.TXT	/^VMS, MSDOS, OS\/2, Windows 9x, Windows NT, Atari, Macintosh,$/;"	v
VMS	proginfo/ZipPorts	/^      UNIX, VMS, WIN32.  Zip is moving in the same direction.  New ports$/;"	v
VMS	proginfo/infozip.who	/^Steven Schweda                                          VMS, Unix, large files$/;"	v
VMS	vms/NOTES.TXT	/^every version of VMS, MMS (or MMK), Zip, and UnZip, on every file$/;"	v
VMS	vms/VMS_ZIP.RNH	/^systems, including UNIX, VMS,  MSDOS, OS\/2, Windows 9x\/NT\/XP, Minix, Atari,$/;"	v
VMS	vms/osdep.h	10;"	d
VMS	vms/zip_cli.help	/^systems, including UNIX, VMS,  MSDOS, OS\/2, Windows 9x\/NT\/XP, Minix,$/;"	v
VMSCLI_help	vms/cmdline.c	/^void VMSCLI_help(void)  \/* VMSCLI version *\/$/;"	f	signature:(void)
VMS_ATTR_COUNT	vms/vms.h	330;"	d
VMS_IM_EXTRA	vms/osdep.h	117;"	d
VMS_MAX_ATRCNT	vms/vms.h	331;"	d
VMS_MSG_IDENT	ziperr.h	22;"	d
VMS_PK_EXTRA	vms/osdep.h	120;"	d
VMS_VERSION	vms/osdep.h	18;"	d
VMS_ZIP	vms/vms_im.c	46;"	d	file:
VMS_ZIP	vms/vms_pk.c	77;"	d	file:
VMSmunch	vms/vmsmunch.c	/^int VMSmunch($/;"	f	signature:( char *filename, int action, char *ptr )
VMStimbuf	vms/vmsmunch.h	/^struct VMStimbuf {      \/* VMSmunch *\/$/;"	s
VMStimbuf::actime	vms/vmsmunch.h	/^    char *actime;       \/* VMS revision date, ASCII format *\/$/;"	m	struct:VMStimbuf	access:public
VMStimbuf::modtime	vms/vmsmunch.h	/^    char *modtime;      \/* VMS creation date, ASCII format *\/$/;"	m	struct:VMStimbuf	access:public
VM_CMS	cmsmvs/cmsmvs.h	38;"	d
VOLUME	tandem/make	/^VOLUME ,"NUNU"$/;"	v
VOLUMECAPS	win32/nt.h	/^} VOLUMECAPS, *PVOLUMECAPS, *LPVOLUMECAPS;$/;"	t	typeref:struct:__anon6
VT	proginfo/txtvsbin.txt	/^  7 (BEL), 8 (BS), 11 (VT), 12 (FF), 26 (SUB), 27 (ESC)$/;"	v
Version	win32/nt.h	/^  BYTE Version; \/* Version of uncompressed security descriptor data format *\/$/;"	m	struct:__anon5	access:public
Vollant	win32/gvmat64.asm	/^; File written by Gilles Vollant, by converting to assembly the longest_match$/;"	v
VolumeCapsLock	win32/nt.c	/^CRITICAL_SECTION VolumeCapsLock;$/;"	v
W32_STATROOT_FIX	win32/osdep.h	546;"	d
W32_STAT_BANDAID	win32/osdep.h	551;"	d
WATCOMC_386	msdos/osdep.h	55;"	d
WATCOMC_386	novell/osdep.h	55;"	d
WATCOMC_386	os2/osdep.h	23;"	d
WATCOMC_386	win32/osdep.h	34;"	d
WBversion	amiga/amigazip.c	/^int WBversion = (int)$/;"	v
WEP	windll/windll.c	/^int FAR PASCAL WEP ( int bSystemExit )$/;"	f	signature:( int bSystemExit )
WILDCHR_MULTI	util.c	40;"	d	file:
WILDCHR_MULTI	util.c	46;"	d	file:
WILDCHR_MULTI	util.c	54;"	d	file:
WILDCHR_SINGLE	util.c	39;"	d	file:
WILDCHR_SINGLE	util.c	45;"	d	file:
WILDCHR_SINGLE	util.c	51;"	d	file:
WIN32	CHANGES	/^    WIN32, set z->vem to "OS_DOS | <real zip version number>".$/;"	v
WIN32	proginfo/infozip.who	/^                                                        WIN32, Linux$/;"	v
WIN32	tailor.h	26;"	d
WIN32	windll/example.c	16;"	d	file:
WIN32_LEAN_AND_MEAN	win32/nt.c	43;"	d	file:
WIN32_LEAN_AND_MEAN	win32/win32.c	27;"	d	file:
WIN32_LEAN_AND_MEAN	win32/win32zip.c	26;"	d	file:
WIN32_LEAN_AND_MEAN	zip.c	19;"	d	file:
WIN32_LEAN_AND_MEAN	zipfile.c	37;"	d	file:
WIN32_OEM	win32/osdep.h	89;"	d
WMASK	deflate.c	101;"	d	file:
WRBUFSIZ	zipnote.c	25;"	d	file:
WRBUFSIZ	zipnote.c	28;"	d	file:
WRBUFSIZ	zipnote.c	29;"	d	file:
WSIZE	amiga/osdep.h	83;"	d
WSIZE	match.S	52;"	d	file:
WSIZE	zip.h	104;"	d
Wed	proginfo/perform.dos	/^Date: Wed, 27 Mar 1996 01:31:50 CET +0100$/;"	v
WiZ	windll/windll.txt	/^For examples of how the actual calls to the dll were set up in WiZ, look in$/;"	v
Win32	INSTALL	/^    This flag should be set automatically on Unix, Win32, and some$/;"	v
Win32	README	/^Testing for Zip 3.0 has focused mainly on Unix, VMS, Max OS X, and Win32,$/;"	v
Win32	README	/^create and read large files and archives.  On Unix, Win32, and some other$/;"	v
WinAssert	windll/windll.h	28;"	d
WinAssert	windll/windll.h	43;"	d
WinCP1252_to_MacRoman	macos/source/charmap.h	/^ZCONST unsigned char WinCP1252_to_MacRoman[128] = {$/;"	v
WindTop	amiga/deflate.a	/^        lea     WSIZE(Window),WindTop   ; WindTop is aligned when Window is$/;"	v
WindTop	amiga/deflate.a	/^; we exclude More, WindTop, SlidIx, Look, Strst, Window, a4 and a7.$/;"	v
WindTop	human68k/deflate.s	/^        lea     WSIZE(Window),WindTop   ; WindTop is aligned when Window is$/;"	v
WindTop	human68k/deflate.s	/^; we exclude More, WindTop, SlidIx, Look, Strst, Window, a4 and a7.$/;"	v
Window	amiga/deflate.a	/^        BASEPTR _window,Window                  ; restore cached value$/;"	v
Window	amiga/deflate.a	/^        lea     4*SPCOUNT(Window),Window        ; can't use (aN)+ as movem.l dest$/;"	v
Window	amiga/deflate.a	/^        movem.l SPAREGS,(Window)        ; a slight overshoot doesn't matter.$/;"	v
Window	amiga/deflate.a	/^; we exclude More, WindTop, SlidIx, Look, Strst, Window, a4 and a7.$/;"	v
Window	human68k/deflate.s	/^        BASEPTR _window,Window                  ; restore cached value$/;"	v
Window	human68k/deflate.s	/^        lea     4*SPCOUNT(Window),Window        ; can't use (aN)+ as movem.l dest$/;"	v
Window	human68k/deflate.s	/^        movem.l SPAREGS,(Window)        ; a slight overshoot doesn't matter.$/;"	v
Window	human68k/deflate.s	/^; we exclude More, WindTop, SlidIx, Look, Strst, Window, a4 and a7.$/;"	v
Windows	README	/^how to use them.  Also, if you are using MSDOS or Windows, note that text$/;"	v
WriteNumString	util.c	/^int WriteNumString( num, outstring )$/;"	f
X	README	/^Testing for Zip 3.0 has focused mainly on Unix, VMS, Max OS X, and Win32,$/;"	v
XAB	vms/vms.h	/^struct XAB {                    \/* This definition may be skipped *\/$/;"	s
XAB::xab$b_bln	vms/vms.h	/^    unsigned char xab$b_bln;$/;"	m	struct:XAB	access:public
XAB::xab$b_cod	vms/vms.h	/^    unsigned char xab$b_cod;$/;"	m	struct:XAB	access:public
XAB::xab$l_nxt	vms/vms.h	/^    char *xab$l_nxt;$/;"	m	struct:XAB	access:public
XAB::xabdef$$_fill_1	vms/vms.h	/^    short int xabdef$$_fill_1;$/;"	m	struct:XAB	access:public
XALLL	vms/vms.h	234;"	d
XALLSIG	vms/vms.h	219;"	d
XDATL	vms/vms.h	235;"	d
XDATSIG	vms/vms.h	221;"	d
XFHCL	vms/vms.h	236;"	d
XFHCSIG	vms/vms.h	220;"	d
XGetVInfo	macos/source/macstuff.c	/^pascal  OSErr   XGetVInfo(short volReference,$/;"	f	signature:(short volReference, StringPtr volName, short *vRefNum, UnsignedWide *freeBytes, UnsignedWide *totalBytes)
XKEYL	vms/vms.h	237;"	d
XKEYSIG	vms/vms.h	224;"	d
XML	proginfo/txtvsbin.txt	/^XML, avoid using control characters outside the list mentioned here.$/;"	v
XNAMSIG	vms/vms.h	225;"	d
XP	vms/VMS_ZIP.RNH	/^systems, including UNIX, VMS,  MSDOS, OS\/2, Windows 9x\/NT\/XP, Minix, Atari,$/;"	v
XP	vms/zip_cli.help	/^systems, including UNIX, VMS,  MSDOS, OS\/2, Windows 9x\/NT\/XP, Minix,$/;"	v
XPG4	unix/README.OS390	/^XPG4, build environment, a Unix-style filesystem (called HFS), and$/;"	v
XPROL	vms/vms.h	238;"	d
XPROSIG	vms/vms.h	223;"	d
XRDTL	vms/vms.h	239;"	d
XRDTSIG	vms/vms.h	222;"	d
XSUML	vms/vms.h	240;"	d
YDAYS	amiga/filedate.c	183;"	d	file:
YDAYS	timezone.c	77;"	d	file:
ZBSZ	cmsmvs/cmsmvs.h	121;"	d
ZBSZ	msdos/osdep.h	109;"	d
ZBSZ	msdos/osdep.h	113;"	d
ZBSZ	msdos/osdep.h	117;"	d
ZBSZ	novell/osdep.h	109;"	d
ZBSZ	novell/osdep.h	113;"	d
ZBSZ	novell/osdep.h	117;"	d
ZBSZ	os2/osdep.h	104;"	d
ZBSZ	tailor.h	449;"	d
ZBSZ	tailor.h	454;"	d
ZBSZ	tailor.h	459;"	d
ZBSZ	tandem/tanzip.h	30;"	d
ZBSZ	tops20/osdep.h	28;"	d
ZCL	api.h	/^} ZCL, _far *LPZCL;$/;"	t	typeref:struct:__anon31
ZCL	windll/windll.txt	/^} ZCL, _far *LPZCL;$/;"	t	typeref:struct:__anon19	file:
ZCONST	crc32.c	29;"	d	file:
ZCONST	crc32.h	25;"	d
ZCONST	ebcdic.h	49;"	d
ZCONST	macos/ZipLib.h	38;"	d
ZCONST	macos/ZipSx.h	37;"	d
ZCONST	tailor.h	189;"	d
ZCONST	tailor.h	192;"	d
ZCONST	ttyio.h	36;"	d
ZCONST	win32/crc_i386.c	87;"	d	file:
ZCRYPT_INTERNAL	crypt.c	32;"	d	file:
ZCR_SEED2	acorn/osdep.h	27;"	d
ZCR_SEED2	amiga/osdep.h	107;"	d
ZCR_SEED2	cmsmvs/cmsmvs.h	78;"	d
ZCR_SEED2	crypt.c	80;"	d	file:
ZCR_SEED2	msdos/osdep.h	148;"	d
ZCR_SEED2	novell/osdep.h	143;"	d
ZCR_SEED2	tailor.h	794;"	d
ZCR_SEED2	win32/osdep.h	516;"	d
ZDLLComm	windll/Vb/VBZipBas.bas	/^    ZDLLComm = 1$/;"	v
ZDLLPrnt	windll/VBz64/VBZipBas.bas	/^  ZDLLPrnt = 0$/;"	v
ZDLLPrnt	windll/Vb/VBZipBas.bas	/^  ZDLLPrnt = 0$/;"	v
ZEXTRAFLD	aosvs/aosvs.c	/^} ZEXTRAFLD;$/;"	t	typeref:struct:zextrafld	file:
ZEXTRA_HEADID	aosvs/aosvs.c	44;"	d	file:
ZEXTRA_REV	aosvs/aosvs.c	46;"	d	file:
ZEXTRA_SENTINEL	aosvs/aosvs.c	45;"	d	file:
ZE_ABORT	ziperr.h	48;"	d
ZE_BIG	ziperr.h	45;"	d
ZE_COMPERR	ziperr.h	57;"	d
ZE_CREAT	ziperr.h	54;"	d
ZE_EOF	ziperr.h	41;"	d
ZE_FORM	ziperr.h	42;"	d
ZE_LOGIC	ziperr.h	44;"	d
ZE_MAXERR	ziperr.h	60;"	d
ZE_MEM	amiga/deflate.a	/^        MOVINT  #ZE_MEM,-(sp)$/;"	v
ZE_MEM	ziperr.h	43;"	d
ZE_MISS	ziperr.h	39;"	d
ZE_NAME	ziperr.h	52;"	d
ZE_NONE	ziperr.h	51;"	d
ZE_NOTE	ziperr.h	46;"	d
ZE_OK	ziperr.h	40;"	d
ZE_OPEN	ziperr.h	56;"	d
ZE_PARMS	ziperr.h	55;"	d
ZE_READ	ziperr.h	50;"	d
ZE_S_ERROR	ziperr.h	27;"	d
ZE_S_INFO	ziperr.h	28;"	d
ZE_S_PERR	ziperr.h	33;"	d
ZE_S_SEVERE	ziperr.h	29;"	d
ZE_S_SUCCESS	ziperr.h	26;"	d
ZE_S_UNUSED	ziperr.h	30;"	d
ZE_S_WARNING	ziperr.h	25;"	d
ZE_TEMP	ziperr.h	49;"	d
ZE_TEST	ziperr.h	47;"	d
ZE_WRITE	ziperr.h	53;"	d
ZE_ZIP64	ziperr.h	58;"	d
ZIP	README.CR	/^    LIKE ANYTHING ELSE THAT IS FREE, ZIP, UNZIP AND THEIR ASSOCIATED$/;"	v
ZIP	amiga/amiga.c	67;"	d	file:
ZIP	zip.h	79;"	d
ZIP64_CENTRAL_DIR_TAIL_END_SIG	zipfile.c	144;"	d	file:
ZIP64_CENTRAL_DIR_TAIL_SIG	zipfile.c	143;"	d	file:
ZIP64_CENTRAL_DIR_TAIL_SIZE	zipfile.c	142;"	d	file:
ZIP64_EFIELD_OFS_CSIZE	zipfile.c	148;"	d	file:
ZIP64_EFIELD_OFS_DISK	zipfile.c	150;"	d	file:
ZIP64_EFIELD_OFS_OFS	zipfile.c	149;"	d	file:
ZIP64_EFIELD_OFS_OSIZE	zipfile.c	147;"	d	file:
ZIP64_EF_TAG	zipfile.c	146;"	d	file:
ZIP64_EOCDL_OFS_EOCD_START	zipfile.c	139;"	d	file:
ZIP64_EOCDL_OFS_SIZE	zipfile.c	125;"	d	file:
ZIP64_EOCDL_OFS_SIZE	zipfile.c	138;"	d	file:
ZIP64_EOCDL_OFS_TOTALDISKS	zipfile.c	140;"	d	file:
ZIP64_EOCDL_SIG	zipfile.c	123;"	d	file:
ZIP64_EOCD_OFS_CD_START	zipfile.c	137;"	d	file:
ZIP64_EOCD_OFS_SIZE	zipfile.c	136;"	d	file:
ZIP64_EOCD_SIG	zipfile.c	135;"	d	file:
ZIP64_EXTCRC	zipfile.c	132;"	d	file:
ZIP64_EXTLEN	zipfile.c	134;"	d	file:
ZIP64_EXTSIZ	zipfile.c	133;"	d	file:
ZIP64_LARGE_FILE_HEAD_SIZE	zipfile.c	145;"	d	file:
ZIP64_MIN_VER	zipfile.c	141;"	d	file:
ZIP64_SUPPORT	unix/osdep.h	59;"	d
ZIP64_SUPPORT	unix/osdep.h	63;"	d
ZIP64_SUPPORT	vms/osdep.h	47;"	d
ZIP64_SUPPORT	vms/osdep.h	51;"	d
ZIP64_SUPPORT	win32/osdep.h	216;"	d
ZIPERR	tailor.h	872;"	d
ZIPERRORS	ziperr.h	115;"	d
ZIPSETOPTIONS	windll/example.h	/^typedef BOOL (WINAPI * ZIPSETOPTIONS)(LPZPOPT);$/;"	t
ZIPUSERFUNCTIONS	api.h	/^} ZIPUSERFUNCTIONS, far * LPZIPUSERFUNCTIONS;$/;"	t	typeref:struct:__anon32
ZIPUSERFUNCTIONS	windll/windll.txt	/^} ZIPUSERFUNCTIONS, far * LPZIPUSERFUNCTIONS;$/;"	t	typeref:struct:__anon20	file:
ZIP_DLL_NAME	windll/example.c	40;"	d	file:
ZIP_DLL_NAME	windll/example.c	42;"	d	file:
ZIP_EF_HEADER_SIZE	zipfile.c	129;"	d	file:
ZIP_UWORD16_MAX	zipfile.c	127;"	d	file:
ZIP_UWORD32_MAX	zipfile.c	128;"	d	file:
ZOFF_T_FORMAT_SIZE_PREFIX	tailor.h	141;"	d
ZOFF_T_FORMAT_SIZE_PREFIX	tailor.h	152;"	d
ZOFF_T_FORMAT_SIZE_PREFIX	unix/osdep.h	35;"	d
ZOFF_T_FORMAT_SIZE_PREFIX	unix/osdep.h	37;"	d
ZOFF_T_FORMAT_SIZE_PREFIX	vms/osdep.h	55;"	d
ZOFF_T_FORMAT_SIZE_PREFIX	vms/osdep.h	59;"	d
ZOFF_T_FORMAT_SIZE_PREFIX	win32/osdep.h	141;"	d
ZOFF_T_FORMAT_SIZE_PREFIX	win32/osdep.h	159;"	d
ZOFF_T_FORMAT_SIZE_PREFIX	win32/osdep.h	172;"	d
ZOFF_T_FORMAT_SIZE_PREFIX	win32/osdep.h	184;"	d
ZOFF_T_FORMAT_SIZE_PREFIX	win32/osdep.h	234;"	d
ZPATH_SEP	zipsplit.c	34;"	d	file:
ZPATH_SEP	zipsplit.c	37;"	d	file:
ZPATH_SEP	zipsplit.c	47;"	d	file:
ZPATH_SEP	zipsplit.c	52;"	d	file:
ZPOPT	api.h	/^} ZPOPT, _far *LPZPOPT;$/;"	t	typeref:struct:__anon30
ZPOPT	windll/windll.txt	/^} ZPOPT, _far *LPZPOPT;$/;"	t	typeref:struct:__anon18	file:
ZPVER_LEN	api.h	43;"	d
ZP_NEED_GEN_D2U_TIME	fileio.c	1138;"	d	file:
ZP_NEED_GEN_D2U_TIME	fileio.c	1142;"	d	file:
ZP_NEED_GEN_D2U_TIME	fileio.c	1147;"	d	file:
ZP_NEED_GEN_D2U_TIME	fileio.c	1175;"	d	file:
ZP_NEED_MEMCOMPR	beos/osdep.h	24;"	d
ZP_NEED_MEMCOMPR	macos/osdep.h	54;"	d
ZP_NEED_MEMCOMPR	os2/osdep.h	52;"	d
ZP_NEED_MEMCOMPR	win32/osdep.h	290;"	d
ZP_PW_ENTER	zip.h	276;"	d
ZP_PW_VERIFY	zip.h	277;"	d
ZVSFSTAT_STRU	aosvs/aosvs.c	/^} ZVSFSTAT_STRU;$/;"	t	typeref:union:zvsfstat_stru	file:
Z_BETALEVEL	revision.h	22;"	d
Z_MAJORVER	revision.h	19;"	d
Z_MAJORVER	win32/zip.rc	/^ FILEVERSION Z_MAJORVER,Z_MINORVER,Z_PATCHLEVEL,0$/;"	v
Z_MAJORVER	win32/zip.rc	/^ PRODUCTVERSION Z_MAJORVER,Z_MINORVER,Z_PATCHLEVEL,0$/;"	v
Z_MAJORVER	windll/windll.rc	/^ FILEVERSION Z_MAJORVER,Z_MINORVER,Z_PATCHLEVEL,0$/;"	v
Z_MAJORVER	windll/windll.rc	/^ PRODUCTVERSION Z_MAJORVER,Z_MINORVER,Z_PATCHLEVEL,0$/;"	v
Z_MINORVER	revision.h	20;"	d
Z_MINORVER	win32/zip.rc	/^ FILEVERSION Z_MAJORVER,Z_MINORVER,Z_PATCHLEVEL,0$/;"	v
Z_MINORVER	win32/zip.rc	/^ PRODUCTVERSION Z_MAJORVER,Z_MINORVER,Z_PATCHLEVEL,0$/;"	v
Z_MINORVER	windll/windll.rc	/^ FILEVERSION Z_MAJORVER,Z_MINORVER,Z_PATCHLEVEL,0$/;"	v
Z_MINORVER	windll/windll.rc	/^ PRODUCTVERSION Z_MAJORVER,Z_MINORVER,Z_PATCHLEVEL,0$/;"	v
Z_PATCHLEVEL	revision.h	21;"	d
Z_PATCHLEVEL	win32/zip.rc	/^ FILEVERSION Z_MAJORVER,Z_MINORVER,Z_PATCHLEVEL,0$/;"	v
Z_PATCHLEVEL	win32/zip.rc	/^ PRODUCTVERSION Z_MAJORVER,Z_MINORVER,Z_PATCHLEVEL,0$/;"	v
Z_PATCHLEVEL	windll/windll.rc	/^ FILEVERSION Z_MAJORVER,Z_MINORVER,Z_PATCHLEVEL,0$/;"	v
Z_PATCHLEVEL	windll/windll.rc	/^ PRODUCTVERSION Z_MAJORVER,Z_MINORVER,Z_PATCHLEVEL,0$/;"	v
Z_UINT4_DEFINED	tailor.h	392;"	d
Z_UINT4_DEFINED	tailor.h	396;"	d
Z_UINT4_DEFINED	tailor.h	400;"	d
Z_UINT4_DEFINED	tailor.h	408;"	d
Zip	vms/NOTES.TXT	/^every version of VMS, MMS (or MMK), Zip, and UnZip, on every file$/;"	v
Zip	vms/zip_msg.msg	/^! general, specific to Zip, this file is not compiled with \/SHARED.$/;"	v
Zip	win32/gvmat64.asm	/^; to compile this file for infozip Zip, I use option:$/;"	v
ZipArchive	windll/example.c	/^_DLL_ZIP ZipArchive;$/;"	v
ZipFileSpec	macos/source/macglob.h	/^    FSSpec          ZipFileSpec;$/;"	m	struct:__anon17	access:public
ZipFileType	macos/source/macglob.h	/^    unsigned long   ZipFileType;$/;"	m	struct:__anon17	access:public
ZipFullPath	macos/source/macglob.h	/^    char            ZipFullPath[NAME_MAX];$/;"	m	struct:__anon17	access:public
ZipGetVolumeCaps	win32/nt.c	/^BOOL ZipGetVolumeCaps($/;"	f	signature:( char *rootpath, char *name, PVOLUMECAPS VolumeCaps )
ZipInit	windll/example.c	/^_ZIP_USER_FUNCTIONS ZipInit;$/;"	v
ZipInitAllVars	macos/source/macos.c	/^void ZipInitAllVars(void)$/;"	f	signature:(void)
ZipIsWinNT	win32/win32.c	/^int ZipIsWinNT(void)    \/* returns TRUE if real NT, FALSE if Win95 or Win32s *\/$/;"	f	signature:(void)
ZipRet	api.c	/^int ZipRet;$/;"	v
ZipSetOptions	windll/example.c	/^ZIPSETOPTIONS ZipSetOptions;$/;"	v
ZipUserFunctions	api.c	/^ZIPUSERFUNCTIONS ZipUserFunctions, far * lpZipUserFunctions;$/;"	v
Zmacstat	macos/source/unixlike.c	/^int Zmacstat(const char *Fname, struct stat *buf)$/;"	f	signature:(const char *Fname, struct stat *buf)
ZpArchive	api.c	/^int EXPENTRY ZpArchive(ZCL C, LPZPOPT Opts)$/;"	f	signature:(ZCL C, LPZPOPT Opts)
ZpInit	api.c	/^int EXPENTRY ZpInit(LPZIPUSERFUNCTIONS lpZipUserFunc)$/;"	f	signature:(LPZIPUSERFUNCTIONS lpZipUserFunc)
ZpInit	windll/windll.txt	/^ZpInit, defined as$/;"	v
ZpOpt	windll/example.c	/^ZPOPT ZpOpt;$/;"	v
ZpVer	api.h	/^} ZpVer;$/;"	t	typeref:struct:_ZpVer
ZpVer	windll/windll.txt	/^} ZpVer;$/;"	t	typeref:struct:_ZpVer	file:
ZpVersion	api.c	/^void EXPENTRY ZpVersion(ZpVer far * p)   \/* should be pointer to const struct *\/$/;"	f	signature:(ZpVer far * p)
ZpZCL	windll/example.c	/^ZCL ZpZCL;$/;"	v
_1	human68k/deflate.s	/^        and.w   #HASH_MASK,_1           ; ((ins_h << H_SHIFT) ^ c) & HASH_MASK$/;"	v
_1	human68k/deflate.s	/^        lea     _1,_2$/;"	v
_1	human68k/deflate.s	/^BASEPTR MACRO   _1,_2$/;"	v
_1	human68k/deflate.s	/^CAL_SH  MACRO   _1              ; Okay, we're back to using regular calloc()...$/;"	v
_1	human68k/deflate.s	/^IN_STR  MACRO   _1,_2$/;"	v
_1	human68k/deflate.s	/^MOVINT  MACRO   _1,_2$/;"	v
_1	human68k/deflate.s	/^UP_HASH MACRO   _1,_2$/;"	v
_2	human68k/deflate.s	/^        add.w   _2,_2                   ; masks implicitly when WSIZE == 32768$/;"	v
_2	human68k/deflate.s	/^        move.b  (Window,_2.l),_2        ; window[strstart + MIN_MATCH - 1]$/;"	v
_ACL	win32/rsxntwin.h	/^typedef struct _ACL {$/;"	s
_ACL::AceCount	win32/rsxntwin.h	/^    WORD   AceCount;$/;"	m	struct:_ACL	access:public
_ACL::AclRevision	win32/rsxntwin.h	/^    BYTE  AclRevision;$/;"	m	struct:_ACL	access:public
_ACL::AclSize	win32/rsxntwin.h	/^    WORD   AclSize;$/;"	m	struct:_ACL	access:public
_ACL::Sbz1	win32/rsxntwin.h	/^    BYTE  Sbz1;$/;"	m	struct:_ACL	access:public
_ACL::Sbz2	win32/rsxntwin.h	/^    WORD   Sbz2;$/;"	m	struct:_ACL	access:public
_A_ARCHIVE	os2/os2zip.h	22;"	d
_A_DIR	os2/os2zip.h	21;"	d
_A_HIDDEN	os2/os2zip.h	18;"	d
_A_RONLY	os2/os2zip.h	17;"	d
_A_SYSTEM	os2/os2zip.h	19;"	d
_A_VOLID	os2/os2zip.h	20;"	d
_BIT	vms/vms_im.c	887;"	d	file:
_BSS	msdos/crc_i86.asm	/^DGROUP  GROUP   _BSS, _DATA$/;"	v
_BSS	win32/match32.asm	/^        assume DS: _BSS, ES: _BSS, FS: _BSS$/;"	v
_COMMIFMT_H	amiga/z-stat.h	32;"	d
_CRT_NONSTDC_NO_DEPRECATE	win32/osdep.h	29;"	d
_CRT_SECURE_NO_DEPRECATE	win32/osdep.h	26;"	d
_CRT_glob	win32/win32.c	/^   int _CRT_glob = 0;   \/* suppress command line globbing by C RTL *\/$/;"	v
_DEFJS	tops20/tops20.c	32;"	d	file:
_DIR	cmsmvs/mvs.h	/^typedef struct _DIR {$/;"	s
_DIR	tandem/tandem.h	/^typedef struct _DIR {$/;"	s
_DIR::D_curpos	cmsmvs/mvs.h	/^   struct  dirent *D_curpos;$/;"	m	struct:_DIR	typeref:struct:_DIR::dirent	access:public
_DIR::D_curpos	tandem/tandem.h	/^   struct  dirent *D_curpos;$/;"	m	struct:_DIR	typeref:struct:_DIR::dirent	access:public
_DIR::D_list	cmsmvs/mvs.h	/^   struct  dirent *D_list;$/;"	m	struct:_DIR	typeref:struct:_DIR::dirent	access:public
_DIR::D_list	tandem/tandem.h	/^   struct  dirent *D_list;$/;"	m	struct:_DIR	typeref:struct:_DIR::dirent	access:public
_DIR::D_path	cmsmvs/mvs.h	/^   char            D_path[FILENAME_MAX];$/;"	m	struct:_DIR	access:public
_DIR::D_path	tandem/tandem.h	/^   char            D_path[NAMELEN+1];$/;"	m	struct:_DIR	access:public
_DIRENT_H	amiga/z-stat.h	30;"	d
_DLL_ZIP	windll/example.h	/^typedef int (WINAPI * _DLL_ZIP)(ZCL);$/;"	t
_EXAMPLE_H	windll/example.h	13;"	d
_EnviromentPair	macos/source/getenv.c	/^typedef struct _EnviromentPair {$/;"	s	file:
_EnviromentPair::key	macos/source/getenv.c	/^    char *key;$/;"	m	struct:_EnviromentPair	file:	access:public
_EnviromentPair::value	macos/source/getenv.c	/^    char *value;$/;"	m	struct:_EnviromentPair	file:	access:public
_FBBYV	tops20/tops20.c	478;"	d	file:
_FILE_OFFSET_BITS	tailor.h	134;"	d
_FILE_OFFSET_BITS	unix/configure	354;"	d	file:
_FILE_OFFSET_BITS	unix/configure	410;"	d	file:
_FILE_OFFSET_BITS	unix/osdep.h	26;"	d
_FLUSH	vms/vms_im.c	899;"	d	file:
_INTERN_ISO	win32/osdep.h	383;"	d
_INTERN_ISO	win32/osdep.h	394;"	d
_INTERN_OEM	win32/osdep.h	382;"	d
_INTERN_OEM	win32/osdep.h	393;"	d
_ISO_INTERN	win32/osdep.h	381;"	d
_ISO_INTERN	win32/osdep.h	392;"	d
_LARGEFILE	vms/osdep.h	40;"	d
_LARGEFILE64_SOURCE	tailor.h	133;"	d
_LARGEFILE64_SOURCE	unix/configure	353;"	d	file:
_LARGEFILE64_SOURCE	unix/configure	409;"	d	file:
_LARGEFILE64_SOURCE	unix/osdep.h	25;"	d
_LARGEFILE_SOURCE	tailor.h	132;"	d
_LARGEFILE_SOURCE	unix/configure	352;"	d	file:
_LARGEFILE_SOURCE	unix/configure	408;"	d	file:
_LARGEFILE_SOURCE	unix/osdep.h	24;"	d
_LARGE_FILES	tailor.h	135;"	d
_LARGE_FILES	unix/configure	355;"	d	file:
_LARGE_FILES	unix/configure	411;"	d	file:
_LARGE_FILES	unix/osdep.h	27;"	d
_LUID	win32/rsxntwin.h	/^typedef struct _LUID {$/;"	s
_LUID::HighPart	win32/rsxntwin.h	/^    LONG HighPart;$/;"	m	struct:_LUID	access:public
_LUID::LowPart	win32/rsxntwin.h	/^    DWORD LowPart;$/;"	m	struct:_LUID	access:public
_LUID_AND_ATTRIBUTES	win32/rsxntwin.h	/^typedef struct _LUID_AND_ATTRIBUTES {$/;"	s
_LUID_AND_ATTRIBUTES::Attributes	win32/rsxntwin.h	/^    DWORD Attributes;$/;"	m	struct:_LUID_AND_ATTRIBUTES	access:public
_LUID_AND_ATTRIBUTES::Luid	win32/rsxntwin.h	/^    LUID Luid;$/;"	m	struct:_LUID_AND_ATTRIBUTES	access:public
_MACGLOBAL_	macos/source/macglob.h	10;"	d
_MACSTUFF_H	macos/source/macstuff.h	10;"	d
_MACTIME_H_	macos/source/mactime.h	10;"	d
_MBCS	vms/osdep.h	95;"	d
_MBCS	win32/osdep.h	43;"	d
_MBCS	win32/osdep.h	46;"	d
_NT_ZIP_H	win32/nt.h	12;"	d
_NetAccessAdd	os2/os2acl.c	/^static USHORT (APIENTRY *_NetAccessAdd)(PSZ pszServer,$/;"	v	file:
_NetAccessAdd	os2/os2acl.c	166;"	d	file:
_NetAccessAdd	os2/os2acl.c	185;"	d	file:
_NetAccessGetInfo	os2/os2acl.c	/^static USHORT (APIENTRY *_NetAccessGetInfo)(PSZ pszServer, PSZ pszResource,$/;"	v	file:
_NetAccessGetInfo	os2/os2acl.c	164;"	d	file:
_NetAccessGetInfo	os2/os2acl.c	183;"	d	file:
_NetAccessSetInfo	os2/os2acl.c	/^static USHORT (APIENTRY *_NetAccessSetInfo)(PSZ pszServer, PSZ pszResource,$/;"	v	file:
_NetAccessSetInfo	os2/os2acl.c	165;"	d	file:
_NetAccessSetInfo	os2/os2acl.c	184;"	d	file:
_OEM_INTERN	win32/osdep.h	380;"	d
_OEM_INTERN	win32/osdep.h	391;"	d
_OS2ACL_H	os2/os2acl.h	25;"	d
_OSDEP_H_	atheos/osdep.h	11;"	d
_P100	timezone.c	84;"	d	file:
_P4	timezone.c	83;"	d	file:
_P400	timezone.c	85;"	d	file:
_POSIX_SOURCE	cmsmvs/cmsmvs.h	20;"	d
_QDOS_OPDEP	qdos/osdep.h	10;"	d
_RSXNTWIN_H	win32/rsxntwin.h	19;"	d
_SH_DENYNO	win32/zipup.h	24;"	d
_STAT_H	amiga/z-stat.h	29;"	d
_STD_ENTRY	crc_i386.S	95;"	d	file:
_STD_LEAVE	crc_i386.S	99;"	d	file:
_SYS_DIR_H	amiga/z-stat.h	31;"	d
_TEXT	msdos/match.asm	/^        assume  cs: _TEXT, ds: DGROUP$/;"	v
_TOKEN_PRIVILEGES	win32/rsxntwin.h	/^typedef struct _TOKEN_PRIVILEGES {$/;"	s
_TOKEN_PRIVILEGES::PrivilegeCount	win32/rsxntwin.h	/^    DWORD PrivilegeCount;$/;"	m	struct:_TOKEN_PRIVILEGES	access:public
_TOKEN_PRIVILEGES::Privileges	win32/rsxntwin.h	/^    LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];$/;"	m	struct:_TOKEN_PRIVILEGES	access:public
_UNIXLIKE_H	macos/source/unixlike.h	15;"	d
_WIN32ZIP_H	win32/win32zip.h	12;"	d
_WINDLL_H	windll/windll.h	15;"	d
_ZIPAPI_H	api.h	13;"	d
_ZIPUP_H_	atheos/zipup.h	10;"	d
_ZIP_STRUCTS_H	windll/structs.h	12;"	d
_ZIP_USER_FUNCTIONS	windll/example.h	/^typedef int (WINAPI * _ZIP_USER_FUNCTIONS)(LPZIPUSERFUNCTIONS);$/;"	t
_ZpVer	api.h	/^typedef struct _ZpVer {$/;"	s
_ZpVer	windll/windll.txt	/^typedef struct _ZpVer {$/;"	s	file:
_ZpVer::betalevel	api.h	/^    char betalevel[10];     \/* e.g., "g BETA" or "" *\/$/;"	m	struct:_ZpVer	access:public
_ZpVer::betalevel	windll/windll.txt	/^    char *betalevel;        \/* e.g., "g BETA" or "" *\/$/;"	m	struct:_ZpVer	file:	access:public
_ZpVer::date	api.h	/^    char date[20];          \/* e.g., "4 Sep 95" (beta) or "4 September 1995" *\/$/;"	m	struct:_ZpVer	access:public
_ZpVer::date	windll/windll.txt	/^    char *date;             \/* e.g., "4 Sep 95" (beta) or "4 September 1995" *\/$/;"	m	struct:_ZpVer	file:	access:public
_ZpVer::fEncryption	api.h	/^    BOOL fEncryption;       \/* TRUE if encryption enabled, FALSE otherwise *\/$/;"	m	struct:_ZpVer	access:public
_ZpVer::fEncryption	windll/windll.txt	/^    BOOL fEncryption;       \/* TRUE if encryption enabled, FALSE otherwise *\/$/;"	m	struct:_ZpVer	file:	access:public
_ZpVer::flag	api.h	/^    ulg flag;               \/* bit 0: is_beta   bit 1: uses_zlib *\/$/;"	m	struct:_ZpVer	access:public
_ZpVer::flag	windll/windll.txt	/^    ulg flag;               \/* bit 0: is_beta   bit 1: uses_zlib *\/$/;"	m	struct:_ZpVer	file:	access:public
_ZpVer::os2dll	api.h	/^    _zip_version_type os2dll;$/;"	m	struct:_ZpVer	access:public
_ZpVer::os2dll	windll/windll.txt	/^    _zip_version_type os2dll;$/;"	m	struct:_ZpVer	file:	access:public
_ZpVer::structlen	api.h	/^    ulg structlen;          \/* length of the struct being passed *\/$/;"	m	struct:_ZpVer	access:public
_ZpVer::structlen	windll/windll.txt	/^    ulg structlen;          \/* length of the struct being passed *\/$/;"	m	struct:_ZpVer	file:	access:public
_ZpVer::windll	api.h	/^    _zip_version_type windll;$/;"	m	struct:_ZpVer	access:public
_ZpVer::windll	windll/windll.txt	/^    _zip_version_type windll;$/;"	m	struct:_ZpVer	file:	access:public
_ZpVer::zip	api.h	/^    _zip_version_type zip;$/;"	m	struct:_ZpVer	access:public
_ZpVer::zip	windll/windll.txt	/^    _zip_version_type zip;$/;"	m	struct:_ZpVer	file:	access:public
_ZpVer::zlib_version	api.h	/^    char zlib_version[10];  \/* e.g., "0.95" or NULL *\/$/;"	m	struct:_ZpVer	access:public
_ZpVer::zlib_version	windll/windll.txt	/^    char *zlib_version;     \/* e.g., "0.95" or NULL *\/$/;"	m	struct:_ZpVer	file:	access:public
__32BIT__	os2/os2acl.c	67;"	d	file:
__32BIT__	os2/os2zip.c	20;"	d	file:
__32BIT__	os2/osdep.h	28;"	d
__686	crc_i386.S	80;"	d	file:
__686	win32/crc_i386.c	83;"	d	file:
__API_C	api.c	29;"	d	file:
__COMPACT__	msdos/crc_i86.asm	/^      ifdef __COMPACT__$/;"	v
__COMPACT__	msdos/match.asm	/^      ifdef __COMPACT__$/;"	v
__CRC32_C	crc32.c	22;"	d	file:
__CRTL_VER	vms/osdep.h	14;"	d
__CYGWIN__	win32/osdep.h	38;"	d
__DEFLATE_C	deflate.c	70;"	d	file:
__EBCDIC	zip.h	215;"	d
__FATDEF_LOADED	vms/vmsdefs.h	171;"	d
__FCHDEF_LOADED	vms/vmsdefs.h	274;"	d
__FILEIO_C	fileio.c	14;"	d	file:
__FJNDEF_LOADED	vms/vmsdefs.h	304;"	d
__G	crypt.h	75;"	d
__G	ttyio.h	28;"	d
__GDEF	crypt.h	77;"	d
__GDEF	ttyio.h	30;"	d
__GLOBALS_C	globals.c	14;"	d	file:
__GPRO	crypt.h	78;"	d
__GPRO	ttyio.h	31;"	d
__GPRO__	crypt.h	79;"	d
__GPRO__	ttyio.h	32;"	d
__G__	crypt.h	76;"	d
__G__	ttyio.h	29;"	d
__HUGE__	msdos/crc_i86.asm	/^        ifndef __HUGE__$/;"	v
__HUGE__	msdos/crc_i86.asm	/^ifdef __HUGE__$/;"	v
__HUGE__	msdos/match.asm	/^        ifndef __HUGE__$/;"	v
__HUGE__	msdos/match.asm	/^ifdef __HUGE__$/;"	v
__LARGE__	msdos/crc_i86.asm	/^   ifdef __LARGE__$/;"	v
__LARGE__	msdos/match.asm	/^   ifdef __LARGE__$/;"	v
__MACOPEN_H__	macos/source/macopen.h	10;"	d
__MACOS_OSDEP_H	macos/osdep.h	10;"	d
__MEDIUM__	msdos/crc_i86.asm	/^         ifdef __MEDIUM__$/;"	v
__MEDIUM__	msdos/match.asm	/^         ifdef __MEDIUM__$/;"	v
__RECURSEDIRECTORY__	macos/source/recurse.h	20;"	d
__STAT_H	amiga/z-stat.h	26;"	d
__STAT_H	cmsmvs/cstat.h	16;"	d
__TREES_C	trees.c	118;"	d	file:
__TTYIO_C	ttyio.c	29;"	d	file:
__TURBOC__	msdos/osdep.h	38;"	d
__TURBOC__	novell/osdep.h	38;"	d
__UNIXIO_LOADED	vms/unixio_gcc.h	8;"	d
__UNIXLIB_LOADED	vms/unixlib_gcc.h	8;"	d
__USE_SYSBASE	amiga/filedate.c	138;"	d	file:
__USE_SYSBASE	amiga/osdep.h	47;"	d
__UTIL_C	util.c	14;"	d	file:
__VAX	vms/vms.c	51;"	d	file:
__VAX	vms/vmsmunch.c	182;"	d	file:
__ZBZ2ERR_C	zbz2err.c	30;"	d	file:
__ZIPCLOAK_C	zipcloak.c	19;"	d	file:
__ZIPFILE_C	zipfile.c	14;"	d	file:
__ZIPNOTE_C	zipnote.c	14;"	d	file:
__ZIPSPLIT_C	zipsplit.c	14;"	d	file:
__ZIPUP_C	zipup.c	14;"	d	file:
__ZIP_C	zip.c	14;"	d	file:
___tmp_ptr	util.c	/^char *___tmp_ptr;$/;"	v
__amiga_amiga_h	amiga/amiga.h	10;"	d
__amiga_filedate_c	amiga/filedate.c	109;"	d	file:
__amiga_osdep_h	amiga/osdep.h	10;"	d
__amiga_stat_c	amiga/stat.c	23;"	d	file:
__amiga_z_stat_h	amiga/z-stat.h	10;"	d
__amiga_zipup_h	amiga/zipup.h	10;"	d
__anon10::ID	acorn/riscos.h	/^  short         ID;$/;"	m	struct:__anon10	access:public
__anon10::ID_2	acorn/riscos.h	/^  int           ID_2;$/;"	m	struct:__anon10	access:public
__anon10::attr	acorn/riscos.h	/^  int           attr;$/;"	m	struct:__anon10	access:public
__anon10::execaddr	acorn/riscos.h	/^  unsigned int  execaddr;$/;"	m	struct:__anon10	access:public
__anon10::loadaddr	acorn/riscos.h	/^  unsigned int  loadaddr;$/;"	m	struct:__anon10	access:public
__anon10::size	acorn/riscos.h	/^  short         size;$/;"	m	struct:__anon10	access:public
__anon10::zero	acorn/riscos.h	/^  int           zero;$/;"	m	struct:__anon10	access:public
__anon11::cbList	os2/os2zip.c	/^  ULONG cbList;               \/* length of value + 22 *\/$/;"	m	struct:__anon11	file:	access:public
__anon11::cbName	os2/os2zip.c	/^  BYTE cbName;                \/* length of ".LONGNAME" = 9 *\/$/;"	m	struct:__anon11	file:	access:public
__anon11::cbValue	os2/os2zip.c	/^  USHORT cbValue;             \/* length of value + 4 *\/$/;"	m	struct:__anon11	file:	access:public
__anon11::eaSize	os2/os2zip.c	/^  USHORT eaSize;              \/* length of value *\/$/;"	m	struct:__anon11	file:	access:public
__anon11::eaType	os2/os2zip.c	/^  USHORT eaType;              \/* 0xFFFD for length-preceded ASCII *\/$/;"	m	struct:__anon11	file:	access:public
__anon11::fEA	os2/os2zip.c	/^  BYTE fEA;                   \/* 0 *\/$/;"	m	struct:__anon11	file:	access:public
__anon11::oNext	os2/os2zip.c	/^  ULONG oNext;$/;"	m	struct:__anon11	file:	access:public
__anon11::szName	os2/os2zip.c	/^  BYTE szName[10];            \/* ".LONGNAME" *\/$/;"	m	struct:__anon11	file:	access:public
__anon11::szValue	os2/os2zip.c	/^  BYTE szValue[CCHMAXPATH];$/;"	m	struct:__anon11	file:	access:public
__anon12::cbList	os2/os2zip.c	/^  ULONG cbList;$/;"	m	struct:__anon12	file:	access:public
__anon12::cbName	os2/os2zip.c	/^  BYTE cbName;$/;"	m	struct:__anon12	file:	access:public
__anon12::oNext	os2/os2zip.c	/^  ULONG oNext;$/;"	m	struct:__anon12	file:	access:public
__anon12::szName	os2/os2zip.c	/^  BYTE szName[10];            \/* ".LONGNAME" *\/$/;"	m	struct:__anon12	file:	access:public
__anon13::lSize	os2/os2zip.c	/^  ULONG lSize;$/;"	m	struct:__anon13	file:	access:public
__anon13::nID	os2/os2zip.c	/^  USHORT nID;$/;"	m	struct:__anon13	file:	access:public
__anon13::nSize	os2/os2zip.c	/^  USHORT nSize;$/;"	m	struct:__anon13	file:	access:public
__anon14::cbName	os2/os2zip.c	/^  BYTE cbName;$/;"	m	struct:__anon14	file:	access:public
__anon14::cbValue	os2/os2zip.c	/^  USHORT cbValue;$/;"	m	struct:__anon14	file:	access:public
__anon14::fEA	os2/os2zip.c	/^  BYTE fEA;$/;"	m	struct:__anon14	file:	access:public
__anon14::oNextEntryOffset	os2/os2zip.c	/^  ULONG oNextEntryOffset;$/;"	m	struct:__anon14	file:	access:public
__anon14::szName	os2/os2zip.c	/^  CHAR szName[1];$/;"	m	struct:__anon14	file:	access:public
__anon15::cbList	os2/os2zip.c	/^  ULONG cbList;$/;"	m	struct:__anon15	file:	access:public
__anon15::list	os2/os2zip.c	/^  FEA2 list[1];$/;"	m	struct:__anon15	file:	access:public
__anon17::BackDate	macos/source/macglob.h	/^    time_t          BackDate;$/;"	m	struct:__anon17	access:public
__anon17::Bk_UTCoffs	macos/source/macglob.h	/^    long            Bk_UTCoffs; \/* offset "local time - UTC" for BackDate *\/$/;"	m	struct:__anon17	access:public
__anon17::BytesOfData	macos/source/macglob.h	/^    unsigned long   BytesOfData;$/;"	m	struct:__anon17	access:public
__anon17::Cr_UTCoffs	macos/source/macglob.h	/^    long            Cr_UTCoffs; \/* offset "local time - UTC" for CreatDate *\/$/;"	m	struct:__anon17	access:public
__anon17::CreatDate	macos/source/macglob.h	/^    time_t          CreatDate;$/;"	m	struct:__anon17	access:public
__anon17::CurrTextEncodingBase	macos/source/macglob.h	/^    short CurrTextEncodingBase;$/;"	m	struct:__anon17	access:public
__anon17::CurrentFork	macos/source/macglob.h	/^    short       CurrentFork;$/;"	m	struct:__anon17	access:public
__anon17::CurrentPath	macos/source/macglob.h	/^    char            CurrentPath[NAME_MAX];$/;"	m	struct:__anon17	access:public
__anon17::DataForkOnly	macos/source/macglob.h	/^    Boolean         DataForkOnly;$/;"	m	struct:__anon17	access:public
__anon17::FileName	macos/source/macglob.h	/^    char            FileName[NAME_MAX];$/;"	m	struct:__anon17	access:public
__anon17::FoundDirectories	macos/source/macglob.h	/^    unsigned long   FoundDirectories;$/;"	m	struct:__anon17	access:public
__anon17::FoundFiles	macos/source/macglob.h	/^    unsigned long   FoundFiles;$/;"	m	struct:__anon17	access:public
__anon17::FullPath	macos/source/macglob.h	/^    char            FullPath[NAME_MAX];$/;"	m	struct:__anon17	access:public
__anon17::HaveGMToffset	macos/source/macglob.h	/^    Boolean     HaveGMToffset;$/;"	m	struct:__anon17	access:public
__anon17::IncludeInvisible	macos/source/macglob.h	/^    Boolean         IncludeInvisible;$/;"	m	struct:__anon17	access:public
__anon17::MacZipMode	macos/source/macglob.h	/^    short       MacZipMode;$/;"	m	struct:__anon17	access:public
__anon17::Md_UTCoffs	macos/source/macglob.h	/^    long            Md_UTCoffs; \/* offset "local time - UTC" for ModDate *\/$/;"	m	struct:__anon17	access:public
__anon17::ModDate	macos/source/macglob.h	/^    time_t          ModDate;$/;"	m	struct:__anon17	access:public
__anon17::Pattern	macos/source/macglob.h	/^    char            Pattern[NAME_MAX];$/;"	m	struct:__anon17	access:public
__anon17::RawCountOfItems	macos/source/macglob.h	/^    unsigned long   RawCountOfItems;$/;"	m	struct:__anon17	access:public
__anon17::SearchDir	macos/source/macglob.h	/^    char            SearchDir[NAME_MAX];$/;"	m	struct:__anon17	access:public
__anon17::SearchLevels	macos/source/macglob.h	/^    unsigned short  SearchLevels;$/;"	m	struct:__anon17	access:public
__anon17::StatingProgress	macos/source/macglob.h	/^    Boolean         StatingProgress;$/;"	m	struct:__anon17	access:public
__anon17::StoreFoldersAlso	macos/source/macglob.h	/^    Boolean         StoreFoldersAlso;  \/* internal switch is true if '-r' is set *\/$/;"	m	struct:__anon17	access:public
__anon17::StoreFullPath	macos/source/macglob.h	/^    Boolean         StoreFullPath;$/;"	m	struct:__anon17	access:public
__anon17::TempZipFileSpec	macos/source/macglob.h	/^    FSSpec          TempZipFileSpec;$/;"	m	struct:__anon17	access:public
__anon17::TempZipFullPath	macos/source/macglob.h	/^    char            TempZipFullPath[NAME_MAX];$/;"	m	struct:__anon17	access:public
__anon17::ZipFileSpec	macos/source/macglob.h	/^    FSSpec          ZipFileSpec;$/;"	m	struct:__anon17	access:public
__anon17::ZipFileType	macos/source/macglob.h	/^    unsigned long   ZipFileType;$/;"	m	struct:__anon17	access:public
__anon17::ZipFullPath	macos/source/macglob.h	/^    char            ZipFullPath[NAME_MAX];$/;"	m	struct:__anon17	access:public
__anon17::attrsize	macos/source/macglob.h	/^    unsigned long   attrsize;$/;"	m	struct:__anon17	access:public
__anon17::dirID	macos/source/macglob.h	/^    long            dirID;$/;"	m	struct:__anon17	access:public
__anon17::fileSpec	macos/source/macglob.h	/^    FSSpec          fileSpec;$/;"	m	struct:__anon17	access:public
__anon17::fpb	macos/source/macglob.h	/^    CInfoPBRec      fpb;$/;"	m	struct:__anon17	access:public
__anon17::isDirectory	macos/source/macglob.h	/^    Boolean         isDirectory;$/;"	m	struct:__anon17	access:public
__anon17::isMacStatValid	macos/source/macglob.h	/^    Boolean     isMacStatValid;$/;"	m	struct:__anon17	access:public
__anon18::Date	windll/windll.txt	/^LPSTR Date;             \/* Date to include after *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::ExcludeList	windll/windll.txt	/^char **ExcludeList;     \/* Pointer to exclude file list array. Note that the last$/;"	m	struct:__anon18	file:	access:public
__anon18::ExcludeListCount	windll/windll.txt	/^long ExcludeListCount;  \/* Count of file names in the include list array *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::IncludeList	windll/windll.txt	/^char **IncludeList;     \/* Pointer to include file list array. Note that the last$/;"	m	struct:__anon18	file:	access:public
__anon18::IncludeListCount	windll/windll.txt	/^long IncludeListCount;  \/* Count of file names in the include list array *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fCRLF_LF	windll/windll.txt	/^BOOL fCRLF_LF;          \/* Translate CR\/LF to LF *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fComment	windll/windll.txt	/^BOOL fComment;          \/* Put comment in zip file *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fDeleteEntries	windll/windll.txt	/^BOOL fDeleteEntries;    \/* Delete files from zip file *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fEncrypt	windll/windll.txt	/^BOOL fEncrypt;          \/* encrypt files *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fEncryption	windll/windll.txt	/^BOOL fEncryption;       \/* TRUE if encryption supported, else FALSE.$/;"	m	struct:__anon18	file:	access:public
__anon18::fExcludeDate	windll/windll.txt	/^BOOL fExcludeDate;      \/* Exclude files earlier than specified date *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fExtra	windll/windll.txt	/^BOOL fExtra;            \/* Exclude extra attributes *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fForce	windll/windll.txt	/^BOOL fForce;            \/* Make entries using DOS names (k for Katz) *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fFreshen	windll/windll.txt	/^BOOL fFreshen;          \/* Freshen zip file--overwrite only *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fGrow	windll/windll.txt	/^BOOL fGrow;             \/* Allow appending to a zip file *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fIncludeDate	windll/windll.txt	/^BOOL fIncludeDate;      \/* Include only files earlier than specified date *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fJunkDir	windll/windll.txt	/^BOOL fJunkDir;          \/* Junk directory names *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fJunkSFX	windll/windll.txt	/^BOOL fJunkSFX;          \/* Junk SFX prefix *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fLF_CRLF	windll/windll.txt	/^BOOL fLF_CRLF;          \/* Translate LF to CR\/LF *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fLatestTime	windll/windll.txt	/^BOOL fLatestTime;       \/* Set zip file time to time of latest file in it *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fLevel	windll/windll.txt	/^char fLevel;            \/* Compression level (0 - 9) *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fMove	windll/windll.txt	/^BOOL fMove;             \/* Delete files added or updated in zip file *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fNoDirEntries	windll/windll.txt	/^BOOL fNoDirEntries;     \/* Do not add directory entries *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fOffsets	windll/windll.txt	/^BOOL fOffsets;          \/* Update archive offsets for SFX files *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fPrivilege	windll/windll.txt	/^BOOL fPrivilege;        \/* Use privileges (WIN32 only) *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fQuiet	windll/windll.txt	/^BOOL fQuiet;            \/* Quiet operation *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fRecurse	windll/windll.txt	/^int  fRecurse;          \/* Recurse into subdirectories. 1 => -r, 2 => -R *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fRepair	windll/windll.txt	/^int  fRepair;           \/* Repair archive. 1 => -F, 2 => -FF *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fSuffix	windll/windll.txt	/^BOOL fSuffix;           \/* include suffixes (not implemented in WiZ) *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fSystem	windll/windll.txt	/^BOOL fSystem;           \/* include system and hidden files *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fTemp	windll/windll.txt	/^BOOL fTemp;             \/* Use temporary directory '-b' during zipping *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fUpdate	windll/windll.txt	/^BOOL fUpdate;           \/* Update zip file--overwrite only if newer *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fVerbose	windll/windll.txt	/^BOOL fVerbose;          \/* Mention oddities in zip file structure *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::fVolume	windll/windll.txt	/^BOOL fVolume;           \/* Include volume label *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::szExcludeList	windll/windll.txt	/^LPSTR szExcludeList;    \/* Pointer to exclude file list (for VB) *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::szIncludeList	windll/windll.txt	/^LPSTR szIncludeList;    \/* Pointer to include file list string (for VB) *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::szRootDir	windll/windll.txt	/^LPSTR szRootDir;        \/* Directory to use as base for zipping *\/$/;"	m	struct:__anon18	file:	access:public
__anon18::szSplitSize	windll/windll.txt	/^LPSTR szSplitSize;		\/* This string contains the size that you want to $/;"	m	struct:__anon18	file:	access:public
__anon18::szTempDir	windll/windll.txt	/^LPSTR szTempDir;        \/* Temporary directory used during zipping *\/$/;"	m	struct:__anon18	file:	access:public
__anon19::argc	windll/windll.txt	/^int  argc;              = Count of files to zip$/;"	m	struct:__anon19	file:	access:public
__anon1::name	ziperr.h	/^    char *name;$/;"	m	struct:__anon1	access:public
__anon1::severity	ziperr.h	/^    int severity;$/;"	m	struct:__anon1	access:public
__anon1::string	ziperr.h	/^    char *string;$/;"	m	struct:__anon1	access:public
__anon20::ServiceApplication	windll/windll.txt	/^DLLSERVICE *ServiceApplication;$/;"	m	struct:__anon20	file:	access:public
__anon20::ServiceApplication64	windll/windll.txt	/^DLLSERVICE *ServiceApplication64;$/;"	m	struct:__anon20	file:	access:public
__anon20::ServiceApplication64_No_Int64	windll/windll.txt	/^DLLSERVICE_NO_INT64 *ServiceApplication64_No_Int64;$/;"	m	struct:__anon20	file:	access:public
__anon20::comment	windll/windll.txt	/^DLLCOMMENT *comment;$/;"	m	struct:__anon20	file:	access:public
__anon20::password	windll/windll.txt	/^DLLPASSWORD *password;$/;"	m	struct:__anon20	file:	access:public
__anon20::print	windll/windll.txt	/^DLLPRNT *print;$/;"	m	struct:__anon20	file:	access:public
__anon20::split	windll/windll.txt	/^DLLSPLIT *split;		\/* This MUST be set to NULL unless you want to be queried$/;"	m	struct:__anon20	file:	access:public
__anon21::count	cmsmvs/mvs.h	/^   unsigned short int count;$/;"	m	struct:__anon21	access:public
__anon21::rest	cmsmvs/mvs.h	/^   char rest[RECLEN];$/;"	m	struct:__anon21	access:public
__anon22::PKi	vms/vms_pk.c	/^    PK_info_t           PKi;$/;"	m	struct:__anon22	file:	access:public
__anon22::aclbuf	vms/vms_pk.c	/^    uch                 aclbuf[ATR$S_READACL];$/;"	m	struct:__anon22	file:	access:public
__anon22::acllen	vms/vms_pk.c	/^    long                acllen;$/;"	m	struct:__anon22	file:	access:public
__anon22::chan	vms/vms_pk.c	/^    ush                 chan;$/;"	m	struct:__anon22	file:	access:public
__anon22::chan_pad	vms/vms_pk.c	/^    ush                 chan_pad;       \/* alignment member *\/$/;"	m	struct:__anon22	file:	access:public
__anon22::iosb	vms/vms_pk.c	/^    struct iosb         iosb;$/;"	m	struct:__anon22	typeref:struct:__anon22::iosb	file:	access:public
__anon22::rest	vms/vms_pk.c	/^    uzoff_t             rest;$/;"	m	struct:__anon22	file:	access:public
__anon22::size	vms/vms_pk.c	/^    uzoff_t             size;$/;"	m	struct:__anon22	file:	access:public
__anon22::status	vms/vms_pk.c	/^    int                 status;$/;"	m	struct:__anon22	file:	access:public
__anon22::vbn	vms/vms_pk.c	/^    long                vbn;$/;"	m	struct:__anon22	file:	access:public
__anon23::bd	vms/vms.h	/^    ush tag_bd; ush len_bd;     byte bd[ATR$S_BAKDATE];$/;"	m	struct:__anon23	access:public
__anon23::cd	vms/vms.h	/^    ush tag_cd; ush len_cd;     byte cd[ATR$S_CREDATE];$/;"	m	struct:__anon23	access:public
__anon23::ed	vms/vms.h	/^    ush tag_ed; ush len_ed;     byte ed[ATR$S_EXPDATE];$/;"	m	struct:__anon23	access:public
__anon23::fp	vms/vms.h	/^    ush tag_fp; ush len_fp;     byte fp[ATR$S_FPRO];$/;"	m	struct:__anon23	access:public
__anon23::jr	vms/vms.h	/^    ush tag_jr; ush len_jr;     byte jr[ATR$S_JOURNAL];$/;"	m	struct:__anon23	access:public
__anon23::len_bd	vms/vms.h	/^    ush tag_bd; ush len_bd;     byte bd[ATR$S_BAKDATE];$/;"	m	struct:__anon23	access:public
__anon23::len_cd	vms/vms.h	/^    ush tag_cd; ush len_cd;     byte cd[ATR$S_CREDATE];$/;"	m	struct:__anon23	access:public
__anon23::len_ed	vms/vms.h	/^    ush tag_ed; ush len_ed;     byte ed[ATR$S_EXPDATE];$/;"	m	struct:__anon23	access:public
__anon23::len_fp	vms/vms.h	/^    ush tag_fp; ush len_fp;     byte fp[ATR$S_FPRO];$/;"	m	struct:__anon23	access:public
__anon23::len_jr	vms/vms.h	/^    ush tag_jr; ush len_jr;     byte jr[ATR$S_JOURNAL];$/;"	m	struct:__anon23	access:public
__anon23::len_ra	vms/vms.h	/^    ush tag_ra; ush len_ra;     byte ra[ATR$S_RECATTR];$/;"	m	struct:__anon23	access:public
__anon23::len_rd	vms/vms.h	/^    ush tag_rd; ush len_rd;     byte rd[ATR$S_REVDATE];$/;"	m	struct:__anon23	access:public
__anon23::len_rn	vms/vms.h	/^    ush tag_rn; ush len_rn;     ush  rn;$/;"	m	struct:__anon23	access:public
__anon23::len_rp	vms/vms.h	/^    ush tag_rp; ush len_rp;     byte rp[ATR$S_RPRO];$/;"	m	struct:__anon23	access:public
__anon23::len_uc	vms/vms.h	/^    ush tag_uc; ush len_uc;     byte uc[ATR$S_UCHAR];$/;"	m	struct:__anon23	access:public
__anon23::len_ui	vms/vms.h	/^    ush tag_ui; ush len_ui;     byte ui[ATR$S_UIC];$/;"	m	struct:__anon23	access:public
__anon23::ra	vms/vms.h	/^    ush tag_ra; ush len_ra;     byte ra[ATR$S_RECATTR];$/;"	m	struct:__anon23	access:public
__anon23::rd	vms/vms.h	/^    ush tag_rd; ush len_rd;     byte rd[ATR$S_REVDATE];$/;"	m	struct:__anon23	access:public
__anon23::rn	vms/vms.h	/^    ush tag_rn; ush len_rn;     ush  rn;$/;"	m	struct:__anon23	access:public
__anon23::rp	vms/vms.h	/^    ush tag_rp; ush len_rp;     byte rp[ATR$S_RPRO];$/;"	m	struct:__anon23	access:public
__anon23::tag_bd	vms/vms.h	/^    ush tag_bd; ush len_bd;     byte bd[ATR$S_BAKDATE];$/;"	m	struct:__anon23	access:public
__anon23::tag_cd	vms/vms.h	/^    ush tag_cd; ush len_cd;     byte cd[ATR$S_CREDATE];$/;"	m	struct:__anon23	access:public
__anon23::tag_ed	vms/vms.h	/^    ush tag_ed; ush len_ed;     byte ed[ATR$S_EXPDATE];$/;"	m	struct:__anon23	access:public
__anon23::tag_fp	vms/vms.h	/^    ush tag_fp; ush len_fp;     byte fp[ATR$S_FPRO];$/;"	m	struct:__anon23	access:public
__anon23::tag_jr	vms/vms.h	/^    ush tag_jr; ush len_jr;     byte jr[ATR$S_JOURNAL];$/;"	m	struct:__anon23	access:public
__anon23::tag_ra	vms/vms.h	/^    ush tag_ra; ush len_ra;     byte ra[ATR$S_RECATTR];$/;"	m	struct:__anon23	access:public
__anon23::tag_rd	vms/vms.h	/^    ush tag_rd; ush len_rd;     byte rd[ATR$S_REVDATE];$/;"	m	struct:__anon23	access:public
__anon23::tag_rn	vms/vms.h	/^    ush tag_rn; ush len_rn;     ush  rn;$/;"	m	struct:__anon23	access:public
__anon23::tag_rp	vms/vms.h	/^    ush tag_rp; ush len_rp;     byte rp[ATR$S_RPRO];$/;"	m	struct:__anon23	access:public
__anon23::tag_uc	vms/vms.h	/^    ush tag_uc; ush len_uc;     byte uc[ATR$S_UCHAR];$/;"	m	struct:__anon23	access:public
__anon23::tag_ui	vms/vms.h	/^    ush tag_ui; ush len_ui;     byte ui[ATR$S_UIC];$/;"	m	struct:__anon23	access:public
__anon23::uc	vms/vms.h	/^    ush tag_uc; ush len_uc;     byte uc[ATR$S_UCHAR];$/;"	m	struct:__anon23	access:public
__anon23::ui	vms/vms.h	/^    ush tag_ui; ush len_ui;     byte ui[ATR$S_UIC];$/;"	m	struct:__anon23	access:public
__anon24::bd	vms/vms.h	/^    ush tag_bd; ush len_bd;     byte bd[ATR$S_BAKDATE];$/;"	m	struct:__anon24	access:public
__anon24::cd	vms/vms.h	/^    ush tag_cd; ush len_cd;     byte cd[ATR$S_CREDATE];$/;"	m	struct:__anon24	access:public
__anon24::ed	vms/vms.h	/^    ush tag_ed; ush len_ed;     byte ed[ATR$S_EXPDATE];$/;"	m	struct:__anon24	access:public
__anon24::fp	vms/vms.h	/^    ush tag_fp; ush len_fp;     byte fp[ATR$S_FPRO];$/;"	m	struct:__anon24	access:public
__anon24::jr	vms/vms.h	/^    ush tag_jr; ush len_jr;     byte jr[ATR$S_JOURNAL];$/;"	m	struct:__anon24	access:public
__anon24::len_bd	vms/vms.h	/^    ush tag_bd; ush len_bd;     byte bd[ATR$S_BAKDATE];$/;"	m	struct:__anon24	access:public
__anon24::len_cd	vms/vms.h	/^    ush tag_cd; ush len_cd;     byte cd[ATR$S_CREDATE];$/;"	m	struct:__anon24	access:public
__anon24::len_ed	vms/vms.h	/^    ush tag_ed; ush len_ed;     byte ed[ATR$S_EXPDATE];$/;"	m	struct:__anon24	access:public
__anon24::len_fp	vms/vms.h	/^    ush tag_fp; ush len_fp;     byte fp[ATR$S_FPRO];$/;"	m	struct:__anon24	access:public
__anon24::len_jr	vms/vms.h	/^    ush tag_jr; ush len_jr;     byte jr[ATR$S_JOURNAL];$/;"	m	struct:__anon24	access:public
__anon24::len_ra	vms/vms.h	/^    ush tag_ra; ush len_ra;     byte ra[ATR$S_RECATTR];$/;"	m	struct:__anon24	access:public
__anon24::len_rd	vms/vms.h	/^    ush tag_rd; ush len_rd;     byte rd[ATR$S_REVDATE];$/;"	m	struct:__anon24	access:public
__anon24::len_rn	vms/vms.h	/^    ush tag_rn; ush len_rn;     ush  rn;$/;"	m	struct:__anon24	access:public
__anon24::len_rp	vms/vms.h	/^    ush tag_rp; ush len_rp;     byte rp[ATR$S_RPRO];$/;"	m	struct:__anon24	access:public
__anon24::len_uc	vms/vms.h	/^    ush tag_uc; ush len_uc;     byte uc[ATR$S_UCHAR];$/;"	m	struct:__anon24	access:public
__anon24::len_ui	vms/vms.h	/^    ush tag_ui; ush len_ui;     byte ui[ATR$S_UIC];$/;"	m	struct:__anon24	access:public
__anon24::ra	vms/vms.h	/^    ush tag_ra; ush len_ra;     byte ra[ATR$S_RECATTR];$/;"	m	struct:__anon24	access:public
__anon24::rd	vms/vms.h	/^    ush tag_rd; ush len_rd;     byte rd[ATR$S_REVDATE];$/;"	m	struct:__anon24	access:public
__anon24::rn	vms/vms.h	/^    ush tag_rn; ush len_rn;     ush  rn;$/;"	m	struct:__anon24	access:public
__anon24::rp	vms/vms.h	/^    ush tag_rp; ush len_rp;     byte rp[ATR$S_RPRO];$/;"	m	struct:__anon24	access:public
__anon24::tag_bd	vms/vms.h	/^    ush tag_bd; ush len_bd;     byte bd[ATR$S_BAKDATE];$/;"	m	struct:__anon24	access:public
__anon24::tag_cd	vms/vms.h	/^    ush tag_cd; ush len_cd;     byte cd[ATR$S_CREDATE];$/;"	m	struct:__anon24	access:public
__anon24::tag_ed	vms/vms.h	/^    ush tag_ed; ush len_ed;     byte ed[ATR$S_EXPDATE];$/;"	m	struct:__anon24	access:public
__anon24::tag_fp	vms/vms.h	/^    ush tag_fp; ush len_fp;     byte fp[ATR$S_FPRO];$/;"	m	struct:__anon24	access:public
__anon24::tag_jr	vms/vms.h	/^    ush tag_jr; ush len_jr;     byte jr[ATR$S_JOURNAL];$/;"	m	struct:__anon24	access:public
__anon24::tag_ra	vms/vms.h	/^    ush tag_ra; ush len_ra;     byte ra[ATR$S_RECATTR];$/;"	m	struct:__anon24	access:public
__anon24::tag_rd	vms/vms.h	/^    ush tag_rd; ush len_rd;     byte rd[ATR$S_REVDATE];$/;"	m	struct:__anon24	access:public
__anon24::tag_rn	vms/vms.h	/^    ush tag_rn; ush len_rn;     ush  rn;$/;"	m	struct:__anon24	access:public
__anon24::tag_rp	vms/vms.h	/^    ush tag_rp; ush len_rp;     byte rp[ATR$S_RPRO];$/;"	m	struct:__anon24	access:public
__anon24::tag_uc	vms/vms.h	/^    ush tag_uc; ush len_uc;     byte uc[ATR$S_UCHAR];$/;"	m	struct:__anon24	access:public
__anon24::tag_ui	vms/vms.h	/^    ush tag_ui; ush len_ui;     byte ui[ATR$S_UIC];$/;"	m	struct:__anon24	access:public
__anon24::uc	vms/vms.h	/^    ush tag_uc; ush len_uc;     byte uc[ATR$S_UCHAR];$/;"	m	struct:__anon24	access:public
__anon24::ui	vms/vms.h	/^    ush tag_ui; ush len_ui;     byte ui[ATR$S_UIC];$/;"	m	struct:__anon24	access:public
__anon25::buf	vms/vms.c	/^    void *buf;$/;"	m	struct:__anon25	file:	access:public
__anon25::buf_len	vms/vms.c	/^    short buf_len;$/;"	m	struct:__anon25	file:	access:public
__anon25::itm_cod	vms/vms.c	/^    short itm_cod;$/;"	m	struct:__anon25	file:	access:public
__anon25::ret_len	vms/vms.c	/^    int *ret_len;$/;"	m	struct:__anon25	file:	access:public
__anon26::rms_ext_itm	vms/vms.c	/^    jpi_item_t rms_ext_itm;$/;"	m	struct:__anon26	file:	access:public
__anon26::rms_mbc_itm	vms/vms.c	/^    jpi_item_t rms_mbc_itm;$/;"	m	struct:__anon26	file:	access:public
__anon26::rms_mbf_itm	vms/vms.c	/^    jpi_item_t rms_mbf_itm;$/;"	m	struct:__anon26	file:	access:public
__anon26::term	vms/vms.c	/^    int term;$/;"	m	struct:__anon26	file:	access:public
__anon27::name	vms/vms.c	/^   char *name;$/;"	m	struct:__anon27	file:	access:public
__anon27::value	vms/vms.c	/^   int value;$/;"	m	struct:__anon27	file:	access:public
__anon2::name	ziperr.h	/^    char *name;$/;"	m	struct:__anon2	access:public
__anon2::severity	ziperr.h	/^    int severity;$/;"	m	struct:__anon2	access:public
__anon2::string	ziperr.h	/^    char *string;$/;"	m	struct:__anon2	access:public
__anon30::Date	api.h	/^LPSTR Date;             \/* Date to include after *\/$/;"	m	struct:__anon30	access:public
__anon30::ExcludeList	api.h	/^char **ExcludeList;     \/* Pointer to exclude file list array. Note that the last$/;"	m	struct:__anon30	access:public
__anon30::ExcludeListCount	api.h	/^long ExcludeListCount;  \/* Count of file names in the include list array *\/$/;"	m	struct:__anon30	access:public
__anon30::IncludeList	api.h	/^char **IncludeList;     \/* Pointer to include file list array. Note that the last$/;"	m	struct:__anon30	access:public
__anon30::IncludeListCount	api.h	/^long IncludeListCount;  \/* Count of file names in the include list array *\/$/;"	m	struct:__anon30	access:public
__anon30::fCRLF_LF	api.h	/^BOOL fCRLF_LF;          \/* Translate CR\/LF to LF *\/$/;"	m	struct:__anon30	access:public
__anon30::fComment	api.h	/^BOOL fComment;          \/* Put comment in zip file *\/$/;"	m	struct:__anon30	access:public
__anon30::fDeleteEntries	api.h	/^BOOL fDeleteEntries;    \/* Delete files from zip file *\/$/;"	m	struct:__anon30	access:public
__anon30::fEncrypt	api.h	/^BOOL fEncrypt;          \/* encrypt files *\/$/;"	m	struct:__anon30	access:public
__anon30::fEncryption	api.h	/^BOOL fEncryption;       \/* TRUE if encryption supported, else FALSE.$/;"	m	struct:__anon30	access:public
__anon30::fExcludeDate	api.h	/^BOOL fExcludeDate;      \/* Exclude files newer than specified date *\/$/;"	m	struct:__anon30	access:public
__anon30::fExtra	api.h	/^BOOL fExtra;            \/* Exclude extra attributes *\/$/;"	m	struct:__anon30	access:public
__anon30::fForce	api.h	/^BOOL fForce;            \/* Make entries using DOS names (k for Katz) *\/$/;"	m	struct:__anon30	access:public
__anon30::fFreshen	api.h	/^BOOL fFreshen;          \/* Freshen zip file--overwrite only *\/$/;"	m	struct:__anon30	access:public
__anon30::fGrow	api.h	/^BOOL fGrow;             \/* Allow appending to a zip file *\/$/;"	m	struct:__anon30	access:public
__anon30::fIncludeDate	api.h	/^BOOL fIncludeDate;      \/* Include only files newer than specified date *\/$/;"	m	struct:__anon30	access:public
__anon30::fJunkDir	api.h	/^BOOL fJunkDir;          \/* Junk directory names *\/$/;"	m	struct:__anon30	access:public
__anon30::fJunkSFX	api.h	/^BOOL fJunkSFX;          \/* Junk SFX prefix *\/$/;"	m	struct:__anon30	access:public
__anon30::fLF_CRLF	api.h	/^BOOL fLF_CRLF;          \/* Translate LF to CR\/LF *\/$/;"	m	struct:__anon30	access:public
__anon30::fLatestTime	api.h	/^BOOL fLatestTime;       \/* Set zip file time to time of latest file in it *\/$/;"	m	struct:__anon30	access:public
__anon30::fLevel	api.h	/^char fLevel;            \/* Compression level (0 - 9) *\/$/;"	m	struct:__anon30	access:public
__anon30::fMove	api.h	/^BOOL fMove;             \/* Delete files added or updated in zip file *\/$/;"	m	struct:__anon30	access:public
__anon30::fNoDirEntries	api.h	/^BOOL fNoDirEntries;     \/* Do not add directory entries *\/$/;"	m	struct:__anon30	access:public
__anon30::fOffsets	api.h	/^BOOL fOffsets;          \/* Update archive offsets for SFX files *\/$/;"	m	struct:__anon30	access:public
__anon30::fPrivilege	api.h	/^BOOL fPrivilege;        \/* Use privileges (WIN32 only) *\/$/;"	m	struct:__anon30	access:public
__anon30::fQuiet	api.h	/^BOOL fQuiet;            \/* Quiet operation *\/$/;"	m	struct:__anon30	access:public
__anon30::fRecurse	api.h	/^int  fRecurse;          \/* Recurse into subdirectories. 1 => -r, 2 => -R *\/$/;"	m	struct:__anon30	access:public
__anon30::fRepair	api.h	/^int  fRepair;           \/* Repair archive. 1 => -F, 2 => -FF *\/$/;"	m	struct:__anon30	access:public
__anon30::fSuffix	api.h	/^BOOL fSuffix;           \/* include suffixes (not implemented) *\/$/;"	m	struct:__anon30	access:public
__anon30::fSystem	api.h	/^BOOL fSystem;           \/* include system and hidden files *\/$/;"	m	struct:__anon30	access:public
__anon30::fTemp	api.h	/^BOOL fTemp;             \/* Use temporary directory '-b' during zipping *\/$/;"	m	struct:__anon30	access:public
__anon30::fUpdate	api.h	/^BOOL fUpdate;           \/* Update zip file--overwrite only if newer *\/$/;"	m	struct:__anon30	access:public
__anon30::fVerbose	api.h	/^BOOL fVerbose;          \/* Mention oddities in zip file structure *\/$/;"	m	struct:__anon30	access:public
__anon30::fVolume	api.h	/^BOOL fVolume;           \/* Include volume label *\/$/;"	m	struct:__anon30	access:public
__anon30::szExcludeList	api.h	/^LPSTR szExcludeList;    \/* Pointer to exclude file list (for VB) *\/$/;"	m	struct:__anon30	access:public
__anon30::szIncludeList	api.h	/^LPSTR szIncludeList;    \/* Pointer to include file list string (for VB) *\/$/;"	m	struct:__anon30	access:public
__anon30::szRootDir	api.h	/^LPSTR szRootDir;        \/* Directory to use as base for zipping *\/$/;"	m	struct:__anon30	access:public
__anon30::szSplitSize	api.h	/^LPSTR szSplitSize;      \/* This string contains the size that you want to$/;"	m	struct:__anon30	access:public
__anon30::szTempDir	api.h	/^LPSTR szTempDir;        \/* Temporary directory used during zipping *\/$/;"	m	struct:__anon30	access:public
__anon31::FNV	api.h	/^  char **FNV;           \/* array of file names to zip up *\/$/;"	m	struct:__anon31	access:public
__anon31::argc	api.h	/^  int  argc;            \/* Count of files to zip *\/$/;"	m	struct:__anon31	access:public
__anon31::lpszAltFNL	api.h	/^  LPSTR lpszAltFNL;     \/* pointer to a string containing a list of file$/;"	m	struct:__anon31	access:public
__anon31::lpszZipFN	api.h	/^  LPSTR lpszZipFN;      \/* name of archive to create\/update *\/$/;"	m	struct:__anon31	access:public
__anon32::ServiceApplication	api.h	/^  DLLSERVICE *ServiceApplication;$/;"	m	struct:__anon32	access:public
__anon32::ServiceApplication64	api.h	/^  DLLSERVICE *ServiceApplication64;$/;"	m	struct:__anon32	access:public
__anon32::ServiceApplication64_No_Int64	api.h	/^  DLLSERVICE_NO_INT64 *ServiceApplication64_No_Int64;$/;"	m	struct:__anon32	access:public
__anon32::comment	api.h	/^  DLLCOMMENT *comment;$/;"	m	struct:__anon32	access:public
__anon32::password	api.h	/^  DLLPASSWORD *password;$/;"	m	struct:__anon32	access:public
__anon32::print	api.h	/^  DLLPRNT *print;$/;"	m	struct:__anon32	access:public
__anon32::split	api.h	/^  DLLSPLIT *split;      \/* This MUST be set to NULL unless you want to be queried$/;"	m	struct:__anon32	access:public
__anon33::__anon34::hi	qdos/qdos.c	/^        unsigned char hi __attribute__ ((packed));$/;"	m	struct:__anon33::__anon34	file:	access:public
__anon33::__anon34::lo	qdos/qdos.c	/^        unsigned char lo __attribute__ ((packed));$/;"	m	struct:__anon33::__anon34	file:	access:public
__anon33::header	qdos/qdos.c	/^    struct      qdirect     header __attribute__ ((packed));$/;"	m	struct:__anon33	typeref:struct:__anon33::qdirect	file:	access:public
__anon33::len	qdos/qdos.c	/^    } len __attribute__ ((packed));$/;"	m	struct:__anon33	typeref:struct:__anon33::__anon34	file:	access:public
__anon33::longid	qdos/qdos.c	/^    char        longid[8] __attribute__ ((packed));$/;"	m	struct:__anon33	file:	access:public
__anon33::shortid	qdos/qdos.c	/^    unsigned short shortid __attribute__ ((packed));$/;"	m	struct:__anon33	file:	access:public
__anon35::ov	tandem/tandem.h	/^  struct nsk_stat_overlay  ov;$/;"	m	union:__anon35	typeref:struct:__anon35::nsk_stat_overlay	access:public
__anon35::reserved	tandem/tandem.h	/^  struct nsk_stat_reserved reserved;$/;"	m	union:__anon35	typeref:struct:__anon35::nsk_stat_reserved	access:public
__anon3::more	tops20/tops20.c	/^   int  more;$/;"	m	struct:__anon3	file:	access:public
__anon3::wfjfn	tops20/tops20.c	/^   int  wfjfn;$/;"	m	struct:__anon3	file:	access:public
__anon4::lSize	win32/nt.h	/^  ULONG lSize;$/;"	m	struct:__anon4	access:public
__anon4::nID	win32/nt.h	/^  USHORT nID;$/;"	m	struct:__anon4	access:public
__anon4::nSize	win32/nt.h	/^  USHORT nSize;$/;"	m	struct:__anon4	access:public
__anon5::Version	win32/nt.h	/^  BYTE Version; \/* Version of uncompressed security descriptor data format *\/$/;"	m	struct:__anon5	access:public
__anon5::lSize	win32/nt.h	/^  ULONG lSize;  \/* uncompressed security descriptor data size *\/$/;"	m	struct:__anon5	access:public
__anon5::nID	win32/nt.h	/^  USHORT nID;   \/* tag for this extra block type *\/$/;"	m	struct:__anon5	access:public
__anon5::nSize	win32/nt.h	/^  USHORT nSize; \/* total data size for this block *\/$/;"	m	struct:__anon5	access:public
__anon6::RootPath	win32/nt.h	/^    char RootPath[MAX_PATH+1];  \/* path to network \/ filesystem *\/$/;"	m	struct:__anon6	access:public
__anon6::bProcessDefer	win32/nt.h	/^    BOOL bProcessDefer;         \/* process deferred entry yet? *\/$/;"	m	struct:__anon6	access:public
__anon6::bRemote	win32/nt.h	/^    BOOL bRemote;               \/* is volume remote? *\/$/;"	m	struct:__anon6	access:public
__anon6::bUsePrivileges	win32/nt.h	/^    BOOL bUsePrivileges;        \/* use privilege overrides? *\/$/;"	m	struct:__anon6	access:public
__anon6::bValid	win32/nt.h	/^    BOOL bValid;                \/* are our contents valid? *\/$/;"	m	struct:__anon6	access:public
__anon6::dwFileAttributes	win32/nt.h	/^    DWORD dwFileAttributes;$/;"	m	struct:__anon6	access:public
__anon6::dwFileSystemFlags	win32/nt.h	/^    DWORD dwFileSystemFlags;    \/* describes target file system *\/$/;"	m	struct:__anon6	access:public
__anon6::dwRemotePrivileges	win32/nt.h	/^    DWORD dwRemotePrivileges;   \/* relevant only on remote volumes *\/$/;"	m	struct:__anon6	access:public
__anon7::errmess	acorn/riscos.h	/^  char errmess[252];$/;"	m	struct:__anon7	access:public
__anon7::errnum	acorn/riscos.h	/^  int errnum;$/;"	m	struct:__anon7	access:public
__anon8::act	acorn/riscos.h	/^  char *act;$/;"	m	struct:__anon8	access:public
__anon8::buf	acorn/riscos.h	/^  void *buf;$/;"	m	struct:__anon8	access:public
__anon8::dirname	acorn/riscos.h	/^  char *dirname;$/;"	m	struct:__anon8	access:public
__anon8::offset	acorn/riscos.h	/^  int offset;$/;"	m	struct:__anon8	access:public
__anon8::read	acorn/riscos.h	/^  int read;$/;"	m	struct:__anon8	access:public
__anon8::size	acorn/riscos.h	/^  int size;$/;"	m	struct:__anon8	access:public
__anon9::attrib	acorn/riscos.h	/^  int attrib;$/;"	m	struct:__anon9	access:public
__anon9::exec_addr	acorn/riscos.h	/^  unsigned int exec_addr;$/;"	m	struct:__anon9	access:public
__anon9::lenght	acorn/riscos.h	/^  int lenght;$/;"	m	struct:__anon9	access:public
__anon9::load_addr	acorn/riscos.h	/^  unsigned int load_addr;$/;"	m	struct:__anon9	access:public
__anon9::name	acorn/riscos.h	/^  char name[13];$/;"	m	struct:__anon9	access:public
__anon9::objtype	acorn/riscos.h	/^  int objtype;$/;"	m	struct:__anon9	access:public
__attribute__	qdos/qdos.c	78;"	d	file:
__blksize	proginfo/fileinfo.cms	/^          unsigned long  __blksize,         \/* see below 3 *\/$/;"	m	struct:__filedata	file:	access:public
__cmsmvs_h	cmsmvs/cmsmvs.h	17;"	d
__crc32_h	crc32.h	15;"	d
__crt0_glob_function	msdos/msdos.c	/^char **__crt0_glob_function(char *_arg)$/;"	f	signature:(char *_arg)
__crt0_load_environment_file	msdos/msdos.c	/^void __crt0_load_environment_file(char *_app_name)$/;"	f	signature:(char *_app_name)
__crypt_h	crypt.h	26;"	d
__device	proginfo/fileinfo.cms	/^          char           __device;  __DISK$/;"	m	struct:__filedata	file:	access:public
__dsname	proginfo/fileinfo.cms	/^          char *         __dsname;          \/* fname ftype fmode *\/$/;"	m	struct:__filedata	file:	access:public
__dsorgConcat	proginfo/fileinfo.cms	/^                         __dsorgConcat : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__dsorgHiper	proginfo/fileinfo.cms	/^                         __dsorgHiper  : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__dsorgMem	proginfo/fileinfo.cms	/^                         __dsorgMem    : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__dsorgPDSdir	proginfo/fileinfo.cms	/^                         __dsorgPDSdir : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__dsorgPDSmem	proginfo/fileinfo.cms	/^                         __dsorgPDSmem : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__dsorgPO	proginfo/fileinfo.cms	/^                         __dsorgPO     : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__dsorgPS	proginfo/fileinfo.cms	/^                         __dsorgPS     : 1, \/* sequential data set *\/$/;"	m	struct:__filedata	file:	access:public
__dsorgTemp	proginfo/fileinfo.cms	/^                         __dsorgTemp   : 1, \/* created with tmpfile() *\/$/;"	m	struct:__filedata	file:	access:public
__dsorgVSAM	proginfo/fileinfo.cms	/^                         __dsorgVSAM   : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__ebcdic_h	ebcdic.h	45;"	d
__far	api.h	33;"	d
__far	windll/structs.h	22;"	d
__filedata	proginfo/fileinfo.cms	/^     struct __filedata {$/;"	s	file:
__filedata::__blksize	proginfo/fileinfo.cms	/^          unsigned long  __blksize,         \/* see below 3 *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__device	proginfo/fileinfo.cms	/^          char           __device;  __DISK$/;"	m	struct:__filedata	file:	access:public
__filedata::__dsname	proginfo/fileinfo.cms	/^          char *         __dsname;          \/* fname ftype fmode *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__dsorgConcat	proginfo/fileinfo.cms	/^                         __dsorgConcat : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__dsorgHiper	proginfo/fileinfo.cms	/^                         __dsorgHiper  : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__dsorgMem	proginfo/fileinfo.cms	/^                         __dsorgMem    : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__dsorgPDSdir	proginfo/fileinfo.cms	/^                         __dsorgPDSdir : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__dsorgPDSmem	proginfo/fileinfo.cms	/^                         __dsorgPDSmem : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__dsorgPO	proginfo/fileinfo.cms	/^                         __dsorgPO     : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__dsorgPS	proginfo/fileinfo.cms	/^                         __dsorgPS     : 1, \/* sequential data set *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__dsorgTemp	proginfo/fileinfo.cms	/^                         __dsorgTemp   : 1, \/* created with tmpfile() *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__dsorgVSAM	proginfo/fileinfo.cms	/^                         __dsorgVSAM   : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__maxreclen	proginfo/fileinfo.cms	/^                         __maxreclen;       \/* see below 4 *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__modeflag	proginfo/fileinfo.cms	/^                         __modeflag    : 4, \/* see below 2 *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__openmode	proginfo/fileinfo.cms	/^                         __openmode    : 2, \/* see below 1 *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__recfmASA	proginfo/fileinfo.cms	/^                         __recfmASA    : 1, \/* text mode and ASA *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__recfmBlk	proginfo/fileinfo.cms	/^                         __recfmBlk    : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__recfmF	proginfo/fileinfo.cms	/^          unsigned int   __recfmF      : 1, \/* fixed length records *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__recfmM	proginfo/fileinfo.cms	/^                         __recfmM      : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__recfmS	proginfo/fileinfo.cms	/^                         __recfmS      : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__recfmU	proginfo/fileinfo.cms	/^                         __recfmU      : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__recfmV	proginfo/fileinfo.cms	/^                         __recfmV      : 1, \/* variable length records *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__reserve1	proginfo/fileinfo.cms	/^                         __reserve1    : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__reserve2	proginfo/fileinfo.cms	/^                         __reserve2    : 9, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__reserve4	proginfo/fileinfo.cms	/^          unsigned int   __reserve4;        \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__vsamRKP	proginfo/fileinfo.cms	/^          unsigned long  __vsamRKP;         \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__vsamkeylen	proginfo/fileinfo.cms	/^          unsigned long  __vsamkeylen;      \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__filedata::__vsamtype	proginfo/fileinfo.cms	/^          unsigned short __vsamtype;        \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__human68k__	proginfo/ZipPorts	/^      it:  AMIGA, ATARI_ST, __human68k__, MACOS, MSDOS, MVS, OS2, TOPS20,$/;"	v
__locate	theos/_stat.c	/^struct fdb* __locate(const char* fn, char* buf, short* drv)$/;"	f	signature:(const char* fn, char* buf, short* drv)
__macos_charmap_h	macos/source/charmap.h	10;"	d
__maxreclen	proginfo/fileinfo.cms	/^                         __maxreclen;       \/* see below 4 *\/$/;"	m	struct:__filedata	file:	access:public
__modeflag	proginfo/fileinfo.cms	/^                         __modeflag    : 4, \/* see below 2 *\/$/;"	m	struct:__filedata	file:	access:public
__near	api.h	36;"	d
__near	windll/structs.h	25;"	d
__open	theos/_stat.c	/^int __open(const char* fn, int mode)$/;"	f	signature:(const char* fn, int mode)
__openmode	proginfo/fileinfo.cms	/^                         __openmode    : 2, \/* see below 1 *\/$/;"	m	struct:__filedata	file:	access:public
__recfmASA	proginfo/fileinfo.cms	/^                         __recfmASA    : 1, \/* text mode and ASA *\/$/;"	m	struct:__filedata	file:	access:public
__recfmBlk	proginfo/fileinfo.cms	/^                         __recfmBlk    : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__recfmF	proginfo/fileinfo.cms	/^          unsigned int   __recfmF      : 1, \/* fixed length records *\/$/;"	m	struct:__filedata	file:	access:public
__recfmM	proginfo/fileinfo.cms	/^                         __recfmM      : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__recfmS	proginfo/fileinfo.cms	/^                         __recfmS      : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__recfmU	proginfo/fileinfo.cms	/^                         __recfmU      : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__recfmV	proginfo/fileinfo.cms	/^                         __recfmV      : 1, \/* variable length records *\/$/;"	m	struct:__filedata	file:	access:public
__reserve1	proginfo/fileinfo.cms	/^                         __reserve1    : 1, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__reserve2	proginfo/fileinfo.cms	/^                         __reserve2    : 9, \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__reserve4	proginfo/fileinfo.cms	/^          unsigned int   __reserve4;        \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__revision_h	revision.h	16;"	d
__riscos_h	acorn/riscos.h	12;"	d
__signal_return_type	amiga/stat.c	/^typedef void (*__signal_return_type)(int);$/;"	t	file:
__struct	vms/vmsdefs.h	57;"	d
__struct	vms/vmsdefs.h	60;"	d
__swiven_h	acorn/swiven.h	12;"	d
__tandem_h	tandem/tandem.h	10;"	d
__tannsk_h	tandem/tannsk.h	14;"	d
__tanzip_h	tandem/tanzip.h	10;"	d
__theos_stat_h	theos/stat.h	2;"	d
__timezone_c	timezone.c	37;"	d	file:
__timezone_h	timezone.h	12;"	d
__ttyio_h	ttyio.h	16;"	d
__tzset	timezone.c	/^void __tzset()$/;"	f
__union	vms/vmsdefs.h	58;"	d
__union	vms/vmsdefs.h	61;"	d
__vms_h	vms/vms.h	18;"	d
__vmsdefs_h	vms/vmsdefs.h	45;"	d
__vmsmunch_h	vms/vmsmunch.h	40;"	d
__vsamRKP	proginfo/fileinfo.cms	/^          unsigned long  __vsamRKP;         \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__vsamkeylen	proginfo/fileinfo.cms	/^          unsigned long  __vsamkeylen;      \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__vsamtype	proginfo/fileinfo.cms	/^          unsigned short __vsamtype;        \/* n\/a *\/$/;"	m	struct:__filedata	file:	access:public
__zip_h	zip.h	77;"	d
__zipup_cb_h	vms/zipup.h	36;"	d
__zipup_h	vms/zipup.h	11;"	d
_abort	amiga/amiga.c	/^void _abort(void)               \/* called when ^C is pressed *\/$/;"	f	signature:(void)
_arg_len	amiga/stat.c	/^int _argc, _arg_len;$/;"	v
_arg_lin	amiga/stat.c	/^char **_argv, *_arg_lin;$/;"	v
_argc	amiga/stat.c	/^int _argc, _arg_len;$/;"	v
_argv	amiga/stat.c	/^char **_argv, *_arg_lin;$/;"	v
_calloc	amiga/deflate.a	/^        xref    _calloc         ; stdlib function: void *calloc(size_t, size_t)$/;"	v
_calloc	human68k/deflate.s	/^        xref    _calloc         ; stdlib function: void *calloc(size_t, size_t)$/;"	v
_chmod	theos/_chmod.c	/^int _chmod(const char *fname, short mask)$/;"	f	signature:(const char *fname, short mask)
_chstat	theos/stat.h	103;"	d
_cli_parse	amiga/stat.c	/^void _cli_parse(struct Process *pp, long alen, register UBYTE *aptr)$/;"	f	signature:(struct Process *pp, long alen, register UBYTE *aptr)
_compress	vms/vms_im.c	/^static int _compress(from,to,size)$/;"	f	file:
_compress_block	vms/vms_im.c	/^static uch *_compress_block(to,from,size,sig)$/;"	f	file:
_condetails	qdos/qdos.c	/^struct WINDOWDEF _condetails =$/;"	v	typeref:struct:WINDOWDEF
_consetup	qdos/qdos.c	/^void (*_consetup)(chanid_t,struct WINDOWDEF *) = consetup_title;$/;"	v
_copyright	qdos/qdos.c	/^char _copyright[] = "(c) Info-ZIP Group";$/;"	v
_crc32	crc_i386.S	57;"	d	file:
_ct_tally	amiga/deflate.a	/^        xref    _ct_tally       ; int ct_tally(int, int)$/;"	v
_ct_tally	human68k/deflate.s	/^        xref    _ct_tally       ; int ct_tally(int, int)$/;"	v
_d_date	os2/os2zip.h	/^  unsigned _d_mode, _d_time, _d_date;$/;"	m	struct:_dircontents	access:public
_d_entry	os2/os2zip.h	/^  char *_d_entry;$/;"	m	struct:_dircontents	access:public
_d_mode	os2/os2zip.h	/^  unsigned _d_mode, _d_time, _d_date;$/;"	m	struct:_dircontents	access:public
_d_next	os2/os2zip.h	/^  struct _dircontents *_d_next;$/;"	m	struct:_dircontents	typeref:struct:_dircontents::_dircontents	access:public
_d_size	os2/os2zip.h	/^  long _d_size;$/;"	m	struct:_dircontents	access:public
_d_time	os2/os2zip.h	/^  unsigned _d_mode, _d_time, _d_date;$/;"	m	struct:_dircontents	access:public
_deflate	amiga/deflate.a	/^        xdef    _deflate        ; void deflate(void)  ...the big one$/;"	v
_deflate	amiga/deflate.a	/^_deflate:           ; first, setup steps common to deflate and deflate_fast:$/;"	v
_deflate	human68k/deflate.s	/^        xdef    _deflate        ; void deflate(void)  ...the big one$/;"	v
_dircontents	os2/os2zip.h	/^struct _dircontents$/;"	s
_dircontents::_d_date	os2/os2zip.h	/^  unsigned _d_mode, _d_time, _d_date;$/;"	m	struct:_dircontents	access:public
_dircontents::_d_entry	os2/os2zip.h	/^  char *_d_entry;$/;"	m	struct:_dircontents	access:public
_dircontents::_d_mode	os2/os2zip.h	/^  unsigned _d_mode, _d_time, _d_date;$/;"	m	struct:_dircontents	access:public
_dircontents::_d_next	os2/os2zip.h	/^  struct _dircontents *_d_next;$/;"	m	struct:_dircontents	typeref:struct:_dircontents::_dircontents	access:public
_dircontents::_d_size	os2/os2zip.h	/^  long _d_size;$/;"	m	struct:_dircontents	access:public
_dircontents::_d_time	os2/os2zip.h	/^  unsigned _d_mode, _d_time, _d_date;$/;"	m	struct:_dircontents	access:public
_dirdesc	os2/os2zip.h	/^typedef struct _dirdesc$/;"	s
_dirdesc::dd_contents	os2/os2zip.h	/^  struct _dircontents *dd_contents;   \/* pointer to contents of dir *\/$/;"	m	struct:_dirdesc	typeref:struct:_dirdesc::_dircontents	access:public
_dirdesc::dd_cp	os2/os2zip.h	/^  struct _dircontents *dd_cp;         \/* pointer to current position *\/$/;"	m	struct:_dirdesc	typeref:struct:_dirdesc::_dircontents	access:public
_dirdesc::dd_id	os2/os2zip.h	/^  int  dd_id;                   \/* uniquely identify each open directory *\/$/;"	m	struct:_dirdesc	access:public
_dirdesc::dd_loc	os2/os2zip.h	/^  long dd_loc;                  \/* where we are in directory entry is this *\/$/;"	m	struct:_dirdesc	access:public
_dstat_	theos/_stat.c	/^int _dstat_(st)$/;"	f
_dtoxtime	msdos/msdos.c	/^time_t _dtoxtime(year, month, mday, hour, min, sec)$/;"	f
_endmsg	qdos/qdos.c	/^char *  _endmsg = NULL;$/;"	v
_error	amiga/deflate.a	/^        xref    _error          ; void error(char *)$/;"	v
_error	human68k/deflate.s	/^        xref    _error          ; void error(char *)$/;"	v
_exit	msdos/match.asm	/^        call    _exit                   ; incompatible "global vars interface"$/;"	v
_far	api.h	32;"	d
_far	windll/structs.h	21;"	d
_fill_window	amiga/deflate.a	/^        xdef    _fill_window    ; this line is just for debugging$/;"	v
_fill_window	amiga/deflate.a	/^_fill_window:                           ; C-callable entry point$/;"	v
_fill_window	human68k/deflate.s	/^        xdef    _fill_window    ; this line is just for debugging$/;"	v
_fill_window	human68k/deflate.s	/^_fill_window:                           ; C-callable entry point$/;"	v
_flush_block	amiga/deflate.a	/^        xref    _flush_block    ; unsigned long F(char *, unsigned long, int)$/;"	v
_flush_block	human68k/deflate.s	/^        xref    _flush_block    ; unsigned long F(char *, unsigned long, int)$/;"	v
_foo	amiga/match_68.a	/^;   ATSIGN     define entry symbols in @foo form as well as _foo, with$/;"	v
_fopen	theos/_stat.c	/^FILE* _fopen(const char* fn, const char* mode)$/;"	f	signature:(const char* fn, const char* mode)
_fopen	theos/osdep.h	50;"	d
_fprintf	theos/_fprintf.c	/^int _fprintf(FILE* fp, const char* fmt, ...)$/;"	f	signature:(FILE* fp, const char* fmt, ...)
_fstat	theos/_stat.c	/^int _fstat(int fd, struct stat *st)$/;"	f	signature:(int fd, struct stat *st)
_get_crc_table	crc_i386.S	58;"	d	file:
_get_crc_table	msdos/crc_i86.asm	/^        call     _get_crc_table$/;"	v
_get_osfhandle	win32/win32.c	731;"	d	file:
_good_match	amiga/match_68.a	/^        xref    _good_match         ; signed int$/;"	v
_good_match	match.S	/^        cmp     _good_match,%ebx       \/* do we have a good match already? *\/$/;"	v
_good_match	match.S	29;"	d	file:
_good_match	win32/lm32_lcc.asm	/^        cmp     _good_match,%ebx$/;"	v
_halloc	msdos/msdos.c	755;"	d	file:
_head	amiga/deflate.a	/^        BASEPTR _head,\\1$/;"	v
_head	amiga/deflate.a	/^        BASEPTR _head,a0$/;"	v
_head	human68k/deflate.s	/^        BASEPTR _head,_1$/;"	v
_head	human68k/deflate.s	/^        BASEPTR _head,a0$/;"	v
_hfree	msdos/msdos.c	756;"	d	file:
_is_executable	msdos/msdos.c	/^int _is_executable (const char *path, int fhandle, const char *ext)$/;"	f	signature:(const char *path, int fhandle, const char *ext)
_isatty	theos/_isatty.c	/^short _isatty(int fd)$/;"	f	signature:(int fd)
_isindst	timezone.c	/^int _isindst(tb)$/;"	f
_isprt	theos/_stat.c	/^static int _isprt(int dev)$/;"	f	file:	signature:(int dev)
_level	amiga/deflate.a	/^        MOVINT  _level,d0$/;"	v
_level	amiga/deflate.a	/^        xref    _level          ; signed int$/;"	v
_level	human68k/deflate.s	/^        MOVINT  _level,d0$/;"	v
_level	human68k/deflate.s	/^        xref    _level          ; signed int$/;"	v
_lm_free	amiga/deflate.a	/^        xdef    _lm_free        ; void lm_free(void)$/;"	v
_lm_free	human68k/deflate.s	/^        xdef    _lm_free        ; void lm_free(void)$/;"	v
_lm_free	human68k/deflate.s	/^;;;     xdef    _lm_free                ; the entry point$/;"	v
_lm_init	amiga/deflate.a	/^        xdef    _lm_init        ; void lm_init(int level, unsigned short *flags)$/;"	v
_lm_init	human68k/deflate.s	/^        xdef    _lm_init        ; void lm_init(int level, unsigned short *flags)$/;"	v
_lm_init	human68k/deflate.s	/^;;;     xdef    _lm_init                ; the entry point$/;"	v
_locate	theos/_stat.c	184;"	d	file:
_locate	theos/_stat.c	185;"	d	file:
_longest_match	amiga/match_68.a	/^        xdef    _longest_match      ; int longest_match(unsigned cur_match);$/;"	v
_longest_match	match.S	35;"	d	file:
_longest_match	win32/lm32_lcc.asm	/^_longest_match: ;\/* int longest_match(cur_match) *\/$/;"	v
_match_init	amiga/match_68.a	/^        xdef    _match_init         ; void match_init(void);$/;"	v
_match_init	match.S	34;"	d	file:
_match_start	amiga/match_68.a	/^        xref    _match_start        ; unsigned int$/;"	v
_match_start	match.S	27;"	d	file:
_max_chain_length	amiga/match_68.a	/^        xref    _max_chain_length   ; unsigned int$/;"	v
_max_chain_length	match.S	/^        mov     _max_chain_length,%ebp \/* chain_length = max_chain_length *\/$/;"	v
_max_chain_length	match.S	32;"	d	file:
_max_chain_length	msdos/match.asm	/^        mov     bp,_max_chain_length    ; chain_length = max_chain_length$/;"	v
_max_chain_length	win32/lm32_lcc.asm	/^        mov     _max_chain_length,%ebp$/;"	v
_max_chain_length	win32/match32.asm	/^        mov     ebp,_max_chain_length   ; chain_length = max_chain_length$/;"	v
_n_	theos/_rename.c	/^static void _n_(const char* fn, char* bfn)$/;"	f	file:	signature:(const char* fn, char* bfn)
_near	api.h	35;"	d
_near	windll/structs.h	24;"	d
_nice_match	amiga/match_68.a	/^        xref    _nice_match         ; signed int$/;"	v
_nice_match	match.S	30;"	d	file:
_nice_match	win32/lm32_lcc.asm	/^        cmp     _nice_match,%eax$/;"	v
_opendir	theos/_stat.c	/^struct dirent* _opendir(const char* dirpath)$/;"	f	signature:(const char* dirpath)
_prev	amiga/deflate.a	/^        BASEPTR _prev,Prev$/;"	v
_prev	amiga/deflate.a	/^        BASEPTR _prev,Prev_Address$/;"	v
_prev	amiga/deflate.a	/^        BASEPTR _prev,a0$/;"	v
_prev	amiga/match.a	/^        lea     _prev,Prev_Address$/;"	v
_prev	amiga/match_68.a	/^        lea     _prev,Prev_Address$/;"	v
_prev	amiga/match_68.a	/^        xref    _prev               ; array of unsigned short$/;"	v
_prev	human68k/deflate.s	/^        BASEPTR _prev,Prev$/;"	v
_prev	human68k/deflate.s	/^        BASEPTR _prev,Prev_Address$/;"	v
_prev	human68k/deflate.s	/^        BASEPTR _prev,a0$/;"	v
_prev	human68k/match.s	/^        lea     _prev,Prev_Address$/;"	v
_prev	match.S	25;"	d	file:
_prev	msdos/match.asm	/^        cmp     _prev[0],0              ; verify zero offset$/;"	v
_prev	msdos/match.asm	/^        mov     ax,_prev[2]             ; segment value$/;"	v
_prev	msdos/match.asm	/^        prev    equ  _prev    ; offset part$/;"	v
_prev	msdos/match.asm	/^        prev_seg  equ ss:_prev[2]       ; works on OS\/2 if SS == DS$/;"	v
_prev	msdos/match.asm	/^    prev_ptr    dw  seg _prev           ; pointer to the prev array$/;"	v
_prev	qdos/match.s	/^        lea     _prev,a2$/;"	v
_prev	win32/match32.asm	/^        mov     si,_prev[esi+esi]       ; cur_match = prev[cur_match]$/;"	v
_prev_length	amiga/match_68.a	/^        xref    _prev_length        ; unsigned int$/;"	v
_prev_length	match.S	/^        mov     _prev_length,%ebx      \/* best_len = prev_length *\/$/;"	v
_prev_length	match.S	28;"	d	file:
_prev_length	win32/lm32_lcc.asm	/^        mov     _prev_length,%ebx$/;"	v
_prog_name	qdos/qdos.c	/^char _prog_name[] = "zip";$/;"	v
_read_buf	amiga/deflate.a	/^        xref    _read_buf       ; int (*read_buf)(char *, unsigned int)$/;"	v
_read_buf	human68k/deflate.s	/^        xref    _read_buf       ; int (*read_buf)(char *, unsigned int)$/;"	v
_rename	theos/_rename.c	/^int _rename(const char* old, const char* new)$/;"	f	signature:(const char* old, const char* new)
_setargv	theos/_setargv.c	/^int _setargv(int *argc, char ***argv)$/;"	f	signature:(int *argc, char ***argv)
_stack	qdos/qdos.c	/^long _stack = 16*1024;$/;"	v
_stat	theos/_stat.c	/^int _stat(const char *_fn, struct stat *st)$/;"	f	signature:(const char *_fn, struct stat *st)
_stat_	theos/_stat.c	/^int _stat_(st, fdb)$/;"	f
_stderr	amiga/deflate.a	/^        xref    _stderr         ; pointer to FILE, which we pass to fputc$/;"	v
_stderr	human68k/deflate.s	/^        xref    _stderr         ; pointer to FILE, which we pass to fputc$/;"	v
_strstart	amiga/deflate.a	/^        MOVINT  Strst,_strstart         ; ct_tally reads this variable$/;"	v
_strstart	amiga/deflate.a	/^        MOVINT  _strstart,Limit$/;"	v
_strstart	amiga/deflate.a	/^        MOVINT  _strstart,Strst$/;"	v
_strstart	amiga/match_68.a	/^        xref    _strstart           ; unsigned int$/;"	v
_strstart	human68k/deflate.s	/^        MOVINT  Strst,_strstart         ; ct_tally reads this variable$/;"	v
_strstart	match.S	/^        mov     _strstart,%edx$/;"	v
_strstart	match.S	31;"	d	file:
_strstart	win32/lm32_lcc.asm	/^        mov     _strstart,%edx$/;"	v
_sys_rename	theos/_rename.c	16;"	d	file:
_tfree	os2/os2acl.c	170;"	d	file:
_tfree	os2/os2acl.c	188;"	d	file:
_tm2um_	theos/_stat.c	/^unsigned short _tm2um_(char protect)$/;"	f	signature:(char protect)
_tmalloc	os2/os2acl.c	169;"	d	file:
_tmalloc	os2/os2acl.c	187;"	d	file:
_tmbuf	timezone.c	/^static struct tm _tmbuf;$/;"	v	typeref:struct:tm	file:
_um2tm_	theos/_stat.c	/^char _um2tm_(unsigned short mask)$/;"	f	signature:(unsigned short mask)
_verbose	amiga/deflate.a	/^        xref    _verbose        ; signed int$/;"	v
_verbose	human68k/deflate.s	/^        xref    _verbose        ; signed int$/;"	v
_version	zip.c	/^char _version[] = VERSION;$/;"	v
_wb_parse	amiga/stat.c	/^void _wb_parse(void)  { }$/;"	f	signature:(void)
_window	amiga/deflate.a	/^        BASEPTR _window,Match_Ini$/;"	v
_window	amiga/deflate.a	/^        BASEPTR _window,Window                  ; restore cached value$/;"	v
_window	amiga/deflate.a	/^        BASEPTR _window,Window$/;"	v
_window	amiga/match_68.a	/^        lea     _window,Match_Ini$/;"	v
_window	amiga/match_68.a	/^        xref    _window             ; array of unsigned char$/;"	v
_window	human68k/deflate.s	/^        BASEPTR _window,Match_Ini$/;"	v
_window	human68k/deflate.s	/^        BASEPTR _window,Window                  ; restore cached value$/;"	v
_window	human68k/deflate.s	/^        BASEPTR _window,Window$/;"	v
_window	match.S	/^        add     $2+_window,%edi        \/* edi = offset(window+strstart+2) *\/$/;"	v
_window	match.S	/^        add     $2+_window,%esi         \/* si = match *\/$/;"	v
_window	match.S	/^        sub     $2+_window,%esi     \/* esi = cur_match + len *\/$/;"	v
_window	match.S	26;"	d	file:
_window	msdos/match.asm	/^        cmp     _window[0],0$/;"	v
_window	win32/lm32_lcc.asm	/^        add     $2+_window,%edi$/;"	v
_window	win32/lm32_lcc.asm	/^        add     $2+_window,%esi$/;"	v
_window	win32/lm32_lcc.asm	/^        sub     $2+_window,%esi$/;"	v
_window	win32/match32.asm	/^        add     edi,2+offset _window    ; edi = offset(window + strstart + 2)$/;"	v
_window	win32/match32.asm	/^        cmp     ax,word ptr _window[ebx+esi-1]   ; check match at best_len-1$/;"	v
_window	win32/match32.asm	/^        cmp     cx,word ptr _window[esi]         ; check min_match_length match$/;"	v
_window	win32/match32.asm	/^        lea     esi,_window[esi+2]      ; esi = match$/;"	v
_window	win32/match32.asm	/^        sub     esi,2+offset _window    ; esi = match - (2 + offset(window))$/;"	v
_zcalloc	amiga/deflate.a	/^;;        jsr     _zcalloc$/;"	v
_zcalloc	human68k/deflate.s	/^;;        jsr     _zcalloc$/;"	v
_zip_ver	api.h	/^typedef struct _zip_ver {$/;"	s
_zip_ver::major	api.h	/^    uch major;              \/* e.g., integer 5 *\/$/;"	m	struct:_zip_ver	access:public
_zip_ver::minor	api.h	/^    uch minor;              \/* e.g., 2 *\/$/;"	m	struct:_zip_ver	access:public
_zip_ver::not_used	api.h	/^    uch not_used;$/;"	m	struct:_zip_ver	access:public
_zip_ver::patchlevel	api.h	/^    uch patchlevel;         \/* e.g., 0 *\/$/;"	m	struct:_zip_ver	access:public
_zip_version_type	api.h	/^} _zip_version_type;$/;"	t	typeref:struct:_zip_ver
_ziperr	amiga/deflate.a	/^        xref    _ziperr         ; void ziperr(int, char *)$/;"	v
_ziperr	human68k/deflate.s	/^        xref    _ziperr         ; void ziperr(int, char *)$/;"	v
a	msdos/crc_i86.asm	/^; against redefinition of @CodeSize and @DataSize symbols, to work around a$/;"	v
a0	amiga/deflate.a	/^        IN_STR  a0,d1                   ; don't clobber d0$/;"	v
a0	amiga/deflate.a	/^        IN_STR  a0,d1                   ; preserve d0$/;"	v
a0	amiga/deflate.a	/^        move.l  _read_buf,a0    ; were compiled with MAXSEG_64K defined.$/;"	v
a0	amiga/deflate.a	/^Scan            equr    a0              ; pointer to unsigned char$/;"	v
a0	human68k/deflate.s	/^        IN_STR  a0,d1                   ; don't clobber d0$/;"	v
a0	human68k/deflate.s	/^        move.l  _read_buf,a0    ; were compiled with MAXSEG_64K defined.$/;"	v
a0	human68k/deflate.s	/^Scan            reg     a0              ; pointer to unsigned char$/;"	v
a0	qdos/match.s	/^;;Scan           equr     a0$/;"	v
a1	amiga/deflate.a	/^Match           equr    a1              ; pointer to unsigned char$/;"	v
a1	human68k/deflate.s	/^Match           reg     a1              ; pointer to unsigned char$/;"	v
a1	qdos/match.s	/^;;Match          equr     a1$/;"	v
a2	amiga/deflate.a	/^;Window equr    a2      ; as in deflate()$/;"	v
a2	amiga/deflate.a	/^Prev_Address    equr    a2              ; pointer to unsigned short$/;"	v
a2	amiga/deflate.a	/^Window  equr    a2              ; cached address of window[]$/;"	v
a2	human68k/deflate.s	/^;Window reg     a2      ; as in deflate()$/;"	v
a2	human68k/deflate.s	/^Prev_Address    reg     a2              ; pointer to unsigned short$/;"	v
a2	human68k/deflate.s	/^Window  reg     a2              ; cached address of window[]$/;"	v
a2	qdos/match.s	/^;;Prev_Address   equr     a2$/;"	v
a3	amiga/deflate.a	/^Prev    equr    a3              ; cached address of prev[]$/;"	v
a3	amiga/deflate.a	/^Scan_Ini        equr    a3              ; pointer to unsigned char$/;"	v
a3	human68k/deflate.s	/^Prev    reg     a3              ; cached address of prev[]$/;"	v
a3	human68k/deflate.s	/^Scan_Ini        reg     a3              ; pointer to unsigned char$/;"	v
a3	qdos/match.s	/^;;Scan_Ini       equr     a3$/;"	v
a5	amiga/deflate.a	/^Match_Ini       equr    a5              ; pointer to unsigned char$/;"	v
a5	amiga/deflate.a	/^PrevM   equr    a5              ; local variable prev_match, int in an A-reg$/;"	v
a5	human68k/deflate.s	/^Match_Ini       reg     a5              ; pointer to unsigned char$/;"	v
a5	human68k/deflate.s	/^PrevM   reg     a5              ; local variable prev_match, int in an A-reg$/;"	v
abbrevmatch	util.c	/^int abbrevmatch (matchstring, abbrev, case_sensitive, minmatch)$/;"	f
acc_attr	os2/os2acl.c	/^  USHORT acc_attr;$/;"	m	struct:access_info	file:	access:public
acc_cb	vms/vms.c	/^int acc_cb( int *id_arg, struct FAB *fab, struct RAB *rab)$/;"	f	signature:( int *id_arg, struct FAB *fab, struct RAB *rab)
acc_count	os2/os2acl.c	/^  USHORT acc_count;$/;"	m	struct:access_info	file:	access:public
acc_resource_name	os2/os2acl.c	/^  PSTR16 acc_resource_name;$/;"	m	struct:access_info	file:	access:public
access	qdos/qdos.c	/^int access (char *f, int mode)$/;"	f	signature:(char *f, int mode)
access_info	os2/os2acl.c	/^typedef struct access_info$/;"	s	file:
access_info::acc_attr	os2/os2acl.c	/^  USHORT acc_attr;$/;"	m	struct:access_info	file:	access:public
access_info::acc_count	os2/os2acl.c	/^  USHORT acc_count;$/;"	m	struct:access_info	file:	access:public
access_info::acc_resource_name	os2/os2acl.c	/^  PSTR16 acc_resource_name;$/;"	m	struct:access_info	file:	access:public
access_list	os2/os2acl.c	/^typedef struct access_list$/;"	s	file:
access_list::acl_access	os2/os2acl.c	/^  USHORT acl_access;$/;"	m	struct:access_list	file:	access:public
access_list::acl_pad	os2/os2acl.c	/^  char acl_pad;$/;"	m	struct:access_list	file:	access:public
access_list::acl_ugname	os2/os2acl.c	/^  char acl_ugname[UNLEN+1];$/;"	m	struct:access_list	file:	access:public
accesses	amiga/match.a	/^; word accesses, because they cause 68000-based Amigas to crash.$/;"	v
accesses	qdos/match.s	/^; word accesses, because they cause 68000-based Amigas to crash.$/;"	v
accuracy	proginfo/txtvsbin.txt	/^degree of accuracy, by employing various simple heuristics.$/;"	v
accuracy	proginfo/txtvsbin.txt	/^to conclude automatically, and with 100% accuracy, whether that file is$/;"	v
acl_access	os2/os2acl.c	/^  USHORT acl_access;$/;"	m	struct:access_list	file:	access:public
acl_bin2text	os2/os2acl.c	/^static int acl_bin2text(char *data, char *text)$/;"	f	file:	signature:(char *data, char *text)
acl_get	os2/os2acl.c	/^int acl_get(char *server, const char *resource, char *buffer)$/;"	f	signature:(char *server, const char *resource, char *buffer)
acl_init	os2/os2acl.c	/^static BOOL acl_init(void)$/;"	f	file:	signature:(void)
acl_mkpath	os2/os2acl.c	/^static void acl_mkpath(char *buffer, const char *source)$/;"	f	file:	signature:(char *buffer, const char *source)
acl_pad	os2/os2acl.c	/^  char acl_pad;$/;"	m	struct:access_list	file:	access:public
acl_set	os2/os2acl.c	/^int acl_set(char *server, const char *resource, char *buffer)$/;"	f	signature:(char *server, const char *resource, char *buffer)
acl_text2bin	os2/os2acl.c	/^static int acl_text2bin(char *data, char *text, char *path)$/;"	f	file:	signature:(char *data, char *text, char *path)
acl_ugname	os2/os2acl.c	/^  char acl_ugname[UNLEN+1];$/;"	m	struct:access_list	file:	access:public
aclbuf	aosvs/aosvs.c	/^     char           aclbuf[$MXACL];     \/* raw ACL, or link-resolution name *\/$/;"	m	struct:zextrafld	file:	access:public
aclbuf	vms/vms_pk.c	/^    uch                 aclbuf[ATR$S_READACL];$/;"	m	struct:__anon22	file:	access:public
acllen	vms/vms_pk.c	/^    long                acllen;$/;"	m	struct:__anon22	file:	access:public
acompress	tandem/tandem.h	/^  unsigned acompress   : 1;$/;"	m	struct:nsk_file_flags	access:public
act	acorn/riscos.h	/^  char *act;$/;"	m	struct:__anon8	access:public
actime	tailor.h	/^    time_t actime;              \/* new access time *\/$/;"	m	struct:ztimbuf	access:public
actime	vms/vmsmunch.h	/^    char *actime;       \/* VMS revision date, ASCII format *\/$/;"	m	struct:VMStimbuf	access:public
action	zip.c	/^local int action = ADD; \/* one of ADD, UPDATE, FRESHEN, DELETE, or ARCHIVE *\/$/;"	v
add_At_ef	atheos/atheos.c	/^local int add_At_ef( struct zlist far *z )$/;"	f	signature:( struct zlist far *z )
add_Be_ef	beos/beos.c	/^local int add_Be_ef( struct zlist far *z )$/;"	f	signature:( struct zlist far *z )
add_JLEE_ef	macos/source/extrafld.c	/^static int add_JLEE_ef( struct zlist far *z )$/;"	f	file:	signature:( struct zlist far *z )
add_MAC3_ef	macos/source/extrafld.c	/^static int add_MAC3_ef( struct zlist far *z )$/;"	f	file:	signature:( struct zlist far *z )
add_UT_ef	atheos/atheos.c	/^local int add_UT_ef( struct zlist far *z )$/;"	f	signature:( struct zlist far *z )
add_UT_ef	beos/beos.c	/^local int add_UT_ef( struct zlist far *z )$/;"	f	signature:( struct zlist far *z )
add_UT_ef	macos/source/extrafld.c	/^static int add_UT_ef(struct zlist far *z, iztimes *z_utim)$/;"	f	file:	signature:(struct zlist far *z, iztimes *z_utim)
add_Unicode_Path_cen_extra_field	zipfile.c	/^local int add_Unicode_Path_cen_extra_field(pZEntry)$/;"	f
add_Unicode_Path_local_extra_field	zipfile.c	/^local int add_Unicode_Path_local_extra_field(pZEntry)$/;"	f
add_Ux_ef	atheos/atheos.c	/^local int add_Ux_ef( struct zlist far *z )$/;"	f	signature:( struct zlist far *z )
add_Ux_ef	beos/beos.c	/^local int add_Ux_ef( struct zlist far *z )$/;"	f	signature:( struct zlist far *z )
add_central_zip64_extra_field	zipfile.c	/^local int add_central_zip64_extra_field(pZipListEntry)$/;"	f
add_dir	qdos/qdos.c	/^static int add_dir(char * dnam)$/;"	f	file:	signature:(char * dnam)
add_local_zip64_extra_field	zipfile.c	/^local int add_local_zip64_extra_field(pZEntry)$/;"	f
adding	zip30f.ann	/^  files on the file system, adding, updating, and deleting entries as needed,$/;"	v
addq	amiga/deflate.a	/^        addq    #4,sp$/;"	v
addq	amiga/deflate.a	/^        addq    #8,sp$/;"	v
adjust	globals.c	/^int adjust = 0;         \/* 1=adjust offsets for sfx'd file (keep preamble) *\/$/;"	v
adjust_zip_central_entry	zipfile.c	/^local void adjust_zip_central_entry(pZipListEntry)$/;"	f
adjust_zip_local_entry	zipfile.c	/^local int adjust_zip_local_entry(pZipListEntry)$/;"	f
aflag	zip.c	/^int aflag = __EBCDIC;   \/* Convert EBCDIC to ASCII or stay EBCDIC ? *\/$/;"	v
after	globals.c	/^ulg after = 0;          \/* 0=ignore, else exclude files newer than this time *\/$/;"	v
ah	msdos/crc_i86.asm	/^        mov     ah,dl$/;"	v
ah	win32/crc_i386.asm	/^                movzx   ebx,ah                 ; tmp = (c>>8) & 0xFF$/;"	v
ah	win32/gvmat64.asm	/^    db     0dh,0ah,"asm686 with masm, optimised assembly code from Brian Raiter, written 1998, converted to amd 64 by Gilles Vollant 2005",0dh,0ah,0$/;"	v
ahead	win32/gvmat64.asm	/^;;; both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and edx is$/;"	v
ai	os2/os2acl.c	/^static ACCINFO *ai;$/;"	v	file:
al	msdos/crc_i86.asm	/^        mov     al,ah$/;"	v
al	msdos/crc_i86.asm	/^        xor     al,BYTE PTR [di]$/;"	v
al	msdos/crc_i86.asm	/^        xor     al,BYTE PTR es:[di]$/;"	v
al	win32/crc_i386.asm	/^                mov     bl,al                ; tmp = c & 0xFF$/;"	v
al	win32/crc_i386.asm	/^                movzx   ebx,al                 ; tmp = (c>>16) & 0xFF$/;"	v
al	win32/crc_i386.asm	/^                movzx   ebx,al                 ; tmp = c & 0xFF$/;"	v
al	win32/crc_i386.asm	/^                xor     al, byte ptr [esi]     ; c ^= *buf$/;"	v
al	win32/crc_lcc.asm	/^	movzbl	%al,%ebx$/;"	v
al	win32/gvmat64.asm	/^LenLower:   sub al, 1$/;"	v
align	os2/match32.asm	/^        align   4                       ; align destination of branch$/;"	v
align	win32/match32.asm	/^        align   4                       ; align destination of branch$/;"	v
alist_items	tandem/tanzip.c	68;"	d	file:
alloc	msdos/match.asm	/^;   DYN_ALLOC  : select support for malloc'ed working space$/;"	v
alloc	os2/os2zip.c	617;"	d	file:
alloc	os2/os2zip.c	620;"	d	file:
allocarg	theos/_setargv.c	/^static int allocarg(int n, int l, char ***nargv, char *s)$/;"	f	file:	signature:(int n, int l, char ***nargv, char *s)
allow_empty_archive	globals.c	/^int allow_empty_archive = 0;  \/* if no files, create empty archive anyway 12\/28\/05 *\/$/;"	v
allow_fifo	globals.c	/^int allow_fifo = 0;           \/* 1=allow reading Unix FIFOs, waiting if pipe open *\/$/;"	v
allow_regex	globals.c	/^int allow_regex = 0;         \/* 1 = allow [list] matching *\/$/;"	v
already	INSTALL	/^     you have unpacked it already, or you cheated and got a tar.Z file...$/;"	v
always	amiga/match_68.a	/^;   CPU020     if defined, use 68020 instructions always$/;"	v
amiga_sfx_offset	zipfile.c	/^   ulg amiga_sfx_offset;        \/* place where size field needs updating *\/$/;"	v
an	amiga/deflate.a	/^        FAIL    Write an '020-detector for your system here!$/;"	v
an	human68k/deflate.s	/^        FAIL    Write an '020-detector for your system here!$/;"	v
and	bzip2/install.txt	/^  include and library paths and, if found, link in the system bzip2$/;"	v
and	msdos/match.asm	/^; Set match_start to the longest match starting at the given string and$/;"	v
and	os2/match32.asm	/^; Set match_start to the longest match starting at the given string and$/;"	v
and	proginfo/fileinfo.cms	/^  A-Z, a-z, 0-9, and +, -, $, #, @, :, and _.  You can separate it$/;"	v
and	win32/match32.asm	/^; Set match_start to the longest match starting at the given string and$/;"	v
and	zip.txt	/^              the  archive  and,  depending  on  the  damage,  it may find the$/;"	v
app	win32/gvmat64.asm	/^; Your can freely use gvmat64 in any free or commercial app$/;"	v
append_int64_to_mem	zipfile.c	/^local void append_int64_to_mem(l64Value, pPtr, offset, blocksize)$/;"	f
append_string_to_mem	zipfile.c	/^local void append_string_to_mem(strValue, strLength, pPtr, offset, blocksize)$/;"	f
append_ulong_to_mem	zipfile.c	/^local void append_ulong_to_mem(uValue, pPtr, offset, blocksize)$/;"	f
approaches	bzip2/install.txt	/^  For Windows there seems to be two approaches, either use bzip2$/;"	v
archive	INSTALL	/^     the archive, making the creating of the zipsrc directory optional.$/;"	v
archive	man/zip.1	/^In cmd, {} is replaced by the name of the temporary archive, otherwise the name$/;"	v
archive	tags	/^archive	man\/zip.1	\/^In cmd, {} is replaced by the name of the temporary archive, otherwise the name$\/;"	v$/;"	v
archive	unix/Packaging/README	/^files are resident in the archive, and it is easily distributed.$/;"	v
archive	zip.txt	/^              Grow (append to) the specified zip archive, instead of  creating$/;"	v
archive	zip30f.ann	/^  creating an updated archive that should be the same as a new archive, but$/;"	v
archived	zip.txt	/^              being archived, and -DF to create a differential archive.$/;"	v
archives	README	/^bzip2 compressed entries in archives, so test your unzip first before using$/;"	v
archives	README	/^spanned archives, but Zip 3.0 supports split archives.  A split archive is an$/;"	v
are	msdos/match.asm	/^; Per default, test code is included to check if the above requirements are$/;"	v
are	win32/gvmat64.asm	/^;;; are hoping to match it up with. In actuality, esi and edi are$/;"	v
arg1	crc_i386.S	/^                movl    arg1, %eax           \/* 1st arg: ulg crc             *\/$/;"	v
arg1	crc_i386.S	96;"	d	file:
arg2	crc_i386.S	97;"	d	file:
arg3	crc_i386.S	/^                movl    arg3, %ecx           \/* 3rd arg: extent len          *\/$/;"	v
arg3	crc_i386.S	98;"	d	file:
argCee	api.c	/^unsigned int argCee;$/;"	v
argStr	macos/source/helpers.c	/^static char         argStr[1024];$/;"	v	file:
argVee	api.c	/^char **argVee;$/;"	v
argc	api.h	/^  int  argc;            \/* Count of files to zip *\/$/;"	m	struct:__anon31	access:public
argc	windll/windll.txt	/^int  argc;              = Count of files to zip$/;"	m	struct:__anon19	file:	access:public
argv	macos/source/helpers.c	/^static char         *argv[MAX_ARGS + 1];$/;"	v	file:
array	win32/crc_i386.asm	/^;   ebx  : index into crc_table array$/;"	v
array	win32/crc_i386.asm	/^;   edi  : pointer to base of crc_table array$/;"	v
arrays	amiga/deflate.a	/^; void lm_init(int pack_level, unsigned short *flags) allocates dynamic arrays$/;"	v
arrays	human68k/deflate.s	/^; void lm_init(int pack_level, unsigned short *flags) allocates dynamic arrays$/;"	v
as	acorn/ReadMe	/^archive as "foo\/c", eventually appearing in the archive as "foo.c", allowing$/;"	v
as	acorn/ReadMe	/^decompress the files, as a file called "file.ext" will be extracted as$/;"	v
ascii	ebcdic.h	/^ZCONST uch ascii[] = {$/;"	v
asctim	vms/vmsmunch.c	/^static void asctim(        \/* convert 64-bit binval to string, put in time *\/$/;"	f	file:	signature:( char *time, long int binval[2] )
ask_for_split_read_path	fileio.c	/^int ask_for_split_read_path(current_disk)$/;"	f
ask_for_split_write_path	fileio.c	/^int ask_for_split_write_path(current_disk)$/;"	f
assembler	msdos/crc_i86.asm	/^; you should define the OPTIMIZE_286_88 macro switch on the assembler's$/;"	v
at_signature	zipfile.c	/^local int at_signature(f, signature)$/;"	f
atcom	os2/match32.asm	/^; and for Watcom's 32-bit C\/C++ compiler. Both pass the first (and only)$/;"	v
atime	zip.h	/^   time_t atime;                \/* new access time *\/$/;"	m	struct:iztimes	access:public
ats	timezone.h	/^    time_t          ats[TZ_MAX_TIMES];$/;"	m	struct:state	access:public
att	zip.h	/^  ush att, lflg;                \/* offset of lflg must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
att6300	INSTALL	/^     att6300, coherent, cray_v3, minix, sco_x286, xenix, zilog.$/;"	v
attr	acorn/riscos.h	/^  int           attr;$/;"	m	struct:__anon10	access:public
attrib	acorn/riscos.h	/^  int attrib;$/;"	m	struct:__anon9	access:public
attributes	README	/^extended file attributes; conversion from Unix to MSDOS text file format; and,$/;"	v
attributes	os2/os2zip.c	/^static int attributes = _A_DIR | _A_HIDDEN | _A_SYSTEM;$/;"	v	file:
attrsize	macos/source/macglob.h	/^    unsigned long   attrsize;$/;"	m	struct:__anon17	access:public
atx	zip.h	/^  ulg atx;$/;"	m	struct:zlist	access:public
audited	tandem/tandem.h	/^  unsigned audited     : 1;$/;"	m	struct:nsk_file_flags	access:public
automatically	proginfo/txtvsbin.txt	/^to conclude automatically, and with 100% accuracy, whether that file is$/;"	v
available_match	amiga/deflate.a	/^Avail   equr    d2              ; local variable available_match, bool$/;"	v
available_match	human68k/deflate.s	/^Avail   reg     d2              ; local variable available_match, bool$/;"	v
ax	msdos/crc_i86.asm	/^        mov     ax,SEG DGROUP$/;"	v
ax	msdos/crc_i86.asm	/^        mov     ax,WORD PTR [bp+4+LCOD_OFS]     ;crc$/;"	v
ax	msdos/crc_i86.asm	/^        mov     ax,WORD PTR [bp+8+LCOD_OFS]     ; buf$/;"	v
ax	msdos/crc_i86.asm	/^        mov     si,ax                           ;crc_table$/;"	v
ax	msdos/crc_i86.asm	/^        or      ax,WORD PTR [bp+10+LCOD_OFS]    ;     == NULL ?$/;"	v
ax	msdos/crc_i86.asm	/^        sub     ax,ax                           ; crc = 0$/;"	v
ax	msdos/crc_i86.asm	/^        xor     ax,WORD PTR [bx][si]$/;"	v
ax	msdos/crc_i86.asm	/^        xor     ax,WORD PTR [di]$/;"	v
ax	msdos/crc_i86.asm	/^        xor     ax,WORD PTR es:[di]$/;"	v
ax	msdos/match.asm	/^        cmp     ax,bx                   ; SS == DS?$/;"	v
ax	msdos/match.asm	/^        mov     ax,[bx+di-3]            ; ax = scan[best_len-1..best_len]$/;"	v
ax	msdos/match.asm	/^        mov     ax,_nice_match$/;"	v
ax	msdos/match.asm	/^        mov     ax,_prev[2]             ; segment value$/;"	v
ax	msdos/match.asm	/^        mov     ax,di                   ; ax = scan+2$/;"	v
ax	msdos/match.asm	/^        mov     ax,ds$/;"	v
ax	msdos/match.asm	/^        mov     ax,es:[bx+di-3]         ; ax = scan[best_len-1..best_len]$/;"	v
ax	msdos/match.asm	/^        mov     cs:prev_ptr,ax          ; ugly write to code, crash on OS\/2$/;"	v
ax	msdos/match.asm	/^        mov     nice,ax                 ; ugly write to code, crash on OS\/2$/;"	v
ax	msdos/match.asm	/^        xchg    ax,di                   ; di = scan+2, ax = end of scan$/;"	v
ax	os2/match32.asm	/^        mov     ax,[ebx+edi-3]          ; ax = scan[best_len-1..best_len]$/;"	v
ax	win32/gvmat64.asm	/^        or ax,ax$/;"	v
ax	win32/match32.asm	/^        mov     ax,[ebx+edi-3]          ; ax = scan[best_len-1..best_len]$/;"	v
bProcessDefer	win32/nt.h	/^    BOOL bProcessDefer;         \/* process deferred entry yet? *\/$/;"	m	struct:__anon6	access:public
bRemote	win32/nt.h	/^    BOOL bRemote;               \/* is volume remote? *\/$/;"	m	struct:__anon6	access:public
bUsePrivileges	win32/nt.h	/^    BOOL bUsePrivileges;        \/* use privilege overrides? *\/$/;"	m	struct:__anon6	access:public
bValid	win32/nt.h	/^    BOOL bValid;                \/* are our contents valid? *\/$/;"	m	struct:__anon6	access:public
bZipInitialized	win32/nt.c	/^BOOL bZipInitialized = FALSE;  \/* module level stuff initialized? *\/$/;"	v
back	windll/VBz64/readVB64.txt	/^the line back, and save the file.  This will force WordPad to change the$/;"	v
back	windll/Vb/readmeVB.txt	/^the line back, and save the file.  This will force WordPad to format$/;"	v
backups	zip30.ann	/^  difference mode for supporting incremental backups, a file sync$/;"	v
bad_bytes_so_far	globals.c	/^uzoff_t bad_bytes_so_far = 0; \/* bad bytes skipped so far *\/$/;"	v
bad_files_so_far	globals.c	/^ulg bad_files_so_far = 0;     \/* bad files skipped so far *\/$/;"	v
base_dist	trees.c	/^local int near base_dist[D_CODES];$/;"	v
base_length	trees.c	/^local int near base_length[LENGTH_CODES];$/;"	v
based	human68k/deflate.s	/^; is based in part on match.a by Carsten Steger, which in turn is partly based$/;"	v
bd	vms/vms.h	/^    ush tag_bd; ush len_bd;     byte bd[ATR$S_BAKDATE];$/;"	m	struct:__anon23	access:public
bd	vms/vms.h	/^    ush tag_bd; ush len_bd;     byte bd[ATR$S_BAKDATE];$/;"	m	struct:__anon24	access:public
be	WHATSNEW	/^  to be, to read then strip old extra fields when reading entries from an$/;"	v
because	amiga/crc_68.a	/^; On the Amiga, type extent is always unsigned long, not unsigned int, because$/;"	v
because	human68k/crc_68.s	/^; On the Amiga, type extent is always unsigned long, not unsigned int, because$/;"	v
because	msdos/crc_i86.asm	/^;  C calling convention, model-dependent handling is not needed, because$/;"	v
before	globals.c	/^ulg before = 0;         \/* 0=ignore, else exclude files before this time *\/$/;"	v
before	vms/NOTES.TXT	/^would certainly be different from the way things have been done before,$/;"	v
before	win32/gvmat64.asm	/^;;; strings match each other, and they can be safely passed over before$/;"	v
being	win32/gvmat64.asm	/^;;; Determine how many bytes the scan ptr is off from being$/;"	v
best_len	win32/gvmat64.asm	/^;;; int best_len = s->prev_length;$/;"	v
bestlen	win32/gvmat64.asm	/^;;; esi = windowbestlen - i.e., (window + bestlen)$/;"	v
betalevel	api.h	/^    char betalevel[10];     \/* e.g., "g BETA" or "" *\/$/;"	m	struct:_ZpVer	access:public
betalevel	windll/windll.txt	/^    char *betalevel;        \/* e.g., "g BETA" or "" *\/$/;"	m	struct:_ZpVer	file:	access:public
better	README	/^favorite port is broke, send us the details or, better, send bug fixes.  It's$/;"	v
bfcopy	fileio.c	/^int bfcopy(n)$/;"	f
bflag	zip.c	/^int bflag = 0;          \/* Use text mode as default *\/$/;"	v
bfwrite	fileio.c	/^size_t bfwrite(buffer, size, count, mode)$/;"	f
bh	msdos/crc_i86.asm	/^        sub     bh,bh$/;"	v
bi_buf	acorn/sendbits.s	/^                &       bi_buf$/;"	v
bi_buf	trees.c	/^local unsigned bi_buf;$/;"	v
bi_buf	trees.c	/^unsigned bi_buf;$/;"	v
bi_init	trees.c	/^void bi_init (tgt_buf, tgt_size, flsh_allowed)$/;"	f
bi_reverse	trees.c	/^local unsigned bi_reverse(code, len)$/;"	f
bi_valid	trees.c	/^int bi_valid;$/;"	v
bi_valid	trees.c	/^local int bi_valid;$/;"	v
bi_windup	trees.c	/^local void bi_windup()$/;"	f
bid	vms/vms.h	/^    ulg bid;$/;"	m	struct:IZ_block	access:public
binary	proginfo/txtvsbin.txt	/^data.  "Polluted" plain text may, in fact, be regarded as binary, on$/;"	v
bintim	vms/vmsmunch.c	/^static void bintim(        \/* convert time string to 64 bits, put in binval *\/$/;"	f	file:	signature:( char *time, long int binval[2] )
bit	WHATSNEW	/^  General Purpose Bit Flag, bit 11, UTF-8 flag, that indicates UTF-8$/;"	v
bits	amiga/deflate.a	/^;   INT16      define this if ints are 16 bits; otherwise 32 bit ints assumed.$/;"	v
bits	human68k/deflate.s	/^;   INT16      define this if ints are 16 bits; otherwise 32 bit ints assumed.$/;"	v
bits_sent	trees.c	/^local uzoff_t bits_sent;   \/* bit length of the compressed data *\/$/;"	v
bl	msdos/crc_i86.asm	/^        mov     bl,al$/;"	v
bl	win32/crc_i386.asm	/^                mov     bl,al                ; tmp = c & 0xFF$/;"	v
bl_count	trees.c	/^local ush near bl_count[MAX_BITS+1];$/;"	v
bl_desc	trees.c	/^local tree_desc near bl_desc =$/;"	v
bl_order	trees.c	/^local uch near bl_order[BL_CODES]$/;"	v
bl_tree	trees.c	/^local ct_data near bl_tree[2*BL_CODES+1];$/;"	v
block	proginfo/fileinfo.cms	/^  * A block, which is the unit of data transmitted to and from a$/;"	v
block	tandem/tandem.h	/^  unsigned short block;     \/* 16 *\/  \/* Allow of block > 4096 one day ! *\/$/;"	m	struct:nsk_file_attrs_def	access:public
block_start	deflate.c	/^long block_start;$/;"	v
blocksize	zipfile.c	/^  extent *blocksize;      \/* current size of block *\/$/;"	v
blocksize	zipfile.c	/^  extent *blocksize;$/;"	v
body	vms/vms.h	/^    uch body[1];                \/* The actual size is unknown *\/$/;"	m	struct:IZ_block	access:public
boundary	proginfo/ebcdic.msg	/^Content-Type: multipart\/mixed; boundary="----------EB1581C42AB86662"$/;"	v
bp	msdos/crc_i86.asm	/^        mov     bp,sp$/;"	v
bp	msdos/match.asm	/^        dec     bp                      ; --chain_length$/;"	v
bp	msdos/match.asm	/^        mov     bp,_max_chain_length    ; chain_length = max_chain_length$/;"	v
bp	msdos/match.asm	/^        mov     bp,sp$/;"	v
bp	msdos/match.asm	/^        shr     bp,1                    ; chain_length >>= 2$/;"	v
bp	msdos/match.asm	/^        shr     bp,1$/;"	v
bp	msdos/match.asm	/^        shr     bp,2                    ; chain_length >>= 2$/;"	v
bp	msdos/match.asm	/^;       chain_length equ bp$/;"	v
breakkey	novell/Netware.c	/^static      breakkey = FALSE;$/;"	v	file:
broken	tandem/tandem.h	/^  unsigned broken      : 1;$/;"	m	struct:nsk_file_flags	access:public
bstrm	zipup.c	/^    local bz_stream bstrm;      \/* zlib's data interface structure *\/$/;"	v
buf	acorn/riscos.h	/^  void *buf;$/;"	m	struct:__anon8	access:public
buf	qdos/crc68.s	/^.globl  _crc32          ; (ulg val, uch *buf, extent bufsize)$/;"	v
buf	vms/vms.c	/^    void *buf;$/;"	m	struct:__anon25	file:	access:public
buf	win32/crc_i386.asm	/^                add     esi, 4*dwPtrIncr       ; ((ulg *)buf) += dwPtrIncr$/;"	v
buf_len	vms/vms.c	/^    short buf_len;$/;"	m	struct:__anon25	file:	access:public
buffer	macos/source/recurse.c	/^static char *buffer;$/;"	v	file:
buffer	proginfo/fileinfo.cms	/^     buffer, and the file position is set to the start fo the next$/;"	v
buffered	tandem/tandem.h	/^  unsigned buffered    : 1;$/;"	m	struct:nsk_file_flags	access:public
build_bl_tree	trees.c	/^local int build_bl_tree()$/;"	f
build_tree	trees.c	/^local void build_tree(desc)$/;"	f
bx	msdos/crc_i86.asm	/^        shl     bx,1$/;"	v
bx	msdos/crc_i86.asm	/^        shl     bx,2$/;"	v
bx	msdos/match.asm	/^        cmp     ax,bx                   ; SS == DS?$/;"	v
bx	msdos/match.asm	/^        mov     bx,ss$/;"	v
bx	msdos/match.asm	/^;       best_len     equ bx$/;"	v
bx	win32/gvmat64.asm	/^        cmp bx,word ptr [rsi + r8 - 1]$/;"	v
by	amiga/deflate.a	/^;               tells it that registers d0\/a0\/d1\/a1 are not preserved by$/;"	v
by	human68k/deflate.s	/^;               tells it that registers d0\/a0\/d1\/a1 are not preserved by$/;"	v
by	msdos/crc_i86.asm	/^; Likewise, "jcxz" was replaced by "jz", because the latter is faster on$/;"	v
byte	vms/vms.h	/^typedef unsigned char byte;$/;"	t
bytes	amiga/deflate.a	/^        moveq   #0,Scan_Start           ; clear 2nd & 4th bytes, use 1st & 3rd$/;"	v
bytes	amiga/match_68.a	/^        moveq   #0,Scan_Start       ; clear 2nd and 4th bytes, use 1st & 3rd$/;"	v
bytes	human68k/deflate.s	/^        moveq   #0,Scan_Start           ; clear 2nd & 4th bytes, use 1st & 3rd$/;"	v
bytes	proginfo/fileinfo.cms	/^     in bytes, of the record read.  If you pass a size argument equal$/;"	v
bytes	win32/crc_i386.asm	/^;          (requires upper three bytes = 0 when __686 is undefined)$/;"	v
bytes_prev_splits	globals.c	/^uzoff_t bytes_prev_splits = 0;    \/* total bytes written to all splits before this *\/$/;"	v
bytes_so_far	globals.c	/^uzoff_t bytes_so_far = 0;     \/* bytes processed so far (from initial scan) *\/$/;"	v
bytes_this_entry	globals.c	/^uzoff_t bytes_this_entry = 0;     \/* bytes written for this entry across all splits *\/$/;"	v
bytes_this_split	globals.c	/^uzoff_t bytes_this_split = 0;     \/* bytes written to the current split *\/$/;"	v
bytes_total	globals.c	/^uzoff_t bytes_total = 0;      \/* total bytes to process (from initial scan) *\/$/;"	v
bz_compress_free	zipup.c	/^void bz_compress_free()$/;"	f
bz_compress_init	zipup.c	/^local int bz_compress_init(pack_level)$/;"	f
bz_internal_error	zbz2err.c	/^void bz_internal_error(errcode)$/;"	f
bzfilecompress	zipup.c	/^local zoff_t bzfilecompress(z_entry, cmpr_method)$/;"	f
bzipInit	zipup.c	/^    local int bzipInit;         \/* flag: bzip2lib is initialized *\/$/;"	v
c	CHANGES	/^ 1. Fix bug in QDOS patch that broke zipsplit.c (Onno, Paul)$/;"	f
c	crypt.c	/^    int c;                      \/* byte of plain text *\/$/;"	v
c	zipfile.c	/^  uzoff_t c;                \/* offset of central directory *\/$/;"	v
cPB	macos/source/recurse.c	/^    CInfoPBRec              cPB;            \/* the parameter block used for$/;"	m	struct:RecurseGlobals	file:	access:public
call	win32/gvmat64.asm	/^; All registers must be preserved across the call, except for$/;"	v
called	acorn/ReadMe	/^called 'newfile', 'NewFile' and 'NEWFILE'. Please be careful.$/;"	v
can	win32/gvmat64.asm	/^;;; chainlen is decremented once beforehand so that the function can$/;"	v
capabilities	zip30.ann	/^  capabilities, but modifying existing programs to use the new dll$/;"	v
case_map	tailor.h	211;"	d
case_map	tailor.h	214;"	d
catalloc	zipnote.c	/^local int catalloc(a, s)$/;"	f
cbList	os2/os2zip.c	/^  ULONG cbList;               \/* length of value + 22 *\/$/;"	m	struct:__anon11	file:	access:public
cbList	os2/os2zip.c	/^  ULONG cbList;$/;"	m	struct:__anon12	file:	access:public
cbList	os2/os2zip.c	/^  ULONG cbList;$/;"	m	struct:__anon15	file:	access:public
cbName	os2/os2zip.c	/^  BYTE cbName;                \/* length of ".LONGNAME" = 9 *\/$/;"	m	struct:__anon11	file:	access:public
cbName	os2/os2zip.c	/^  BYTE cbName;$/;"	m	struct:__anon12	file:	access:public
cbName	os2/os2zip.c	/^  BYTE cbName;$/;"	m	struct:__anon14	file:	access:public
cbValue	os2/os2zip.c	/^  USHORT cbValue;             \/* length of value + 4 *\/$/;"	m	struct:__anon11	file:	access:public
cbValue	os2/os2zip.c	/^  USHORT cbValue;$/;"	m	struct:__anon14	file:	access:public
cchFilesMax	windll/windll.h	46;"	d
cd	vms/vms.h	/^    ush tag_cd; ush len_cd;     byte cd[ATR$S_CREDATE];$/;"	m	struct:__anon23	access:public
cd	vms/vms.h	/^    ush tag_cd; ush len_cd;     byte cd[ATR$S_CREDATE];$/;"	m	struct:__anon24	access:public
cd_entries_this_disk	globals.c	/^uzoff_t cd_entries_this_disk = 0; \/* cd entries this disk *\/$/;"	v
cd_start_disk	globals.c	/^ulg     cd_start_disk = (ulg)-1;  \/* central directory start disk *\/$/;"	v
cd_start_offset	globals.c	/^uzoff_t cd_start_offset = 0;      \/* offset of start of cd on cd start disk *\/$/;"	v
cenbeg	globals.c	/^uzoff_t cenbeg;               \/* Starting offset of central dir *\/$/;"	v
cext	zip.h	/^  ush nam, ext, cext, com;      \/* offset of ext must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
cextra	zip.h	/^  char *cextra;                 \/* Extra in central (set only if cext != 0) *\/$/;"	m	struct:zlist	access:public
chain_length	win32/gvmat64.asm	/^;;; unsigned chain_length = s->max_chain_length;$/;"	v
chan	vms/vms_pk.c	/^    ush                 chan;$/;"	m	struct:__anon22	file:	access:public
chan_pad	vms/vms_pk.c	/^    ush                 chan_pad;       \/* alignment member *\/$/;"	m	struct:__anon22	file:	access:public
change	win32/gvmat64.asm	/^;   (if you use a version of zLib before 1.0.4 or after 1.2.2.2, change$/;"	v
changelabel	tandem/tandem.c	/^_c _callable int changelabel(fnum, modtime, actime)$/;"	f
changes	vms/NOTES.TXT	/^will work regardless of such case changes, but there may be some$/;"	v
char_prop	vms/vmszip.c	/^unsigned char char_prop[ 256] = {$/;"	v
characters	proginfo/fileinfo.cms	/^  original record, the new data fills the first n characters, where$/;"	v
characters	proginfo/txtvsbin.txt	/^contain both control characters, and codes from the upper range.  On the$/;"	v
charcnt	timezone.h	/^    int             charcnt;$/;"	m	struct:state	access:public
chars	timezone.h	/^    char            chars[TZ_MAX_CHARS];$/;"	m	struct:state	access:public
check	proginfo/3rdparty.bug	/^   the -ex option; when tested, the files fail the CRC check, and comparison$/;"	v
check_cli	vms/cmdline.c	/^check_cli (struct dsc$descriptor_s *qual)$/;"	f	file:	signature:(struct dsc$descriptor_s *qual)
check_dup	fileio.c	/^int check_dup()$/;"	f
check_for_windows	msdos/msdos.c	/^void check_for_windows(char *app)$/;"	f	signature:(char *app)
check_match	deflate.c	/^local void check_match(start, match, length)$/;"	f
check_match	deflate.c	571;"	d	file:
check_unzip_version	zip.c	/^local int check_unzip_version(unzippath)$/;"	f
check_zipfile	zip.c	/^local void check_zipfile(zipname, zippath)$/;"	f
checkend	amiga/deflate.a	/^checkend:                               ; assert eofile is false$/;"	v
checkext	acorn/riscos.c	/^int checkext(char *suff)$/;"	f	signature:(char *suff)
chmod	acorn/riscos.c	/^int chmod(char *file, int mode)$/;"	f	signature:(char *file, int mode)
chmod	amiga/stat.c	/^int chmod(const char *filename, int bits)       \/* bits are as for st_mode *\/$/;"	f	signature:(const char *filename, int bits)
chmod	macos/source/unixlike.c	/^int chmod(char *path, int mode)$/;"	f	signature:(char *path, int mode)
chmod	tandem/tandem.c	/^int chmod(file, unix_sec)$/;"	f
chmod	theos/stat.h	97;"	d
chown	tandem/tandem.c	/^int chown(file, uid, gid)$/;"	f
chowner	qdos/qdos.c	/^static jobid_t chowner(chanid_t chan)$/;"	f	file:	signature:(chanid_t chan)
cl	msdos/match.asm	/^        mov     cl,[di-2]               ; mismatch on first or second byte?$/;"	v
cl	os2/match32.asm	/^        mov     cl,[edi-2]              ; mismatch on first or second byte?$/;"	v
cl	win32/match32.asm	/^        mov     cl,[edi-2]              ; mismatch on first or second byte?$/;"	v
clear_archive_bits	globals.c	/^int clear_archive_bits = 0;   \/* clear DOS archive bit of included files *\/$/;"	v
clear_tm	macos/source/mactime.c	/^static void clear_tm(struct tm * tm)$/;"	f	file:	signature:(struct tm * tm)
clearonpurge	tandem/tandem.h	/^  unsigned clearonpurge: 1;$/;"	m	struct:nsk_file_flags	access:public
cli$dcl_parse	vms/cmdline.c	288;"	d	file:
cli$get_value	vms/cmdline.c	294;"	d	file:
cli$present	vms/cmdline.c	291;"	d	file:
clock	msdos/crc_i86.asm	/^; on Pentium MMX). For the 286, the penalty of "dec cx; jnz" is one clock$/;"	v
close_leftover_open_dirs	amiga/stat.c	/^void close_leftover_open_dirs(void)$/;"	f	signature:(void)
close_split	fileio.c	/^int close_split(disk_number, tempfile, temp_name)$/;"	f
closedir	acorn/riscos.c	/^void closedir(DIR *d)$/;"	f	signature:(DIR *d)
closedir	amiga/stat.c	/^void closedir(DIR *dd)$/;"	f	signature:(DIR *dd)
closedir	beos/beos.c	88;"	d	file:
closedir	cmsmvs/mvs.c	/^int closedir(DIR *dirp)$/;"	f	signature:(DIR *dirp)
closedir	os2/os2zip.c	/^void closedir(DIR * dirp)$/;"	f	signature:(DIR * dirp)
closedir	tandem/tandem.c	/^int closedir(DIR *dirp)$/;"	f	signature:(DIR *dirp)
closedir	tops20/tops20.c	/^local void closedir(d)$/;"	f
closedir	unix/unix.c	92;"	d	file:
cma$tis_errno_get_addr	zip.h	360;"	d
cmpr_bytelen	trees.c	/^local uzoff_t cmpr_bytelen;     \/* total byte length of compressed file *\/$/;"	v
cmpr_len_bits	trees.c	/^local ulg cmpr_len_bits;        \/* number of bits past 'cmpr_bytelen' *\/$/;"	v
code	WHATSNEW	/^  otherwise use base code, and compiling normally to enable Zip64 code$/;"	v
code	msdos/match.asm	/^        mov     cs:prev_ptr,ax          ; ugly write to code, crash on OS\/2$/;"	v
code	msdos/match.asm	/^        mov     nice,ax                 ; ugly write to code, crash on OS\/2$/;"	v
code	msdos/match.asm	/^; To simplify the code, the option -DDYN_ALLOC is supported for OS\/2$/;"	v
code	proginfo/txtvsbin.txt	/^documents, compiled object code, etcetera.  The results confirm the$/;"	v
code	proginfo/txtvsbin.txt	/^including plain old texts, system logs, source code, formatted office$/;"	v
code	trees.c	/^        ush  code;       \/* bit string *\/$/;"	m	union:ct_data::__anon28	file:	access:public
code	win32/gvmat64.asm	/^;  and by taking inspiration on asm686 with masm, optimised assembly code $/;"	v
coherent	INSTALL	/^     att6300, coherent, cray_v3, minix, sco_x286, xenix, zilog.$/;"	v
com	zip.h	/^  ush nam, ext, cext, com;      \/* offset of ext must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
comadd	zip.c	/^local int comadd = 0;   \/* 1=add comments for new files *\/$/;"	v
comment	api.h	/^  DLLCOMMENT *comment;$/;"	m	struct:__anon32	access:public
comment	windll/windll.c	/^void comment(unsigned int comlen)$/;"	f	signature:(unsigned int comlen)
comment	windll/windll.txt	/^DLLCOMMENT *comment;$/;"	m	struct:__anon20	file:	access:public
comment	zip.h	/^  char *comment;                \/* Comment (set only if com != 0) *\/$/;"	m	struct:zlist	access:public
common	INSTALL	/^     SYS$LOGIN:LOGIN.COM procedure, or to a common, site-specific$/;"	v
compatibility	zip.txt	/^       path  for  backward  compatibility,  the UTF-8 translation of the path.$/;"	v
compiled	windll/windll.txt	/^The code set out below is not intended to be compiled, but is only intended as$/;"	v
compiler	msdos/match.asm	/^; The security tests should remain enabled, when a new C compiler$/;"	v
compilers	vms/install_vms.txt	/^     compilers, DEC\/Compaq\/HP C, VAX C, or GNU C.  If DEC\/Compaq\/HP C is$/;"	v
compliance	acorn/ReadMe	/^When adding files to a zipfile; to maintain FileCore compliance, all$/;"	v
compress_block	trees.c	/^local void compress_block(ltree, dtree)$/;"	f
compressed	zip.txt	/^              copied instead of compressed, updating an existing archive  with$/;"	v
compression	amiga/deflate.a	/^                dc.w    32,258,258,4096 ; level 9: maximum compression, slow$/;"	v
compression	human68k/deflate.s	/^                dc.w    32,258,258,4096 ; level 9: maximum compression, slow$/;"	v
computer	amiga/match_68.a	/^; longest_match().  It is written for any 680x0 based computer, but at this$/;"	v
config	deflate.c	/^typedef struct config {$/;"	s	file:
config	deflate.c	/^} config;$/;"	t	typeref:struct:config	file:
config::good_length	deflate.c	/^   ush good_length; \/* reduce lazy search above this match length *\/$/;"	m	struct:config	file:	access:public
config::max_chain	deflate.c	/^   ush max_chain;$/;"	m	struct:config	file:	access:public
config::max_lazy	deflate.c	/^   ush max_lazy;    \/* do not perform lazy search above this match length *\/$/;"	m	struct:config	file:	access:public
config::nice_length	deflate.c	/^   ush nice_length; \/* quit search above this match length *\/$/;"	m	struct:config	file:	access:public
configuration_table	deflate.c	/^local config configuration_table[10] = {$/;"	v
const	tailor.h	190;"	d
contents	zip.txt	/^       temporary file with the new contents, and only replace the old one when$/;"	v
contributions	README	/^thoughts and contributions, etc., check out the new discussion forum.  This is$/;"	v
conv_to_rule	win32/win32.c	/^static void conv_to_rule(LPSYSTEMTIME lpw32tm, struct rule * ZCONST ptrule)$/;"	f	file:	signature:(LPSYSTEMTIME lpw32tm, struct rule * ZCONST ptrule)
convenient	vms/NOTES.TXT	/^support.  Currently, UnZip is less convenient, but searching the UnZip$/;"	v
convention	msdos/crc_i86.asm	/^;  C calling convention, model-dependent handling is not needed, because$/;"	v
conventions	msdos/match.asm	/^; The code has been prepared for two different C compiler calling conventions$/;"	v
copied	WHATSNEW	/^  since existing entries are copied, may be much faster.$/;"	v
copy_args	fileio.c	/^char **copy_args(args, max_args)$/;"	f
copy_block	trees.c	/^local void copy_block(block, len, header)$/;"	f
copy_nondup_extra_fields	zipfile.c	/^char *copy_nondup_extra_fields(oldExtra, oldExtraLen, newExtra, newExtraLen, newLen)$/;"	f
copy_only	globals.c	/^int copy_only = 0;            \/* 1=copying archive entries only *\/$/;"	v
copy_sig	zipfile.c	/^char *copy_sig(copyto, copyfrom)$/;"	f
copying	WHATSNEW	/^  when deleting, copying, or freshening entries (deleting and copying$/;"	v
copyright	revision.h	/^ZCONST char *copyright[] = {$/;"	v
corrupt	tandem/tandem.h	/^  unsigned corrupt     : 1;$/;"	m	struct:nsk_file_flags	access:public
count	cmsmvs/mvs.h	/^   unsigned short int count;$/;"	m	struct:__anon21	access:public
count	os2/os2zip.c	/^static ULONG count;$/;"	v	file:
count	os2/os2zip.c	/^static USHORT count;$/;"	v	file:
count	vms/vms.h	/^    ush count;$/;"	m	struct:iosb	access:public
count_args	util.c	/^local int count_args(s)$/;"	f
count_of_Zippedfiles	macos/source/macos.c	/^unsigned long count_of_Zippedfiles = 0;$/;"	v
course	README	/^of course, the ability to run on most of your favorite operating systems.  And$/;"	v
cparms	cmsmvs/mc.exec	/^    '| specs \/CC \/ 1 w1-3 n \/(NOTERM 'cparms'\/ nw',   \/* compile! *\/$/;"	v
cparms	cmsmvs/mc.exec	/^cparms = cparms globals$/;"	v
cpuflag	amiga/match_68.a	/^        section cpuflag,data$/;"	v
crashopen	tandem/tandem.h	/^  unsigned crashopen   : 1;$/;"	m	struct:nsk_file_flags	access:public
cray_v3	INSTALL	/^     att6300, coherent, cray_v3, minix, sco_x286, xenix, zilog.$/;"	v
crc	zip.h	/^  ulg tim, crc;$/;"	m	struct:zlist	access:public
crc	zipup.c	/^local ulg crc;                  \/* crc on uncompressed file data *\/$/;"	v
crc32	crc32.c	/^ulg crc32(crc, buf, len)$/;"	f
crc32	vms/vms.h	/^    ulg crc32;$/;"	m	struct:PK_header	access:public
crc32	win32/crc_i386.c	/^ulg crc32(crc, buf, len)$/;"	f
crc_32_tab	zip.c	/^ZCONST uLongf *crc_32_tab;$/;"	v
crc_32_tab	zip.c	/^ZCONST ulg near *crc_32_tab;$/;"	v
crc_32_tab	zipcloak.c	/^ZCONST uLongf *crc_32_tab;$/;"	v
crc_32_tab	zipcloak.c	/^ZCONST ulg near *crc_32_tab;$/;"	v
createArchiveName	macos/source/pathname.c	/^void createArchiveName(char *thePath)$/;"	f	signature:(char *thePath)
createTime	macos/source/macos.c	/^long    createTime;$/;"	v
created	WHATSNEW	/^  directories being created, -AS now does not store directory$/;"	v
created	zip30f.ann	/^  includes only files changed or added since the input archive was created,$/;"	v
creation_time	tandem/tandem.h	/^  time_t creation_time;       \/* 32 bits *\/$/;"	m	struct:nsk_stat_overlay	access:public
cry_crctb_p	crypt.c	/^   local z_uint4 near *cry_crctb_p = NULL;$/;"	v
crycrctab	crypt.c	/^   local z_uint4 near crycrctab[256];$/;"	v
crypthead	crypt.c	/^void crypthead(passwd, crc)$/;"	f
cryptnote	revision.h	/^ZCONST char * far cryptnote[] = {$/;"	v
crytab_init	crypt.c	/^local z_uint4 near *crytab_init(__G)$/;"	f
ct_data	trees.c	/^typedef struct ct_data {$/;"	s	file:
ct_data	trees.c	/^} ct_data;$/;"	t	typeref:struct:ct_data	file:
ct_data::__anon28::code	trees.c	/^        ush  code;       \/* bit string *\/$/;"	m	union:ct_data::__anon28	file:	access:public
ct_data::__anon28::freq	trees.c	/^        ush  freq;       \/* frequency count *\/$/;"	m	union:ct_data::__anon28	file:	access:public
ct_data::__anon29::dad	trees.c	/^        ush  dad;        \/* father node in Huffman tree *\/$/;"	m	union:ct_data::__anon29	file:	access:public
ct_data::__anon29::len	trees.c	/^        ush  len;        \/* length of bit string *\/$/;"	m	union:ct_data::__anon29	file:	access:public
ct_data::dl	trees.c	/^    } dl;$/;"	m	struct:ct_data	typeref:union:ct_data::__anon29	file:	access:public
ct_data::fc	trees.c	/^    } fc;$/;"	m	struct:ct_data	typeref:union:ct_data::__anon28	file:	access:public
ct_init	trees.c	/^void ct_init(attr, method)$/;"	f
ct_tally	trees.c	/^int ct_tally (dist, lc)$/;"	f
ctime	zip.h	/^   time_t ctime;                \/* new creation time (!= Unix st.ctime) *\/$/;"	m	struct:iztimes	access:public
cur_match	match.S	93;"	d	file:
cur_match	msdos/match.asm	/^        mov     si,cur_match            ; use bp before it is destroyed$/;"	v
cur_match	os2/match32.asm	/^; at this point, edi == scan+2, esi == cur_match,$/;"	v
cur_match	win32/gvmat64.asm	/^;    IPos cur_match;                             \/* current match *\/$/;"	v
cur_match	win32/match32.asm	/^; at this point, edi == scan+2, esi == cur_match,$/;"	v
current	msdos/match.asm	/^; IN assertions: cur_match is the head of the hash chain for the current$/;"	v
current	os2/match32.asm	/^; IN assertions: cur_match is the head of the hash chain for the current$/;"	v
current	win32/match32.asm	/^; IN assertions: cur_match is the head of the hash chain for the current$/;"	v
current	zip.h	/^  int current;                  \/* Marker for files that are current to what is on OS (filesync) *\/$/;"	m	struct:zlist	access:public
currentLevel	macos/source/recurse.c	/^    unsigned short          currentLevel;   \/* The current level$/;"	m	struct:RecurseGlobals	file:	access:public
current_disk	globals.c	/^ulg     current_disk = 0;         \/* current disk number *\/$/;"	v
current_in_disk	globals.c	/^ulg     current_in_disk = 0;    \/* current read split disk *\/$/;"	v
current_in_offset	globals.c	/^uzoff_t current_in_offset = 0;  \/* current offset in current read disk *\/$/;"	v
current_line	vms/cvthelp.tpu	/^        if length(current_line) = 0$/;"	v
current_local_disk	globals.c	/^ulg     current_local_disk = 0;   \/* disk with current local header *\/$/;"	v
current_local_file	globals.c	/^FILE  *current_local_file = NULL; \/* file pointer for current local header *\/$/;"	v
current_local_offset	globals.c	/^uzoff_t current_local_offset = 0; \/* offset to start of current local header *\/$/;"	v
current_local_tempname	globals.c	/^char *current_local_tempname = NULL; \/* name of temp file *\/$/;"	v
cutpath	zipfile.c	/^local void cutpath(p, delim)$/;"	f
cx	msdos/crc_i86.asm	/^        and     cx,00003H$/;"	v
cx	msdos/crc_i86.asm	/^        dec     cx                      ; on 286, "loop Next_Four" needs 11$/;"	v
cx	msdos/crc_i86.asm	/^        mov     cx,WORD PTR [bp+10+LCOD_OFS]    ;len$/;"	v
cx	msdos/crc_i86.asm	/^        mov     cx,WORD PTR [bp+12+LCOD_OFS]    ;len$/;"	v
cx	msdos/crc_i86.asm	/^        shr     cx,1$/;"	v
cx	msdos/crc_i86.asm	/^        shr     cx,2$/;"	v
cx	msdos/crc_i86.asm	/^        test    cx,cx$/;"	v
cx	msdos/match.asm	/^        mov     cx,es$/;"	v
d0	amiga/deflate.a	/^        MOVINT  Head,d0                 ; parm for longest_match$/;"	v
d0	amiga/deflate.a	/^        MOVINT  d0,-(sp)$/;"	v
d0	amiga/deflate.a	/^        cmp.w   Look,d0                 ; does length exceed valid data?$/;"	v
d0	amiga/deflate.a	/^        dbra    d0,align$/;"	v
d0	amiga/deflate.a	/^        dbra    d0,fixhead$/;"	v
d0	amiga/deflate.a	/^        dbra    d0,fixprev$/;"	v
d0	amiga/deflate.a	/^        move.l  Window,d0               ; fake tst.l$/;"	v
d0	amiga/deflate.a	/^; Arg 1 is bool (int) EOF flag, flush_block result is in d0, trashes d1\/a0\/a1$/;"	v
d0	amiga/deflate.a	/^Cur_Match       equr    d0              ; unsigned int, kept valid as long$/;"	v
d0	human68k/deflate.s	/^        MOVINT  Head,d0                 ; parm for longest_match$/;"	v
d0	human68k/deflate.s	/^        MOVINT  d0,-(sp)$/;"	v
d0	human68k/deflate.s	/^        cmp.w   Look,d0                 ; does length exceed valid data?$/;"	v
d0	human68k/deflate.s	/^        dbra    d0,align$/;"	v
d0	human68k/deflate.s	/^        dbra    d0,fixhead$/;"	v
d0	human68k/deflate.s	/^        dbra    d0,fixprev$/;"	v
d0	human68k/deflate.s	/^        move.w  (eofile,pc),d0          ; we put this up here for speed$/;"	v
d0	human68k/deflate.s	/^; Arg 1 is bool (int) EOF flag, flush_block result is in d0, trashes d1\/a0\/a1$/;"	v
d0	human68k/deflate.s	/^Cur_Match       reg     d0              ; unsigned int, kept valid as long$/;"	v
d0	qdos/match.s	/^;;Cur_Match      equr     d0      ; Must be in d0!$/;"	v
d1	amiga/deflate.a	/^        IN_STR  a0,d1                   ; don't clobber d0$/;"	v
d1	amiga/deflate.a	/^        IN_STR  a0,d1                   ; preserve d0$/;"	v
d1	amiga/deflate.a	/^        UP_HASH d1,Avail                ; preserve d0$/;"	v
d1	amiga/deflate.a	/^        moveq   #0,d1                   ; preserve d0$/;"	v
d1	amiga/deflate.a	/^Best_Len        equr    d1              ; unsigned int, kept valid as long$/;"	v
d1	human68k/deflate.s	/^        IN_STR  a0,d1                   ; don't clobber d0$/;"	v
d1	human68k/deflate.s	/^        UP_HASH d1,Avail                ; preserve d0$/;"	v
d1	human68k/deflate.s	/^        moveq   #0,d1                   ; preserve d0$/;"	v
d1	human68k/deflate.s	/^Best_Len        reg     d1              ; unsigned int, kept valid as long$/;"	v
d1	qdos/match.s	/^;;Best_Len       equr     d1$/;"	v
d2	amiga/deflate.a	/^Avail   equr    d2              ; local variable available_match, bool$/;"	v
d2	amiga/deflate.a	/^Level   equr    d2$/;"	v
d2	human68k/deflate.s	/^Avail   reg     d2              ; local variable available_match, bool$/;"	v
d2	human68k/deflate.s	/^Level   reg     d2$/;"	v
d2	qdos/match.s	/^;;Loop_Counter   equr     d2$/;"	v
d3	amiga/deflate.a	/^MatchL  equr    d3              ; local variable match_length, unsigned short$/;"	v
d3	amiga/deflate.a	/^Scan_Start      equr    d3              ; pair of bytes$/;"	v
d3	human68k/deflate.s	/^MatchL  reg     d3              ; local variable match_length, unsigned short$/;"	v
d3	human68k/deflate.s	/^Scan_Start      reg     d3              ; pair of bytes$/;"	v
d3	qdos/match.s	/^;;Scan_Start     equr     d3$/;"	v
d4	amiga/deflate.a	/^PrevL   equr    d4              ; prev_length cached as short$/;"	v
d4	amiga/deflate.a	/^Scan_End        equr    d4              ; pair of bytes$/;"	v
d4	human68k/deflate.s	/^PrevL   reg     d4              ; prev_length cached as short$/;"	v
d4	human68k/deflate.s	/^Scan_End        reg     d4              ; pair of bytes$/;"	v
d4	qdos/match.s	/^;;Scan_End       equr     d4$/;"	v
d5	amiga/deflate.a	/^Head    equr    d5              ; local variable hash_head, short$/;"	v
d5	amiga/deflate.a	/^Limit           equr    d5              ; unsigned int$/;"	v
d5	human68k/deflate.s	/^Head    reg     d5              ; local variable hash_head, short$/;"	v
d5	human68k/deflate.s	/^Limit           reg     d5              ; unsigned int$/;"	v
d5	qdos/match.s	/^;;Limit          equr     d5$/;"	v
d6	amiga/deflate.a	/^Chain_Length    equr    d6              ; unsigned int$/;"	v
d6	amiga/deflate.a	/^Look    equr    d6              ; lookahead cached as short$/;"	v
d6	human68k/deflate.s	/^Chain_Length    reg     d6              ; unsigned int$/;"	v
d6	human68k/deflate.s	/^Look    reg     d6              ; lookahead cached as short$/;"	v
d6	qdos/match.s	/^        dbls    d6,do_scan$/;"	v
d6	qdos/match.s	/^;;Chain_Length   equr     d6$/;"	v
d7	amiga/deflate.a	/^Scan_Test       equr    d7              ; counter, pair of bytes sometimes$/;"	v
d7	amiga/deflate.a	/^Strst   equr    d7              ; strstart cached as a longword$/;"	v
d7	human68k/deflate.s	/^Scan_Test       reg     d7              ; counter, pair of bytes sometimes$/;"	v
d7	human68k/deflate.s	/^Strst   reg     d7              ; strstart cached as a longword$/;"	v
d7	qdos/match.s	/^;;Scan_Test      equr     d7$/;"	v
d_access	qdos/qdos.c	/^    unsigned char   d_access __attribute__ ((packed));  \/* file access type *\/$/;"	m	struct:qdirect	file:	access:public
d_backup	qdos/qdos.c	/^    long            d_backup __attribute__ ((packed));   \/* EOD *\/$/;"	m	struct:qdirect	file:	access:public
d_buf	trees.c	/^  local ush far *d_buf;$/;"	v
d_buf	trees.c	/^  local ush far d_buf[DIST_BUFSIZE]; \/* buffer for distances *\/$/;"	v
d_cleanuplink	amiga/z-stat.h	/^    struct dirent       *d_cleanuplink,$/;"	m	struct:dirent	typeref:struct:dirent::dirent	access:public
d_cleanupparent	amiga/z-stat.h	/^                       **d_cleanupparent;$/;"	m	struct:dirent	typeref:struct:dirent::	access:public
d_code	trees.c	457;"	d	file:
d_datalen	qdos/qdos.c	/^    long            d_datalen __attribute__ ((packed)); \/* data length *\/$/;"	m	struct:qdirect	file:	access:public
d_date	os2/os2zip.h	/^  unsigned d_date;$/;"	m	struct:dirent	access:public
d_desc	trees.c	/^local tree_desc near d_desc =$/;"	v
d_fd	win32/win32zip.c	/^  WIN32_FIND_DATA d_fd;$/;"	m	struct:zdirscan	file:	access:public
d_fdw	win32/win32zip.c	/^  WIN32_FIND_DATAW d_fdw;$/;"	m	struct:zdirscanw	file:	access:public
d_fib	amiga/z-stat.h	/^    struct FileInfoBlock d_fib;$/;"	m	struct:dirent	typeref:struct:dirent::FileInfoBlock	access:public
d_fileno	acorn/riscos.h	/^  int d_fileno;                \/* file number of entry *\/$/;"	m	struct:dirent	access:public
d_first	win32/win32zip.c	/^  int    d_first;$/;"	m	struct:zdirscan	file:	access:public
d_first	win32/win32zip.c	/^  int    d_first;$/;"	m	struct:zdirscanw	file:	access:public
d_hFindFile	win32/win32zip.c	/^  HANDLE d_hFindFile;$/;"	m	struct:zdirscan	file:	access:public
d_hFindFile	win32/win32zip.c	/^  HANDLE d_hFindFile;$/;"	m	struct:zdirscanw	file:	access:public
d_ino	os2/os2zip.h	/^  ino_t    d_ino;                   \/* a bit of a farce *\/$/;"	m	struct:dirent	access:public
d_length	qdos/qdos.c	/^    long            d_length __attribute__ ((packed));  \/* file length *\/$/;"	m	struct:qdirect	file:	access:public
d_mode	os2/os2zip.h	/^  unsigned d_mode;                  \/* DOS or OS\/2 file attributes *\/$/;"	m	struct:dirent	access:public
d_name	acorn/riscos.h	/^  char d_name[MAXFILENAMELEN]; \/* name *\/$/;"	m	struct:dirent	access:public
d_name	amiga/z-stat.h	80;"	d
d_name	cmsmvs/mvs.h	/^   char   d_name[NAMELEN+1];$/;"	m	struct:dirent	access:public
d_name	macos/source/unixlike.h	/^        char            d_name[NAME_MAX];$/;"	m	struct:dirent	access:public
d_name	os2/os2zip.h	/^  char     d_name[MAXNAMLEN + 1];   \/* null terminated *\/$/;"	m	struct:dirent	access:public
d_name	qdos/qdos.c	/^    char            d_name[QDOS_FLMAX] __attribute__ ((packed));\/* name area *\/$/;"	m	struct:qdirect	file:	access:public
d_name	tandem/tandem.h	/^   char   d_name[NAMELEN+1];$/;"	m	struct:dirent	access:public
d_name	vms/vmszip.c	/^  char d_name[ NAM_MAXRSS+ 1];$/;"	m	struct:zdirent	file:	access:public
d_namlen	acorn/riscos.h	/^  size_t d_namlen;             \/* length of d_name *\/$/;"	m	struct:dirent	access:public
d_namlen	os2/os2zip.h	/^  int      d_namlen;                \/* length of d_name *\/$/;"	m	struct:dirent	access:public
d_next	cmsmvs/mvs.h	/^   struct dirent *d_next;$/;"	m	struct:dirent	typeref:struct:dirent::dirent	access:public
d_next	tandem/tandem.h	/^   struct dirent *d_next;$/;"	m	struct:dirent	typeref:struct:dirent::dirent	access:public
d_off	acorn/riscos.h	/^  unsigned int d_off;          \/* offset of next disk directory entry *\/$/;"	m	struct:dirent	access:public
d_parentlock	amiga/z-stat.h	/^    BPTR                 d_parentlock;$/;"	m	struct:dirent	access:public
d_qualwildname	vms/vmszip.c	/^  char d_qualwildname[ NAM_MAXRSS+ 1];$/;"	m	struct:zdirent	file:	access:public
d_reclen	acorn/riscos.h	/^  size_t d_reclen;             \/* length of this record *\/$/;"	m	struct:dirent	access:public
d_reclen	os2/os2zip.h	/^  int      d_reclen;                \/* more farce *\/$/;"	m	struct:dirent	access:public
d_refdate	qdos/qdos.c	/^    long            d_refdate __attribute__ ((packed));$/;"	m	struct:qdirect	file:	access:public
d_reserved	qdos/qdos.c	/^    long            d_reserved __attribute__ ((packed));\/* Unused *\/$/;"	m	struct:qdirect	file:	access:public
d_size	os2/os2zip.h	/^  long     d_size;                  \/* size in bytes *\/$/;"	m	struct:dirent	access:public
d_szname	qdos/qdos.c	/^    short           d_szname __attribute__ ((packed));  \/* size of name *\/$/;"	m	struct:qdirect	file:	access:public
d_time	os2/os2zip.h	/^  unsigned d_time;$/;"	m	struct:dirent	access:public
d_type	qdos/qdos.c	/^    unsigned char   d_type __attribute__ ((packed));    \/* file type *\/$/;"	m	struct:qdirect	file:	access:public
d_update	qdos/qdos.c	/^    long            d_update __attribute__ ((packed));  \/* last update *\/$/;"	m	struct:qdirect	file:	access:public
d_wild	vms/vmszip.c	/^  int d_wild;                \/* flag for wildcard vs. non-wild *\/$/;"	m	struct:zdirent	file:	access:public
dad	trees.c	/^        ush  dad;        \/* father node in Huffman tree *\/$/;"	m	union:ct_data::__anon29	file:	access:public
damage	zip.txt	/^              the  archive  and,  depending  on  the  damage,  it may find the$/;"	v
data	amiga/deflate.a	/^        section deflatevars,data$/;"	v
data	human68k/deflate.s	/^;;;     section deflatevars,data$/;"	v
data	os2/os2acl.c	/^static char *path, *data;$/;"	v	file:
data	vms/vms.h	/^    byte data[1];$/;"	m	struct:PK_header	access:public
data	vms/vms.h	/^    uch data[1];$/;"	m	struct:EB_header	access:public
date	api.h	/^    char date[20];          \/* e.g., "4 Sep 95" (beta) or "4 September 1995" *\/$/;"	m	struct:_ZpVer	access:public
date	windll/windll.txt	/^    char *date;             \/* e.g., "4 Sep 95" (beta) or "4 September 1995" *\/$/;"	m	struct:_ZpVer	file:	access:public
daylight	timezone.c	/^int daylight = 0;$/;"	v
daylight	win32/osdep.h	490;"	d
dcompress	tandem/tandem.h	/^  unsigned dcompress   : 1;$/;"	m	struct:nsk_file_flags	access:public
dd_contents	os2/os2zip.h	/^  struct _dircontents *dd_contents;   \/* pointer to contents of dir *\/$/;"	m	struct:_dirdesc	typeref:struct:_dirdesc::_dircontents	access:public
dd_cp	os2/os2zip.h	/^  struct _dircontents *dd_cp;         \/* pointer to current position *\/$/;"	m	struct:_dirdesc	typeref:struct:_dirdesc::_dircontents	access:public
dd_id	os2/os2zip.h	/^  int  dd_id;                   \/* uniquely identify each open directory *\/$/;"	m	struct:_dirdesc	access:public
dd_loc	os2/os2zip.h	/^  long dd_loc;                  \/* where we are in directory entry is this *\/$/;"	m	struct:_dirdesc	access:public
decc_feat_array	vms/vms.c	/^decc_feat_t decc_feat_array[] = {$/;"	v
decc_feat_t	vms/vms.c	/^   } decc_feat_t;$/;"	t	typeref:struct:__anon27	file:
decc_init	vms/vms.c	/^static void decc_init( void)$/;"	f	file:	signature:( void)
decc_init_done	vms/vms.c	/^int decc_init_done = -1;$/;"	v
decrypt_byte	crypt.c	/^int decrypt_byte(__G)$/;"	f
decrypt_byte	crypt.h	106;"	d
decrypt_byte	crypt.h	108;"	d
decrypt_byte	crypt.h	114;"	d
defined	CHANGES	/^ 2. Only call NLMsignals() in zip.c when NLM is defined (Mike, Onno)$/;"	f
defined	amiga/deflate.a	/^;               If neither of these is defined, use 68000 instructions only.$/;"	v
defined	amiga/deflate.a	/^;               function calls.  At present, if AMIGA is not defined, it$/;"	v
defined	amiga/match_68.a	/^;               If neither of these is defined, use 68000 instructions only.$/;"	v
defined	human68k/deflate.s	/^;               If neither of these is defined, use 68000 instructions only.$/;"	v
defined	human68k/deflate.s	/^;               function calls.  At present, if AMIGA is not defined, it$/;"	v
defined	msdos/match.asm	/^; When SS_NEQ_DS is defined, the code segment is used to store some$/;"	v
deflInit	zipup.c	/^  local int deflInit = FALSE;   \/* flag: zlib deflate is initialized *\/$/;"	v
deflate	deflate.c	/^uzoff_t deflate()$/;"	f
deflate	human68k/deflate.s	/^;;      section deflate,code$/;"	v
deflate_fast	deflate.c	/^local uzoff_t deflate_fast()$/;"	f
deflatevars	human68k/deflate.s	/^;;;     section deflatevars,data$/;"	v
degrade	win32/gvmat64.asm	/^;;; straightforward "rep cmpsb" would not drastically degrade$/;"	v
delete	tandem/tandem.h	/^  unsigned delete    : 3;$/;"	m	struct:nsk_file_attrs_def	access:public
deletedir	acorn/riscos.c	/^int deletedir(char *d)$/;"	f	signature:(char *d)
deletedir	amiga/amigazip.c	/^int deletedir(d)$/;"	f
deletedir	aosvs/aosvs.c	/^int deletedir(d)$/;"	f
deletedir	atari/atari.c	/^int deletedir(d)$/;"	f
deletedir	atheos/osdep.h	29;"	d
deletedir	beos/beos.c	/^int deletedir(d)$/;"	f
deletedir	cmsmvs/cmsmvs.c	/^int deletedir(d)$/;"	f
deletedir	human68k/human68k.c	/^int deletedir(d)$/;"	f
deletedir	macos/source/macos.c	/^int deletedir(char *path)$/;"	f	signature:(char *path)
deletedir	msdos/msdos.c	/^int deletedir(d)$/;"	f
deletedir	novell/Netware.c	/^int deletedir(d)$/;"	f
deletedir	os2/os2.c	/^int deletedir(d)$/;"	f
deletedir	qdos/qfileio.c	/^int deletedir(d)$/;"	f
deletedir	tandem/tanzip.c	/^  int deletedir(d)$/;"	f
deletedir	theos/osdep.h	30;"	d
deletedir	tops20/tops20.c	/^int deletedir(d)$/;"	f
deletedir	unix/unix.c	/^int deletedir(d)$/;"	f
deletedir	vms/vmszip.c	/^int deletedir( char *d)$/;"	f	signature:( char *d)
deletedir	win32/win32zip.c	/^int deletedir(d)$/;"	f
depth	trees.c	/^local uch near depth[2*L_CODES+1];$/;"	v
des_crc	globals.c	/^ulg des_crc = 0;        \/* Data descriptor CRC *\/$/;"	v
des_csize	globals.c	/^uzoff_t des_csize = 0;  \/* Data descriptor csize *\/$/;"	v
des_good	globals.c	/^int des_good = 0;       \/* Good data descriptor found *\/$/;"	v
des_usize	globals.c	/^uzoff_t des_usize = 0;  \/* Data descriptor usize *\/$/;"	v
descmp	zipsplit.c	/^local int descmp(a, b)$/;"	f
descriptions	CHANGES	/^ 7. windll: Fix some typos, descriptions (Christian)$/;"	f
destroy	fileio.c	/^int destroy(f)$/;"	f
destroy	macos/source/macopen.c	/^int destroy(char *path)$/;"	f	signature:(char *path)
detection	CHANGES	/^ 3. use #elif constructions for msdos,os2 and win32 compiler detection (Onno)$/;"	f
devlen	qdos/qdos.c	/^short devlen(char *p)$/;"	f	signature:(char *p)
dh	msdos/crc_i86.asm	/^        sub     dh,dh$/;"	v
dh	win32/gvmat64.asm	/^    db     0dh,0ah,"asm686 with masm, optimised assembly code from Brian Raiter, written 1998, converted to amd 64 by Gilles Vollant 2005",0dh,0ah,0$/;"	v
di	msdos/crc_i86.asm	/^        add     di,2$/;"	v
di	msdos/crc_i86.asm	/^        les     di,DWORD PTR [bp+8+LCOD_OFS]    ;buf$/;"	v
di	msdos/crc_i86.asm	/^        mov     di,WORD PTR [bp+8+LCOD_OFS]     ;buf$/;"	v
di	msdos/crc_i86.asm	/^start:  test    di,1$/;"	v
di	msdos/match.asm	/^        mov     ax,di                   ; ax = scan+2$/;"	v
di	msdos/match.asm	/^        xchg    ax,di                   ; di = scan+2, ax = end of scan$/;"	v
di	msdos/match.asm	/^;       scan         equ es:di$/;"	v
diag	zip.h	564;"	d
diag	zip.h	580;"	d
diff_mode	globals.c	/^int diff_mode = 0;            \/* 1=require --out and only store changed and add *\/$/;"	v
different	zip.txt	/^       or size of the OS file is different, adding  new  files,  and  deleting$/;"	v
digits	proginfo/timezone.txt	/^      leading colon (:), digits, a comma (,), a minus (-) or a plus$/;"	v
dirID	macos/source/macglob.h	/^    long            dirID;$/;"	m	struct:__anon17	access:public
dir_cleanup_list	amiga/stat.c	/^static DIR *dir_cleanup_list = NULL;    \/* for resource tracking *\/$/;"	v	file:
dir_fstat_packet	aosvs/aosvs.c	/^     P_FSTAT_DIR    dir_fstat_packet;       \/* DIR\/CPD fstat packet *\/$/;"	m	union:zvsfstat_stru	file:	access:public
direct	amiga/amiga.h	27;"	d
direct	proginfo/extrafld.txt	/^          reclen        Short       record length for indexed,keyed and direct,$/;"	v
directories	zip.txt	/^              the paths of entries, including directories, are stored as usual$/;"	v
directory	README.CR	/^      directory, as usual.$/;"	v
directory	vms/build_zip.com	/^$! Find out current disk, directory, compiler and options$/;"	v
directory	zip.txt	/^              include  dir,  a directory directly under the current directory,$/;"	v
dirent	acorn/riscos.h	/^struct dirent {$/;"	s
dirent	amiga/z-stat.h	/^typedef struct dirent {$/;"	s
dirent	beos/beos.c	64;"	d	file:
dirent	cmsmvs/mvs.h	/^struct dirent {$/;"	s
dirent	macos/source/unixlike.h	/^struct dirent {$/;"	s
dirent	os2/os2zip.h	/^struct dirent$/;"	s
dirent	tandem/tandem.h	/^struct dirent {$/;"	s
dirent	unix/unix.c	41;"	d	file:
dirent	unix/unix.c	68;"	d	file:
dirent::d_cleanuplink	amiga/z-stat.h	/^    struct dirent       *d_cleanuplink,$/;"	m	struct:dirent	typeref:struct:dirent::dirent	access:public
dirent::d_cleanupparent	amiga/z-stat.h	/^                       **d_cleanupparent;$/;"	m	struct:dirent	typeref:struct:dirent::	access:public
dirent::d_date	os2/os2zip.h	/^  unsigned d_date;$/;"	m	struct:dirent	access:public
dirent::d_fib	amiga/z-stat.h	/^    struct FileInfoBlock d_fib;$/;"	m	struct:dirent	typeref:struct:dirent::FileInfoBlock	access:public
dirent::d_fileno	acorn/riscos.h	/^  int d_fileno;                \/* file number of entry *\/$/;"	m	struct:dirent	access:public
dirent::d_ino	os2/os2zip.h	/^  ino_t    d_ino;                   \/* a bit of a farce *\/$/;"	m	struct:dirent	access:public
dirent::d_mode	os2/os2zip.h	/^  unsigned d_mode;                  \/* DOS or OS\/2 file attributes *\/$/;"	m	struct:dirent	access:public
dirent::d_name	acorn/riscos.h	/^  char d_name[MAXFILENAMELEN]; \/* name *\/$/;"	m	struct:dirent	access:public
dirent::d_name	cmsmvs/mvs.h	/^   char   d_name[NAMELEN+1];$/;"	m	struct:dirent	access:public
dirent::d_name	macos/source/unixlike.h	/^        char            d_name[NAME_MAX];$/;"	m	struct:dirent	access:public
dirent::d_name	os2/os2zip.h	/^  char     d_name[MAXNAMLEN + 1];   \/* null terminated *\/$/;"	m	struct:dirent	access:public
dirent::d_name	tandem/tandem.h	/^   char   d_name[NAMELEN+1];$/;"	m	struct:dirent	access:public
dirent::d_namlen	acorn/riscos.h	/^  size_t d_namlen;             \/* length of d_name *\/$/;"	m	struct:dirent	access:public
dirent::d_namlen	os2/os2zip.h	/^  int      d_namlen;                \/* length of d_name *\/$/;"	m	struct:dirent	access:public
dirent::d_next	cmsmvs/mvs.h	/^   struct dirent *d_next;$/;"	m	struct:dirent	typeref:struct:dirent::dirent	access:public
dirent::d_next	tandem/tandem.h	/^   struct dirent *d_next;$/;"	m	struct:dirent	typeref:struct:dirent::dirent	access:public
dirent::d_off	acorn/riscos.h	/^  unsigned int d_off;          \/* offset of next disk directory entry *\/$/;"	m	struct:dirent	access:public
dirent::d_parentlock	amiga/z-stat.h	/^    BPTR                 d_parentlock;$/;"	m	struct:dirent	access:public
dirent::d_reclen	acorn/riscos.h	/^  size_t d_reclen;             \/* length of this record *\/$/;"	m	struct:dirent	access:public
dirent::d_reclen	os2/os2zip.h	/^  int      d_reclen;                \/* more farce *\/$/;"	m	struct:dirent	access:public
dirent::d_size	os2/os2zip.h	/^  long     d_size;                  \/* size in bytes *\/$/;"	m	struct:dirent	access:public
dirent::d_time	os2/os2zip.h	/^  unsigned d_time;$/;"	m	struct:dirent	access:public
dirname	acorn/riscos.h	/^  char *dirname;$/;"	m	struct:__anon8	access:public
dirnames	globals.c	/^int dirnames = 1;             \/* include directory entries by default *\/$/;"	v
disabled	win32/crc_i386.asm	/^;   This optimization is controlled by the macro symbol __686 and is disabled$/;"	v
disk	proginfo/perform.dos	/^Cx486DX-40, VL-bus, 8MB; IDE hard disk;$/;"	v
disk	vms/NOTES.TXT	/^binary kit could be created on an ODS2 disk, and a Zip archive created$/;"	v
disk_not_mounted	amiga/amiga.h	43;"	d
disk_not_mounted	amiga/stat.c	/^unsigned short disk_not_mounted;$/;"	v
disks	proginfo/fileinfo.cms	/^    on all the accessed readable disks, in order.  If it does not find$/;"	v
disks	vms/NOTES.TXT	/^both ODS2 and ODS5 disks, and old and new Zip and UnZip versions, it's$/;"	v
display_bytes	globals.c	/^int display_bytes = 0;        \/* display running bytes remaining *\/$/;"	v
display_counts	globals.c	/^int display_counts = 0;       \/* display running file count *\/$/;"	v
display_globaldots	globals.c	/^int display_globaldots = 0;   \/* display dots for archive instead of each file *\/$/;"	v
display_usize	globals.c	/^int display_usize = 0;        \/* display uncompressed bytes *\/$/;"	v
display_volume	globals.c	/^int display_volume = 0;       \/* display current input and output volume (disk) numbers *\/$/;"	v
dispose	globals.c	/^int dispose = 0;        \/* 1=remove files after put in zip file *\/$/;"	v
dist_code	trees.c	/^local uch dist_code[512];$/;"	v
djgpp	proginfo/infozip.who	/^Christian Spieler       spieler@ikp.tu-darmstadt.de     VMS, MSDOS, emx, djgpp,$/;"	v
dl	msdos/crc_i86.asm	/^        mov     dl,dh$/;"	v
dl	trees.c	/^    } dl;$/;"	m	struct:ct_data	typeref:union:ct_data::__anon29	file:	access:public
dll	windll/Vb/readmeVB.txt	/^dll, and you should now use a version of zip32.dll from that or later.$/;"	v
dmy_lib$initialize	vms/vms.c	/^int dmy_lib$initialize = (int) LIB$INITIALIZE;$/;"	v
do_scan	msdos/match.asm	/^        jb      do_scan                 ; good match?$/;"	v
documents	proginfo/txtvsbin.txt	/^documents, compiled object code, etcetera.  The results confirm the$/;"	v
don	win32/gvmat64.asm	/^; please don't remove this string !$/;"	v
done	msdos/crc_i86.asm	/^        jz      done$/;"	v
dos2unixtime	fileio.c	/^time_t dos2unixtime(dostime)$/;"	f
dosflag	zip.h	/^  int dosflag;                  \/* Set to force MSDOS file attributes *\/$/;"	m	struct:flist	access:public
dosflag	zip.h	/^  int dosflag;                  \/* Set to force MSDOS file attributes *\/$/;"	m	struct:zlist	access:public
dosify	globals.c	/^int dosify = 0;         \/* 1=make new entries look like MSDOS *\/$/;"	v
dosmatch	util.c	/^int dosmatch(p, s, cs)$/;"	f
dosmatchw	util.c	/^int dosmatchw(pw, sw, cs)$/;"	f
dostime	fileio.c	/^ulg dostime(y, n, d, h, m, s)$/;"	f
dot_count	globals.c	/^zoff_t dot_count = 0;         \/* buffers seen, recyles at dot_size *\/$/;"	v
dot_size	globals.c	/^zoff_t dot_size = 0;          \/* bytes processed in deflate per dot, 0 = no dots *\/$/;"	v
doubledash_ends_options	fileio.c	/^int doubledash_ends_options = 1;            \/* when -- what follows are not options *\/$/;"	v
dowhereis	novell/Netware.c	/^void dowhereis(char *s)$/;"	f	signature:(char *s)
drive	proginfo/3rdparty.bug	/^   drive, sometimes only zeros out the data while failing to shrink the$/;"	v
drives	proginfo/3rdparty.bug	/^ - PKZIP (2.04g?) can silently ignore read errors on network drives, storing$/;"	v
ds	msdos/crc_i86.asm	/^        mov     ds,ax$/;"	v
ds	msdos/crc_i86.asm	/^        pop     ds$/;"	v
ds	msdos/crc_i86.asm	/^;       mov     ds,dx$/;"	v
ds	msdos/crc_i86.asm	/^;       push    ds$/;"	v
ds	msdos/match.asm	/^        mov     ds,prev_seg             ; (does not destroy the flags)$/;"	v
dsk	zip.h	/^  ulg dsk;                      \/* disk number was ush but now ulg *\/$/;"	m	struct:zlist	access:public
dstrm	acorn/riscos.h	54;"	d
dump_rms_block	vms/vms_im.c	/^static void dump_rms_block(p)$/;"	f	file:
dw	msdos/match.asm	/^    match_start dw  0                   ; copy of _match_start if SS != DS$/;"	v
dw	msdos/match.asm	/^    nice_match  dw  0                   ; copy of _nice_match  if SS != DS$/;"	v
dwFileAttributes	win32/nt.h	/^    DWORD dwFileAttributes;$/;"	m	struct:__anon6	access:public
dwFileSystemFlags	win32/nt.h	/^    DWORD dwFileSystemFlags;    \/* describes target file system *\/$/;"	m	struct:__anon6	access:public
dwPlatformId	windll/example.c	/^DWORD dwPlatformId = 0xFFFFFFFF;$/;"	v
dwPtrIncr	win32/crc_i386.asm	/^                add     esi, 4*dwPtrIncr       ; ((ulg *)buf) += dwPtrIncr$/;"	v
dwRemotePrivileges	win32/nt.h	/^    DWORD dwRemotePrivileges;   \/* relevant only on remote volumes *\/$/;"	m	struct:__anon6	access:public
dx	msdos/crc_i86.asm	/^        mov     dx,WORD PTR [bp+6+LCOD_OFS]$/;"	v
dx	msdos/crc_i86.asm	/^        not     dx$/;"	v
dx	msdos/crc_i86.asm	/^        xor     dx,WORD PTR [bx+2][si]$/;"	v
dx	msdos/crc_i86.asm	/^;       mov     ds,dx$/;"	v
dx	msdos/match.asm	/^        mov     dx,_strstart$/;"	v
dx	msdos/match.asm	/^        sub     dx,MAX_DIST             ; limit = strstart-MAX_DIST$/;"	v
dx	msdos/match.asm	/^        sub     dx,dx                   ; limit = NIL$/;"	v
dyn_dtree	trees.c	/^local ct_data near dyn_dtree[2*D_CODES+1]; \/* distance tree *\/$/;"	v
dyn_ltree	trees.c	/^local ct_data near dyn_ltree[HEAP_SIZE];   \/* literal and length tree *\/$/;"	v
dyn_tree	trees.c	/^    ct_data near *dyn_tree;      \/* the dynamic tree *\/$/;"	m	struct:tree_desc	file:	access:public
dynamic	LICENSE	/^       modified or added functionality, and dynamic, shared, or static library$/;"	v
dynamic	tags	/^functionality	LICENSE	\/^       modified or added functionality, and dynamic, shared, or static library$\/;"	v$/;"	v
dynamic	tags	/^shared	LICENSE	\/^       modified or added functionality, and dynamic, shared, or static library$\/;"	v$/;"	v
dynamically	proginfo/fileinfo.cms	/^     dynamically, but only if you have not specified LRECL or BLKSIZE$/;"	v
eaSize	os2/os2zip.c	/^  USHORT eaSize;              \/* length of value *\/$/;"	m	struct:__anon11	file:	access:public
eaType	os2/os2zip.c	/^  USHORT eaType;              \/* 0xFFFD for length-preceded ASCII *\/$/;"	m	struct:__anon11	file:	access:public
early	acorn/sendbits.s	/^        MOV     ip,r4,LSR #16   ;  (done early, keeping the old bi_buf$/;"	v
eat_carets	vms/vmszip.c	/^local void eat_carets( char *str)$/;"	f	signature:( char *str)
eax	crc_i386.S	/^                subl    %eax, %eax           \/* > if (!buf)                  *\/$/;"	v
eax	match.S	/^        mov     %eax,%ebx               \/* ebx = best_len = len *\/$/;"	v
eax	match.S	/^        sub     %eax,%esi           \/* esi = cur_match *\/$/;"	v
eax	os2/match32.asm	/^        mov     eax,edi                 ; eax = scan+2$/;"	v
eax	os2/match32.asm	/^        mov     esi,eax                 ; cur_match$/;"	v
eax	os2/match32.asm	/^        xchg    eax,edi                 ; edi = scan+2, eax = end of scan$/;"	v
eax	win32/crc_i386.asm	/^                mov     eax,[edi+eax*4]        ;  ^ table[256*0+tmp]$/;"	v
eax	win32/crc_i386.asm	/^                shr     eax,16                 ;$/;"	v
eax	win32/crc_i386.asm	/^                xor     eax, dword ptr [esi]   ; c ^= *(ulg *)buf$/;"	v
eax	win32/crc_i386.asm	/^                xor     eax,edx                ; ..$/;"	v
eax	win32/crc_lcc.asm	/^	subl	%eax,%eax$/;"	v
eax	win32/gvmat64.asm	/^        cmp eax, MAX_MATCH$/;"	v
eax	win32/gvmat64.asm	/^        cmp eax, [nicematch]$/;"	v
eax	win32/gvmat64.asm	/^        mov eax, WMask$/;"	v
eax	win32/gvmat64.asm	/^        or  ebx, eax$/;"	v
eax	win32/gvmat64.asm	/^        shr eax,16$/;"	v
eax	win32/gvmat64.asm	/^        sub eax, MIN_LOOKAHEAD$/;"	v
eax	win32/gvmat64.asm	/^        test    eax, 0000FFFFh$/;"	v
eax	win32/gvmat64.asm	/^        test eax,0ffffffffh$/;"	v
eax	win32/lm32_lcc.asm	/^        cmp     _nice_match,%eax$/;"	v
eax	win32/lm32_lcc.asm	/^        mov     %eax,%ebx$/;"	v
eax	win32/lm32_lcc.asm	/^        sub     %eax,%esi$/;"	v
eax	win32/match32.asm	/^        mov     eax,edi                 ; eax = scan+2$/;"	v
eax	win32/match32.asm	/^        xchg    eax,edi                 ; edi = scan+2, eax = end of scan$/;"	v
ebcdic	ebcdic.h	/^ZCONST uch ebcdic[] = {$/;"	v
ebp	os2/match32.asm	/^        mov     ebp,max_chain_length    ; chain_length = max_chain_length$/;"	v
ebp	os2/match32.asm	/^        shr     ebp,2                   ; chain_length >>= 2$/;"	v
ebp	os2/match32.asm	/^;       chain_length equ ebp$/;"	v
ebp	win32/crc_i386.asm	/^                mov     ebp,esp$/;"	v
ebp	win32/gvmat64.asm	/^        cmovng ebp,edi$/;"	v
ebp	win32/gvmat64.asm	/^        mov ebp, strstart$/;"	v
ebp	win32/gvmat64.asm	/^        sub ebp, eax$/;"	v
ebp	win32/match32.asm	/^        mov     ebp,_max_chain_length   ; chain_length = max_chain_length$/;"	v
ebp	win32/match32.asm	/^        shr     ebp,2                   ; chain_length >>= 2$/;"	v
ebp	win32/match32.asm	/^;       chain_length equ ebp$/;"	v
ebug	vms/install_vms.txt	/^     o Build a large-file product from scratch, for debug, getting$/;"	v
ebugging	amiga/deflate.a	/^        xdef    _fill_window    ; this line is just for debugging$/;"	v
ebugging	human68k/deflate.s	/^        xdef    _fill_window    ; this line is just for debugging$/;"	v
ebx	crc_i386.S	/^                subl    %ebx, %ebx           \/* ebx=0; bl usable as dword    *\/$/;"	v
ebx	match.S	/^        cmp     %ebx,%eax           \/* len > best_len ? *\/$/;"	v
ebx	match.S	/^        mov     %ebx,%eax               \/* result = eax = best_len *\/$/;"	v
ebx	os2/match32.asm	/^        add     ebx,2$/;"	v
ebx	os2/match32.asm	/^        lea     ebx,window$/;"	v
ebx	os2/match32.asm	/^        push    ebx                     ; esp$/;"	v
ebx	os2/match32.asm	/^;       best_len     equ ebx$/;"	v
ebx	win32/crc_i386.asm	/^                movzx   ebx,ah                 ; tmp = (c>>8) & 0xFF$/;"	v
ebx	win32/crc_i386.asm	/^                movzx   ebx,al                 ; tmp = (c>>16) & 0xFF$/;"	v
ebx	win32/crc_i386.asm	/^                movzx   ebx,al                 ; tmp = c & 0xFF$/;"	v
ebx	win32/gvmat64.asm	/^        mov [chainlenwmask], ebx$/;"	v
ebx	win32/gvmat64.asm	/^        mov ebx, max_chain_length$/;"	v
ebx	win32/gvmat64.asm	/^        movzx   ebx, word ptr [r9 + rax - 1]$/;"	v
ebx	win32/gvmat64.asm	/^        movzx ebx, word ptr [r9 + r11 - 1]$/;"	v
ebx	win32/gvmat64.asm	/^        or  ebx, eax$/;"	v
ebx	win32/gvmat64.asm	/^        shr ebx, 2$/;"	v
ebx	win32/gvmat64.asm	/^;scanend         equ  rsp + xx - LocalVarsSize   ; last two bytes of string use ebx$/;"	v
ebx	win32/lm32_lcc.asm	/^        cmp     %ebx,%eax$/;"	v
ebx	win32/lm32_lcc.asm	/^        mov     %ebx,%eax$/;"	v
ebx	win32/lm32_lcc.asm	/^        push    %ebx$/;"	v
ebx	win32/match32.asm	/^        push    ebx                     ; esp$/;"	v
ebx	win32/match32.asm	/^;       best_len     equ ebx$/;"	v
echo	ttyio.c	/^int echo(opt)$/;"	f
echofd	ttyio.c	/^   static int echofd=(-1);      \/* file descriptor whose echo is off *\/$/;"	v	file:
echoff	ttyio.h	104;"	d
echoff	ttyio.h	110;"	d
echoff	ttyio.h	116;"	d
echoff	ttyio.h	123;"	d
echoff	ttyio.h	147;"	d
echoff	ttyio.h	159;"	d
echoff	ttyio.h	164;"	d
echoff	ttyio.h	176;"	d
echoff	ttyio.h	185;"	d
echoff	ttyio.h	197;"	d
echoff	ttyio.h	224;"	d
echoff	ttyio.h	82;"	d
echoff	ttyio.h	89;"	d
echoff	ttyio.h	97;"	d
echon	ttyio.h	105;"	d
echon	ttyio.h	111;"	d
echon	ttyio.h	117;"	d
echon	ttyio.h	124;"	d
echon	ttyio.h	148;"	d
echon	ttyio.h	160;"	d
echon	ttyio.h	165;"	d
echon	ttyio.h	177;"	d
echon	ttyio.h	186;"	d
echon	ttyio.h	198;"	d
echon	ttyio.h	225;"	d
echon	ttyio.h	83;"	d
echon	ttyio.h	90;"	d
echon	ttyio.h	98;"	d
ecx	crc_i386.S	/^                testl   %ecx, %ecx$/;"	v
ecx	win32/crc_lcc.asm	/^	movl	%ecx,%edx$/;"	v
ecx	win32/crc_lcc.asm	/^	testl	%ecx,%ecx$/;"	v
ed	vms/vms.h	/^    ush tag_ed; ush len_ed;     byte ed[ATR$S_EXPDATE];$/;"	m	struct:__anon23	access:public
ed	vms/vms.h	/^    ush tag_ed; ush len_ed;     byte ed[ATR$S_EXPDATE];$/;"	m	struct:__anon24	access:public
edi	match.S	/^        mov     %edi,%eax               \/* ax = scan+2 *\/$/;"	v
edi	match.S	/^        sub     %edi,%eax           \/* eax = len *\/$/;"	v
edi	match.S	/^        xchg    %edi,%eax           \/* edi = scan+2, eax = end of scan *\/$/;"	v
edi	os2/match32.asm	/^        mov     eax,edi                 ; eax = scan+2$/;"	v
edi	os2/match32.asm	/^        push    edi                     ; esp+8$/;"	v
edi	os2/match32.asm	/^        xchg    eax,edi                 ; edi = scan+2, eax = end of scan$/;"	v
edi	os2/match32.asm	/^;       scan         equ edi$/;"	v
edi	win32/gvmat64.asm	/^        cmovng ebp,edi$/;"	v
edi	win32/gvmat64.asm	/^        cmp edi, esi$/;"	v
edi	win32/gvmat64.asm	/^        mov edi, prev_length$/;"	v
edi	win32/gvmat64.asm	/^        xor edi,edi$/;"	v
edi	win32/lm32_lcc.asm	/^        mov     %edi,%eax$/;"	v
edi	win32/lm32_lcc.asm	/^        push    %edi$/;"	v
edi	win32/lm32_lcc.asm	/^        sub     %edi,%eax$/;"	v
edi	win32/lm32_lcc.asm	/^        xchg    %edi,%eax$/;"	v
edi	win32/match32.asm	/^        mov     eax,edi                 ; eax = scan+2$/;"	v
edi	win32/match32.asm	/^        push    edi                     ; esp+8$/;"	v
edi	win32/match32.asm	/^        xchg    eax,edi                 ; edi = scan+2, eax = end of scan$/;"	v
edi	win32/match32.asm	/^;       scan         equ edi$/;"	v
edx	match.S	/^        cmp     %edx,%esi               \/* cur_match <= limit ? *\/$/;"	v
edx	match.S	/^        mov     %edx,%edi$/;"	v
edx	match.S	/^        sub     %edx,%edx              \/* limit = NIL *\/$/;"	v
edx	os2/match32.asm	/^        cmp     esi,edx                 ; cur_match <= limit ?$/;"	v
edx	os2/match32.asm	/^        mov     edx,strstart$/;"	v
edx	os2/match32.asm	/^        sub     edx,MAX_DIST            ; limit = strstart-MAX_DIST$/;"	v
edx	os2/match32.asm	/^        sub     edx,edx                 ; limit = NIL$/;"	v
edx	win32/crc_i386.asm	/^                xor     eax,edx                ; ..$/;"	v
edx	win32/crc_i386.asm	/^                xor     edx,[edi+ebx*4+2048]   ;  ^ table[256*2+tmp]$/;"	v
edx	win32/crc_lcc.asm	/^	movl	%edx,%ecx$/;"	v
edx	win32/gvmat64.asm	/^        mov [chainlenwmask], edx$/;"	v
edx	win32/gvmat64.asm	/^        mov edx, [chainlenwmask]$/;"	v
edx	win32/gvmat64.asm	/^        sub edx, 00010000h$/;"	v
edx	win32/lm32_lcc.asm	/^        cmp     %edx,%esi$/;"	v
edx	win32/lm32_lcc.asm	/^        mov     %edx,%edi$/;"	v
edx	win32/lm32_lcc.asm	/^        sub     %edx,%edx$/;"	v
edx	win32/match32.asm	/^        cmp     esi,edx                 ; cur_match <= limit ?$/;"	v
edx	win32/match32.asm	/^        mov     edx,_strstart$/;"	v
edx	win32/match32.asm	/^        sub     edx,MAX_DIST            ; limit = strstart-MAX_DIST$/;"	v
edx	win32/match32.asm	/^        sub     edx,edx                 ; limit = NIL$/;"	v
ef_scan_ut_time	zipfile.c	/^local int ef_scan_ut_time(ef_buf, ef_len, ef_is_cent, z_utim)$/;"	f
efah	win32/gvmat64.asm	/^        mov eax,07efah ; MAX_DIST = (WSIZE-MIN_LOOKAHEAD) (0x8000-(3+8+1))$/;"	v
efined	amiga/deflate.a	/^;   CPU020     if defined, use 68020 instructions always.$/;"	v
efined	amiga/deflate.a	/^;   CPUTEST    if defined, check at runtime for CPU type.  Another symbol$/;"	v
efined	amiga/match_68.a	/^;   CPU020     if defined, use 68020 instructions always$/;"	v
efined	amiga/match_68.a	/^;   CPUTEST    if defined, check at runtime for CPU type.  Another symbol$/;"	v
efined	amiga/match_68.a	/^;   WSIZE      if defined, determines the sliding window size for deflate;$/;"	v
efined	human68k/deflate.s	/^;   CPU020     if defined, use 68020 instructions always.$/;"	v
efined	human68k/deflate.s	/^;   CPUTEST    if defined, check at runtime for CPU type.  Another symbol$/;"	v
eflate	amiga/match_68.a	/^;   WSIZE      if defined, determines the sliding window size for deflate;$/;"	v
elems	trees.c	/^    int     elems;               \/* max number of elements in the tree *\/$/;"	m	struct:tree_desc	file:	access:public
emx	proginfo/infozip.who	/^Christian Spieler       spieler@ikp.tu-darmstadt.de     VMS, MSDOS, emx, djgpp,$/;"	v
enable_permute	fileio.c	/^int enable_permute = 1;                     \/* yes - return options first *\/$/;"	v
enabled	msdos/match.asm	/^; The security tests should remain enabled, when a new C compiler$/;"	v
encr_passwd	api.c	/^int encr_passwd(int modeflag, char *pwbuf, int size, const char *zfn)$/;"	f	signature:(int modeflag, char *pwbuf, int size, const char *zfn)
encryption	README.CR	/^For more serious encryption, check into PGP (Pretty Good Privacy), a$/;"	v
endif	msdos/crc_i86.asm	/^endif   ;?@CodeSize$/;"	v
endif	msdos/crc_i86.asm	/^endif   ;?Use_286_code$/;"	v
endif	msdos/crc_i86.asm	/^endif   ;?__186$/;"	v
endif	msdos/crc_i86.asm	/^endif   ;?__286$/;"	v
endif	msdos/crc_i86.asm	/^endif   ;?__386$/;"	v
endif	msdos/crc_i86.asm	/^endif   ;?__486$/;"	v
endif	msdos/crc_i86.asm	/^endif   ;?__586$/;"	v
endif	msdos/crc_i86.asm	/^endif   ;?__686$/;"	v
endif	msdos/crc_i86.asm	/^endif ; !NO_16_BIT_LOADS$/;"	v
endif	msdos/crc_i86.asm	/^endif ; !NO_UNROLLED_LOOPS$/;"	v
endif	msdos/crc_i86.asm	/^endif ;!USE_ZLIB$/;"	v
endif	msdos/crc_i86.asm	/^endif$/;"	v
endif	msdos/match.asm	/^endif   ;?@CodeSize$/;"	v
endif	msdos/match.asm	/^endif   ;?Use_286_code$/;"	v
endif	msdos/match.asm	/^endif   ;?__186$/;"	v
endif	msdos/match.asm	/^endif   ;?__286$/;"	v
endif	msdos/match.asm	/^endif   ;?__386$/;"	v
endif	msdos/match.asm	/^endif   ;?__486$/;"	v
endif	msdos/match.asm	/^endif   ;?__586$/;"	v
endif	msdos/match.asm	/^endif$/;"	v
endmark	cmsmvs/mvs.h	/^char    *endmark = "\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF";$/;"	v
endon_error	vms/cvthelp.tpu	/^   endon_error;$/;"	v
endp	msdos/match.asm	/^_match_init endp$/;"	v
entries	zip.txt	/^              the paths of entries, including directories, are stored as usual$/;"	v
entry	zip.txt	/^       is written for the entry, but for a stream the size of the data is  not$/;"	v
envargs	util.c	/^void envargs(Pargc, Pargv, envstr, envstr2)$/;"	f
environment	unix/README.OS390	/^XPG4, build environment, a Unix-style filesystem (called HFS), and$/;"	v
eofile	deflate.c	/^local int           eofile;        \/* flag set at end of input file *\/$/;"	v
equ	amiga/deflate.a	/^;HASH_BITS      equ     15$/;"	v
equ	amiga/deflate.a	/^HASH_BITS       equ     14      ; default -- MEDIUM_MEM$/;"	v
equ	amiga/deflate.a	/^Sizeof_config   equ     8$/;"	v	typeref:struct:Sizeof_config
equ	human68k/deflate.s	/^;HASH_BITS      equ     15$/;"	v
equ	human68k/deflate.s	/^HASH_BITS       equ     14      ; default -- MEDIUM_MEM$/;"	v
equ	human68k/deflate.s	/^Sizeof_config   equ     8$/;"	v	typeref:struct:Sizeof_config
equ	msdos/match.asm	/^        WSIZE         equ 32768         ; keep in sync with zip.h !$/;"	v
equ	msdos/match.asm	/^        prev    equ 0         ; offset forced to zero$/;"	v
equ	os2/match32.asm	/^        WSIZE         equ 32768         ; keep in sync with zip.h !$/;"	v
equ	win32/gvmat64.asm	/^ LocalVarsSize   equ 72$/;"	v
equ	win32/gvmat64.asm	/^Lookahead       equ [ rcx + dsLookahead] ; 0ffffffffh on infozip$/;"	v
equ	win32/match32.asm	/^        WSIZE         equ 32768         ; keep in sync with zip.h !$/;"	v
equivalent	amiga/match_68.a	/^;               make sure that this module is assembled with an equivalent$/;"	v
errbuf	globals.c	/^char errbuf[FNMAX+4081];$/;"	v
errbuf	vms/cmdline.c	/^char errbuf[ FNMAX+ 81];        \/* Error message buffer. *\/$/;"	v
errmess	acorn/riscos.h	/^  char errmess[252];$/;"	m	struct:__anon7	access:public
errnum	acorn/riscos.h	/^  int errnum;$/;"	m	struct:__anon7	access:public
error	zip.c	/^void error(h)$/;"	f
error	zip.h	614;"	d
error_level	macos/source/macos.c	/^int error_level;   \/* used only in ziperr() *\/$/;"	v
es	msdos/match.asm	/^        mov     ax,es:[bx+di-3]         ; ax = scan[best_len-1..best_len]$/;"	v
esi	crc_i386.S	/^                testl   %esi, %esi           \/* >   return 0;                *\/$/;"	v
esi	match.S	/^        mov     %esi,_match_start       \/* match_start = cur_match *\/$/;"	v
esi	os2/match32.asm	/^        add     esi,window_off          ; esi = match$/;"	v
esi	os2/match32.asm	/^        cmp     esi,edx                 ; cur_match <= limit ?$/;"	v
esi	os2/match32.asm	/^        mov     esi,eax                 ; cur_match$/;"	v
esi	os2/match32.asm	/^        push    esi                     ; esp+4$/;"	v
esi	os2/match32.asm	/^;       match        equ esi$/;"	v
esi	win32/crc_i386.asm	/^                add     esi, 4*dwPtrIncr       ; ((ulg *)buf) += dwPtrIncr$/;"	v
esi	win32/crc_lcc.asm	/^	testl	%esi,%esi$/;"	v
esi	win32/gvmat64.asm	/^        mov esi, good_match$/;"	v
esi	win32/lm32_lcc.asm	/^        mov     %esi,_match_start$/;"	v
esi	win32/lm32_lcc.asm	/^        push    %esi$/;"	v
esi	win32/match32.asm	/^        cmp     esi,edx                 ; cur_match <= limit ?$/;"	v
esi	win32/match32.asm	/^        lea     esi,_window[esi+2]      ; esi = match$/;"	v
esi	win32/match32.asm	/^        mov     esi,cur_match$/;"	v
esi	win32/match32.asm	/^        push    esi                     ; esp+4$/;"	v
esi	win32/match32.asm	/^;       match        equ esi$/;"	v
esired	vms/NOTES.TXT	/^   Symlink support can be disabled at build-time, if desired, by$/;"	v
esp	win32/crc_lcc.asm	/^	movl	%esp,%ebp$/;"	v
estTicksToFinish	macos/source/macos.c	/^long    estTicksToFinish;$/;"	v
eval	unix/configure	/^  elif eval "$CC -c _match.s >\/dev\/null 2>\/dev\/null" && [ -f _match.o ]; then$/;"	v
ex2in	acorn/acornzip.c	/^char *ex2in(x, isdir, pdosflag)$/;"	f
ex2in	amiga/amigazip.c	/^char *ex2in(x, isdir, pdosflag)$/;"	f
ex2in	aosvs/aosvs.c	/^char *ex2in(x, isdir, pdosflag)$/;"	f
ex2in	atari/atari.c	/^char *ex2in(x, isdir, pdosflag)$/;"	f
ex2in	atheos/atheos.c	/^char *ex2in(x, isdir, pdosflag)$/;"	f
ex2in	beos/beos.c	/^char *ex2in(x, isdir, pdosflag)$/;"	f
ex2in	cmsmvs/cmsmvs.c	/^char *ex2in(x, isdir, pdosflag)$/;"	f
ex2in	human68k/human68k.c	/^char *ex2in(x, isdir, pdosflag)$/;"	f
ex2in	macos/source/macos.c	/^char *ex2in(char *externalFilen, int isdir, int *pdosflag)$/;"	f	signature:(char *externalFilen, int isdir, int *pdosflag)
ex2in	msdos/msdos.c	/^char *ex2in(x, isdir, pdosflag)$/;"	f
ex2in	novell/Netware.c	/^char *ex2in(x, isdir, pdosflag)$/;"	f
ex2in	os2/os2.c	/^char *ex2in(x, isdir, pdosflag)$/;"	f
ex2in	qdos/qfileio.c	/^char *ex2in(x, isdir, pdosflag)$/;"	f
ex2in	tandem/tanzip.c	/^  char *ex2in(x, isdir, pdosflag)$/;"	f
ex2in	theos/theos.c	/^char *ex2in(x, isdir, pdosflag)$/;"	f
ex2in	tops20/tops20.c	/^char *ex2in(x, isdir, pdosflag)$/;"	f
ex2in	unix/unix.c	/^char *ex2in(x, isdir, pdosflag)$/;"	f
ex2in	vms/vmszip.c	/^char *ex2in( char *x, int isdir, int *pdosflag)$/;"	f	signature:( char *x, int isdir, int *pdosflag)
ex2in	win32/win32zip.c	/^char *ex2in(x, isdir, pdosflag)$/;"	f
ex2inw	win32/win32zip.c	/^wchar_t *ex2inw(xw, isdir, pdosflag)$/;"	f
example	vms/NOTES.TXT	/^regarding LOCAL_UNZIP or LOCAL_ZIP, as appropriate.)  For example, using$/;"	v
exec_addr	acorn/riscos.h	/^  unsigned int exec_addr;$/;"	m	struct:__anon9	access:public
execaddr	acorn/riscos.h	/^  unsigned int  execaddr;$/;"	m	struct:__anon10	access:public
executables	INSTALL	/^     most users define foreign command symbols for the Zip executables, like$/;"	v
execute	tandem/tandem.h	/^  unsigned execute   : 3;$/;"	m	struct:nsk_file_attrs_def	access:public
exist	proginfo/fileinfo.cms	/^     the block descriptor word).  In CMS, BDWs and RDWs do not exist,$/;"	v
exit	zipnote.c	69;"	d	file:
exit	zipsplit.c	41;"	d	file:
expand_args	util.c	/^void expand_args(argcp, argvp)$/;"	f
explicit_dev	vms/vmszip.c	/^local int explicit_dev( char *file_spec)$/;"	f	signature:( char *file_spec)
ext	zip.h	/^  ush nam, ext, cext, com;      \/* offset of ext must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
extension	README	/^file using an extension, such as .z02 as in the file name archive.z02, that$/;"	v
extension	TODO	/^- For an sfx file without extension, "zip -A sfx" works but "zip sfx -A"$/;"	v
extent	tailor.h	/^   typedef size_t extent;$/;"	t
extent	tailor.h	/^   typedef unsigned int extent;$/;"	t
extra	zip.h	/^  char *extra;                  \/* Extra field (set only if ext != 0) *\/$/;"	m	struct:zlist	access:public
extra_base	trees.c	/^    int     extra_base;          \/* base index for extra_bits *\/$/;"	m	struct:tree_desc	file:	access:public
extra_bits	trees.c	/^    int     near *extra_bits;    \/* extra bits for each code or NULL *\/$/;"	m	struct:tree_desc	file:	access:public
extra_blbits	trees.c	/^local int near extra_blbits[BL_CODES]\/* extra bits for each bit length code *\/$/;"	v
extra_block	acorn/riscos.h	/^} extra_block;$/;"	t	typeref:struct:__anon10
extra_data_size	aosvs/aosvs.c	/^     char           extra_data_size[2]; \/* size of rest, in Intel little-endian order *\/$/;"	m	struct:zextrafld	file:	access:public
extra_dbits	trees.c	/^local int near extra_dbits[D_CODES] \/* extra bits for each distance code *\/$/;"	v
extra_fields	globals.c	/^int extra_fields = 1;         \/* 0=create minimum, 1=don't copy old, 2=keep old *\/$/;"	v
extra_header_id	aosvs/aosvs.c	/^     char           extra_header_id[2]; \/* set to VS - in theory, an int *\/$/;"	m	struct:zextrafld	file:	access:public
extra_lbits	trees.c	/^local int near extra_lbits[LENGTH_CODES] \/* extra bits for each length code *\/$/;"	v
extra_rev	aosvs/aosvs.c	/^     unsigned char  extra_rev;          \/* set to 10 for rev 1.0 *\/$/;"	m	struct:zextrafld	file:	access:public
extra_sentinel	aosvs/aosvs.c	/^     char           extra_sentinel[4];  \/* set to FCI w\/ trailing null *\/$/;"	m	struct:zextrafld	file:	access:public
exts2swap	acorn/riscos.c	/^char *exts2swap = NULL; \/* Extensions to swap (actually, directory names) *\/$/;"	v
f	ttyio.c	/^    int f;                      \/* file descriptor from which to read *\/$/;"	v
f	ttyio.c	/^    int f;                    \/* file descriptor for which to turn echo off *\/$/;"	v
f	ttyio.c	/^    int f;    \/* file descriptor from which to read (must be open already) *\/$/;"	v
f	vms/cvthelp.tpu	/^        ,f$/;"	v
fCRLF_LF	api.h	/^BOOL fCRLF_LF;          \/* Translate CR\/LF to LF *\/$/;"	m	struct:__anon30	access:public
fCRLF_LF	windll/windll.txt	/^BOOL fCRLF_LF;          \/* Translate CR\/LF to LF *\/$/;"	m	struct:__anon18	file:	access:public
fComment	api.h	/^BOOL fComment;          \/* Put comment in zip file *\/$/;"	m	struct:__anon30	access:public
fComment	windll/windll.txt	/^BOOL fComment;          \/* Put comment in zip file *\/$/;"	m	struct:__anon18	file:	access:public
fDeleteEntries	api.h	/^BOOL fDeleteEntries;    \/* Delete files from zip file *\/$/;"	m	struct:__anon30	access:public
fDeleteEntries	windll/windll.txt	/^BOOL fDeleteEntries;    \/* Delete files from zip file *\/$/;"	m	struct:__anon18	file:	access:public
fEA	os2/os2zip.c	/^  BYTE fEA;                   \/* 0 *\/$/;"	m	struct:__anon11	file:	access:public
fEA	os2/os2zip.c	/^  BYTE fEA;$/;"	m	struct:__anon14	file:	access:public
fEncrypt	api.h	/^BOOL fEncrypt;          \/* encrypt files *\/$/;"	m	struct:__anon30	access:public
fEncrypt	windll/windll.txt	/^BOOL fEncrypt;          \/* encrypt files *\/$/;"	m	struct:__anon18	file:	access:public
fEncryption	api.h	/^    BOOL fEncryption;       \/* TRUE if encryption enabled, FALSE otherwise *\/$/;"	m	struct:_ZpVer	access:public
fEncryption	api.h	/^BOOL fEncryption;       \/* TRUE if encryption supported, else FALSE.$/;"	m	struct:__anon30	access:public
fEncryption	windll/windll.txt	/^    BOOL fEncryption;       \/* TRUE if encryption enabled, FALSE otherwise *\/$/;"	m	struct:_ZpVer	file:	access:public
fEncryption	windll/windll.txt	/^BOOL fEncryption;       \/* TRUE if encryption supported, else FALSE.$/;"	m	struct:__anon18	file:	access:public
fExcludeDate	api.h	/^BOOL fExcludeDate;      \/* Exclude files newer than specified date *\/$/;"	m	struct:__anon30	access:public
fExcludeDate	windll/windll.txt	/^BOOL fExcludeDate;      \/* Exclude files earlier than specified date *\/$/;"	m	struct:__anon18	file:	access:public
fExtra	api.h	/^BOOL fExtra;            \/* Exclude extra attributes *\/$/;"	m	struct:__anon30	access:public
fExtra	windll/windll.txt	/^BOOL fExtra;            \/* Exclude extra attributes *\/$/;"	m	struct:__anon18	file:	access:public
fForce	api.h	/^BOOL fForce;            \/* Make entries using DOS names (k for Katz) *\/$/;"	m	struct:__anon30	access:public
fForce	windll/windll.txt	/^BOOL fForce;            \/* Make entries using DOS names (k for Katz) *\/$/;"	m	struct:__anon18	file:	access:public
fFreshen	api.h	/^BOOL fFreshen;          \/* Freshen zip file--overwrite only *\/$/;"	m	struct:__anon30	access:public
fFreshen	windll/windll.txt	/^BOOL fFreshen;          \/* Freshen zip file--overwrite only *\/$/;"	m	struct:__anon18	file:	access:public
fGrow	api.h	/^BOOL fGrow;             \/* Allow appending to a zip file *\/$/;"	m	struct:__anon30	access:public
fGrow	windll/windll.txt	/^BOOL fGrow;             \/* Allow appending to a zip file *\/$/;"	m	struct:__anon18	file:	access:public
fIncludeDate	api.h	/^BOOL fIncludeDate;      \/* Include only files newer than specified date *\/$/;"	m	struct:__anon30	access:public
fIncludeDate	windll/windll.txt	/^BOOL fIncludeDate;      \/* Include only files earlier than specified date *\/$/;"	m	struct:__anon18	file:	access:public
fJunkDir	api.h	/^BOOL fJunkDir;          \/* Junk directory names *\/$/;"	m	struct:__anon30	access:public
fJunkDir	windll/windll.txt	/^BOOL fJunkDir;          \/* Junk directory names *\/$/;"	m	struct:__anon18	file:	access:public
fJunkSFX	api.h	/^BOOL fJunkSFX;          \/* Junk SFX prefix *\/$/;"	m	struct:__anon30	access:public
fJunkSFX	windll/windll.txt	/^BOOL fJunkSFX;          \/* Junk SFX prefix *\/$/;"	m	struct:__anon18	file:	access:public
fLF_CRLF	api.h	/^BOOL fLF_CRLF;          \/* Translate LF to CR\/LF *\/$/;"	m	struct:__anon30	access:public
fLF_CRLF	windll/windll.txt	/^BOOL fLF_CRLF;          \/* Translate LF to CR\/LF *\/$/;"	m	struct:__anon18	file:	access:public
fLatestTime	api.h	/^BOOL fLatestTime;       \/* Set zip file time to time of latest file in it *\/$/;"	m	struct:__anon30	access:public
fLatestTime	windll/windll.txt	/^BOOL fLatestTime;       \/* Set zip file time to time of latest file in it *\/$/;"	m	struct:__anon18	file:	access:public
fLevel	api.h	/^char fLevel;            \/* Compression level (0 - 9) *\/$/;"	m	struct:__anon30	access:public
fLevel	windll/windll.txt	/^char fLevel;            \/* Compression level (0 - 9) *\/$/;"	m	struct:__anon18	file:	access:public
fMove	api.h	/^BOOL fMove;             \/* Delete files added or updated in zip file *\/$/;"	m	struct:__anon30	access:public
fMove	windll/windll.txt	/^BOOL fMove;             \/* Delete files added or updated in zip file *\/$/;"	m	struct:__anon18	file:	access:public
fNoDirEntries	api.h	/^BOOL fNoDirEntries;     \/* Do not add directory entries *\/$/;"	m	struct:__anon30	access:public
fNoDirEntries	windll/windll.txt	/^BOOL fNoDirEntries;     \/* Do not add directory entries *\/$/;"	m	struct:__anon18	file:	access:public
fNo_int64	api.c	/^BOOL fNo_int64 = FALSE; \/* flag for DLLSERVICE_NO_INT64 *\/$/;"	v
fOffsets	api.h	/^BOOL fOffsets;          \/* Update archive offsets for SFX files *\/$/;"	m	struct:__anon30	access:public
fOffsets	windll/windll.txt	/^BOOL fOffsets;          \/* Update archive offsets for SFX files *\/$/;"	m	struct:__anon18	file:	access:public
fP	man/zip.1	/^\\fBk\\fP (kilobytes), \\fBm\\fP (megabytes), \\fBg\\fP (gigabytes), or \\fBt\\fP$/;"	f
fPrivilege	api.h	/^BOOL fPrivilege;        \/* Use privileges (WIN32 only) *\/$/;"	m	struct:__anon30	access:public
fPrivilege	windll/windll.txt	/^BOOL fPrivilege;        \/* Use privileges (WIN32 only) *\/$/;"	m	struct:__anon18	file:	access:public
fQuiet	api.h	/^BOOL fQuiet;            \/* Quiet operation *\/$/;"	m	struct:__anon30	access:public
fQuiet	windll/windll.txt	/^BOOL fQuiet;            \/* Quiet operation *\/$/;"	m	struct:__anon18	file:	access:public
fRecurse	api.h	/^int  fRecurse;          \/* Recurse into subdirectories. 1 => -r, 2 => -R *\/$/;"	m	struct:__anon30	access:public
fRecurse	windll/windll.txt	/^int  fRecurse;          \/* Recurse into subdirectories. 1 => -r, 2 => -R *\/$/;"	m	struct:__anon18	file:	access:public
fRepair	api.h	/^int  fRepair;           \/* Repair archive. 1 => -F, 2 => -FF *\/$/;"	m	struct:__anon30	access:public
fRepair	windll/windll.txt	/^int  fRepair;           \/* Repair archive. 1 => -F, 2 => -FF *\/$/;"	m	struct:__anon18	file:	access:public
fSuffix	api.h	/^BOOL fSuffix;           \/* include suffixes (not implemented) *\/$/;"	m	struct:__anon30	access:public
fSuffix	windll/windll.txt	/^BOOL fSuffix;           \/* include suffixes (not implemented in WiZ) *\/$/;"	m	struct:__anon18	file:	access:public
fSystem	api.h	/^BOOL fSystem;           \/* include system and hidden files *\/$/;"	m	struct:__anon30	access:public
fSystem	windll/windll.txt	/^BOOL fSystem;           \/* include system and hidden files *\/$/;"	m	struct:__anon18	file:	access:public
fTemp	api.h	/^BOOL fTemp;             \/* Use temporary directory '-b' during zipping *\/$/;"	m	struct:__anon30	access:public
fTemp	windll/windll.txt	/^BOOL fTemp;             \/* Use temporary directory '-b' during zipping *\/$/;"	m	struct:__anon18	file:	access:public
fUpdate	api.h	/^BOOL fUpdate;           \/* Update zip file--overwrite only if newer *\/$/;"	m	struct:__anon30	access:public
fUpdate	windll/windll.txt	/^BOOL fUpdate;           \/* Update zip file--overwrite only if newer *\/$/;"	m	struct:__anon18	file:	access:public
fVerbose	api.h	/^BOOL fVerbose;          \/* Mention oddities in zip file structure *\/$/;"	m	struct:__anon30	access:public
fVerbose	windll/windll.txt	/^BOOL fVerbose;          \/* Mention oddities in zip file structure *\/$/;"	m	struct:__anon18	file:	access:public
fVolume	api.h	/^BOOL fVolume;           \/* Include volume label *\/$/;"	m	struct:__anon30	access:public
fVolume	windll/windll.txt	/^BOOL fVolume;           \/* Include volume label *\/$/;"	m	struct:__anon18	file:	access:public
f_ibuf	zipup.c	/^    local char *f_ibuf = NULL;$/;"	v
f_ibuf	zipup.c	/^  local char *f_ibuf = NULL;$/;"	v
f_obuf	zipup.c	/^    local char *f_obuf = NULL;$/;"	v
f_obuf	zipup.c	/^  local char *f_obuf = NULL;$/;"	v
fab	vms/vms_im.c	/^    struct FAB *fab;$/;"	m	struct:user_context	typeref:struct:user_context::FAB	file:	access:public
fab	vms/vmszip.c	/^  struct FAB fab;$/;"	m	struct:zdirent	typeref:struct:zdirent::FAB	file:	access:public
fact	proginfo/txtvsbin.txt	/^data.  "Polluted" plain text may, in fact, be regarded as binary, on$/;"	v
far	api.h	31;"	d
far	msdos/match.asm	/^        extrn   _exit : far             ; 'far' for large model$/;"	v
far	tailor.h	469;"	d
far	tailor.h	473;"	d
far	tailor.h	481;"	d
far	win32/gvmat64.asm	/^;;; have so far, then forget it and return to the lookup loop.$/;"	v
far	windll/structs.h	20;"	d
farfree	tailor.h	490;"	d
farmalloc	tailor.h	489;"	d
fastest	amiga/deflate.a	/^                dc.w    4,4,8,4         ; level 1: fastest, loosest compression$/;"	v
fastest	human68k/deflate.s	/^                dc.w    4,4,8,4         ; level 1: fastest, loosest compression$/;"	v
fat$b_bktsize	vms/vmsdefs.h	/^  unsigned char fat$b_bktsize;          \/* bucket size in blocks            *\/$/;"	m	struct:fatdef	access:public
fat$b_rattrib	vms/vmsdefs.h	157;"	d
fat$b_rtype	vms/vmsdefs.h	154;"	d
fat$b_vfcsize	vms/vmsdefs.h	/^  unsigned char fat$b_vfcsize;          \/* # of control bytes in VFC record *\/$/;"	m	struct:fatdef	access:public
fat$fill	vms/vmsdefs.h	/^  char fat$fill[8];$/;"	m	struct:fatdef	access:public
fat$l_efblk	vms/vmsdefs.h	166;"	d
fat$l_hiblk	vms/vmsdefs.h	163;"	d
fat$r_efblk_overlay	vms/vmsdefs.h	/^  } fat$r_efblk_overlay;$/;"	m	struct:fatdef	access:public
fat$r_hiblk_overlay	vms/vmsdefs.h	/^  } fat$r_hiblk_overlay;$/;"	m	struct:fatdef	access:public
fat$r_rattrib_overlay	vms/vmsdefs.h	/^  } fat$r_rattrib_overlay;$/;"	m	struct:fatdef	access:public
fat$r_rtype_overlay	vms/vmsdefs.h	/^  } fat$r_rtype_overlay;$/;"	m	struct:fatdef	access:public
fat$v_fileorg	vms/vmsdefs.h	156;"	d
fat$v_fortrancc	vms/vmsdefs.h	158;"	d
fat$v_impliedcc	vms/vmsdefs.h	159;"	d
fat$v_msbrcw	vms/vmsdefs.h	162;"	d
fat$v_nospan	vms/vmsdefs.h	161;"	d
fat$v_printcc	vms/vmsdefs.h	160;"	d
fat$v_rtype	vms/vmsdefs.h	155;"	d
fat$w_defext	vms/vmsdefs.h	/^  unsigned short int fat$w_defext;      \/* default extend quantity          *\/$/;"	m	struct:fatdef	access:public
fat$w_efblkh	vms/vmsdefs.h	167;"	d
fat$w_efblkl	vms/vmsdefs.h	168;"	d
fat$w_ffbyte	vms/vmsdefs.h	/^  unsigned short int fat$w_ffbyte;      \/* first free byte in EFBLK         *\/$/;"	m	struct:fatdef	access:public
fat$w_gbc	vms/vmsdefs.h	/^  unsigned short int fat$w_gbc;         \/* global buffer count              *\/$/;"	m	struct:fatdef	access:public
fat$w_hiblkh	vms/vmsdefs.h	164;"	d
fat$w_hiblkl	vms/vmsdefs.h	165;"	d
fat$w_maxrec	vms/vmsdefs.h	/^  unsigned short int fat$w_maxrec;      \/* maximum record size in bytes     *\/$/;"	m	struct:fatdef	access:public
fat$w_rsize	vms/vmsdefs.h	/^  unsigned short int fat$w_rsize;       \/* record size in bytes             *\/$/;"	m	struct:fatdef	access:public
fat$w_versions	vms/vmsdefs.h	/^  unsigned short int fat$w_versions;$/;"	m	struct:fatdef	access:public
fatal_err	msdos/match.asm	/^fatal_err:                              ; (quiet) emergency stop:$/;"	v
fatdef	vms/vmsdefs.h	/^struct fatdef {$/;"	s
fatdef::fat$b_bktsize	vms/vmsdefs.h	/^  unsigned char fat$b_bktsize;          \/* bucket size in blocks            *\/$/;"	m	struct:fatdef	access:public
fatdef::fat$b_vfcsize	vms/vmsdefs.h	/^  unsigned char fat$b_vfcsize;          \/* # of control bytes in VFC record *\/$/;"	m	struct:fatdef	access:public
fatdef::fat$fill	vms/vmsdefs.h	/^  char fat$fill[8];$/;"	m	struct:fatdef	access:public
fatdef::fat$r_efblk_overlay	vms/vmsdefs.h	/^  } fat$r_efblk_overlay;$/;"	m	struct:fatdef	access:public
fatdef::fat$r_hiblk_overlay	vms/vmsdefs.h	/^  } fat$r_hiblk_overlay;$/;"	m	struct:fatdef	access:public
fatdef::fat$r_rattrib_overlay	vms/vmsdefs.h	/^  } fat$r_rattrib_overlay;$/;"	m	struct:fatdef	access:public
fatdef::fat$r_rtype_overlay	vms/vmsdefs.h	/^  } fat$r_rtype_overlay;$/;"	m	struct:fatdef	access:public
fatdef::fat$w_defext	vms/vmsdefs.h	/^  unsigned short int fat$w_defext;      \/* default extend quantity          *\/$/;"	m	struct:fatdef	access:public
fatdef::fat$w_ffbyte	vms/vmsdefs.h	/^  unsigned short int fat$w_ffbyte;      \/* first free byte in EFBLK         *\/$/;"	m	struct:fatdef	access:public
fatdef::fat$w_gbc	vms/vmsdefs.h	/^  unsigned short int fat$w_gbc;         \/* global buffer count              *\/$/;"	m	struct:fatdef	access:public
fatdef::fat$w_maxrec	vms/vmsdefs.h	/^  unsigned short int fat$w_maxrec;      \/* maximum record size in bytes     *\/$/;"	m	struct:fatdef	access:public
fatdef::fat$w_rsize	vms/vmsdefs.h	/^  unsigned short int fat$w_rsize;       \/* record size in bytes             *\/$/;"	m	struct:fatdef	access:public
fatdef::fat$w_versions	vms/vmsdefs.h	/^  unsigned short int fat$w_versions;$/;"	m	struct:fatdef	access:public
fbad	acorn/zipup.h	10;"	d
fbad	amiga/zipup.h	16;"	d
fbad	atari/zipup.h	13;"	d
fbad	atheos/zipup.h	16;"	d
fbad	beos/zipup.h	13;"	d
fbad	cmsmvs/zipup.h	12;"	d
fbad	human68k/zipup.h	10;"	d
fbad	macos/zipup.h	14;"	d
fbad	msdos/zipup.h	10;"	d
fbad	novell/zipup.h	10;"	d
fbad	os2/zipup.h	10;"	d
fbad	qdos/zipup.h	13;"	d
fbad	tandem/zipup.h	13;"	d
fbad	theos/zipup.h	13;"	d
fbad	tops20/zipup.h	12;"	d
fbad	unix/zipup.h	18;"	d
fbad	vms/zipup.h	15;"	d
fbad	win32/zipup.h	27;"	d
fc	trees.c	/^    } fc;$/;"	m	struct:ct_data	typeref:union:ct_data::__anon28	file:	access:public
fch$r_fch_union	vms/vmsdefs.h	/^  } fch$r_fch_union;$/;"	m	struct:fchdef	access:public
fch$v_associated	vms/vmsdefs.h	251;"	d
fch$v_badacl	vms/vmsdefs.h	261;"	d
fch$v_badblock	vms/vmsdefs.h	264;"	d
fch$v_contig	vms/vmsdefs.h	260;"	d
fch$v_contigb	vms/vmsdefs.h	258;"	d
fch$v_directory	vms/vmsdefs.h	263;"	d
fch$v_erase	vms/vmsdefs.h	267;"	d
fch$v_existence	vms/vmsdefs.h	252;"	d
fch$v_locked	vms/vmsdefs.h	259;"	d
fch$v_markdel	vms/vmsdefs.h	265;"	d
fch$v_nobackup	vms/vmsdefs.h	254;"	d
fch$v_nocharge	vms/vmsdefs.h	266;"	d
fch$v_nomove	vms/vmsdefs.h	270;"	d
fch$v_noshelvable	vms/vmsdefs.h	271;"	d
fch$v_readcheck	vms/vmsdefs.h	256;"	d
fch$v_scratch	vms/vmsdefs.h	269;"	d
fch$v_shelved	vms/vmsdefs.h	268;"	d
fch$v_spool	vms/vmsdefs.h	262;"	d
fch$v_vcc_state	vms/vmsdefs.h	250;"	d
fch$v_wascontig	vms/vmsdefs.h	253;"	d
fch$v_writcheck	vms/vmsdefs.h	257;"	d
fch$v_writeback	vms/vmsdefs.h	255;"	d
fchdef	vms/vmsdefs.h	/^struct fchdef  {$/;"	s
fchdef::fch$r_fch_union	vms/vmsdefs.h	/^  } fch$r_fch_union;$/;"	m	struct:fchdef	access:public
fcopy	fileio.c	/^int fcopy(f, g, n)$/;"	f
fcount	globals.c	/^extent fcount;                    \/* Count of files in list *\/$/;"	v
fdopen	cmsmvs/cmsmvs.h	72;"	d
features	README	/^can be used to discuss issues, request features, and is one place new betas$/;"	v
fexpel	fileio.c	/^struct flist far *fexpel(f)$/;"	f
ff_attrib	msdos/msdos.c	45;"	d	file:
ff_attrib	msdos/msdos.c	68;"	d	file:
ff_dir	msdos/msdos.c	/^   typedef struct _find   ff_dir;$/;"	t	typeref:struct:_find	file:
ff_dir	msdos/msdos.c	/^   typedef struct ffblk   ff_dir;$/;"	t	typeref:struct:ffblk	file:
ff_dir	msdos/msdos.c	/^   typedef struct find_t  ff_dir;$/;"	t	typeref:struct:find_t	file:
ff_fdate	msdos/msdos.c	43;"	d	file:
ff_fdate	msdos/msdos.c	66;"	d	file:
ff_ftime	msdos/msdos.c	44;"	d	file:
ff_ftime	msdos/msdos.c	67;"	d	file:
ff_name	msdos/msdos.c	42;"	d	file:
ff_name	msdos/msdos.c	65;"	d	file:
fffffffffffffef8h	win32/gvmat64.asm	/^        mov rdx, 0fffffffffffffef8h; -(MAX_MATCH_8)$/;"	v
ffile_size	zipfile.c	/^zoff_t ffile_size( file)$/;"	f
fhow	acorn/zipup.h	9;"	d
fhow	amiga/zipup.h	15;"	d
fhow	atari/zipup.h	12;"	d
fhow	atheos/zipup.h	15;"	d
fhow	beos/zipup.h	12;"	d
fhow	cmsmvs/zipup.h	9;"	d
fhow	human68k/zipup.h	9;"	d
fhow	macos/zipup.h	13;"	d
fhow	msdos/zipup.h	9;"	d
fhow	novell/zipup.h	9;"	d
fhow	os2/zipup.h	9;"	d
fhow	qdos/zipup.h	12;"	d
fhow	tandem/zipup.h	12;"	d
fhow	theos/zipup.h	12;"	d
fhow	tops20/zipup.h	11;"	d
fhow	unix/zipup.h	17;"	d
fhow	vms/zipup.h	48;"	d
fhow	vms/zipup.h	52;"	d
fhow	win32/zipup.h	26;"	d
fhow_id	vms/vms.c	/^int fhow_id = FHOW_ID;          \/* Callback id storage, in read. *\/$/;"	v
fhowb	cmsmvs/zipup.h	10;"	d
fid	novell/Netware.c	/^char        fid[100];$/;"	v
fields	WHATSNEW	/^  The new option -X- (negated -X) keeps any old extra fields, copying$/;"	v
file	INSTALL	/^     distribution file, in this case zip30.zip.  But since you read this,$/;"	v
file	WHATSNEW	/^  but instead of displaying them for each file, the dots track the total$/;"	v
file	WHERE	/^   unz552d2.zip      OS\/2 2\/3\/4.x (32-bit) DLL, header file, demo exe and docs$/;"	v
file	bzip2/install.txt	/^file, "bzlib.h", and the object library, typically "libbz2.a", except$/;"	v
file	proginfo/fileinfo.cms	/^     Each time you call fread() for a record I\/O file, fread() reads$/;"	v
file	proginfo/fileinfo.cms	/^     When you call the fldata() function for an open CMS minidisk file,$/;"	v
file	proginfo/txtvsbin.txt	/^a plain text file, without performing a heavy-duty semantic analysis on$/;"	v
file	proginfo/txtvsbin.txt	/^uniform results on any particular text file, no matter what alphabet$/;"	v
fileSpec	macos/source/macglob.h	/^    FSSpec          fileSpec;$/;"	m	struct:__anon17	access:public
file_arg	atari/atari.c	/^static char   fullpath[FILENAME_MAX], file_arg[FILENAME_MAX];$/;"	v	file:
file_binary	zipup.c	/^  local int file_binary = 0;        \/* first buf *\/$/;"	v
file_binary_final	zipup.c	/^  local int file_binary_final = 0;  \/* for bzip2 for entire file.  assume text until find binary *\/$/;"	v
file_method	trees.c	/^local int *file_method;     \/* pointer to DEFLATE or STORE *\/$/;"	v
file_outbuf	zipup.c	/^  local char file_outbuf[1024]; \/* output buffer for compression to file *\/$/;"	v
file_read	zipup.c	/^local unsigned file_read(buf, size)$/;"	f
file_sys_type	vms/vmszip.c	/^local int file_sys_type( char *path)$/;"	f	signature:( char *path)
file_type	trees.c	/^local ush *file_type;       \/* pointer to UNKNOWN, BINARY or ASCII *\/$/;"	v
filearg_count	zip.c	/^long filearg_count = 0;$/;"	v
filecode	tandem/tandem.h	/^  unsigned short filecode;  \/* 16 *\/$/;"	m	struct:nsk_file_attrs_def	access:public
filecompress	zipup.c	/^local zoff_t filecompress(z_entry, cmpr_method)$/;"	f
filelist	zip.c	/^struct filelist_struct *filelist = NULL;  \/* start of list *\/$/;"	v	typeref:struct:filelist_struct
filelist_struct	zip.c	/^struct filelist_struct {$/;"	s	file:
filelist_struct::name	zip.c	/^    char *name;$/;"	m	struct:filelist_struct	file:	access:public
filelist_struct::next	zip.c	/^    struct filelist_struct *next;$/;"	m	struct:filelist_struct	typeref:struct:filelist_struct::filelist_struct	file:	access:public
filename	proginfo/extrafld.txt	/^          identifying files independent of filename, optionally adds$/;"	v
filename	proginfo/fileinfo.cms	/^  much whitespace you can have before and after the filename, the$/;"	v
fileno	cmsmvs/cmsmvs.h	71;"	d
filenotes	zip.c	/^local int filenotes = 0; \/* 1=take comments from AmigaDOS\/MACOS filenotes *\/$/;"	v
fileopen	tandem/tandem.h	/^  unsigned fileopen  : 1;$/;"	m	struct:nsk_file_attrs_def	access:public
files	README	/^large files, but they currently do not handle split archives.  A work around$/;"	v
files	README.CR	/^  use encryption and compress regular disk files, you need not worry about$/;"	v
files	WHERE	/^   unz552dN.zip      NT4\/W2K\/XP\/2K3\/W9x (32-bit Intel) DLL, header files, docs$/;"	v
files	proginfo/infozip.who	/^                                                        large files, splits, DLLs$/;"	v
files	zip.txt	/^       or size of the OS file is different, adding  new  files,  and  deleting$/;"	v
files_so_far	globals.c	/^ulg files_so_far = 0;         \/* files processed so far *\/$/;"	v
files_total	globals.c	/^ulg files_total = 0;          \/* files total to process *\/$/;"	v
filesize64	zip.c	/^uzoff_t filesize64;$/;"	v
filesync	globals.c	/^int filesync = 0;       \/* 1=file sync, delete entries not on file system *\/$/;"	v
filetime	acorn/acornzip.c	/^ulg filetime(f, a, n, t)$/;"	f
filetime	amiga/amigazip.c	/^ulg filetime(f, a, n, t)$/;"	f
filetime	aosvs/aosvs.c	/^ulg filetime(f, a, n, t)$/;"	f
filetime	atari/atari.c	/^ulg filetime(f, a, n, t)$/;"	f
filetime	atheos/atheos.c	/^ulg filetime(f, a, n, t)$/;"	f
filetime	beos/beos.c	/^ulg filetime(f, a, n, t)$/;"	f
filetime	cmsmvs/cmsmvs.c	/^ulg filetime(f, a, n, t)$/;"	f
filetime	human68k/human68k.c	/^ulg filetime(f, a, n, t)$/;"	f
filetime	macos/source/macos.c	/^ulg filetime($/;"	f	signature:( char *f, ulg *a, long *n, iztimes *t)
filetime	msdos/msdos.c	/^ulg filetime(f, a, n, t)$/;"	f
filetime	novell/Netware.c	/^ulg filetime(f, a, n, t)$/;"	f
filetime	os2/os2.c	/^ulg filetime(f, a, n, t)$/;"	f
filetime	qdos/qfileio.c	/^ulg filetime(f, a, n, t)$/;"	f
filetime	tandem/tanzip.c	/^  ulg filetime(f, a, n, t)$/;"	f
filetime	theos/theos.c	/^ulg filetime(f, a, n, t)$/;"	f
filetime	tops20/tops20.c	/^ulg filetime(f, a, n, t)$/;"	f
filetime	unix/unix.c	/^ulg filetime(f, a, n, t)$/;"	f
filetime	vms/vmszip.c	/^ulg filetime( char *f, ulg *a, zoff_t *n, iztimes *t)$/;"	f	signature:( char *f, ulg *a, zoff_t *n, iztimes *t)
filetime	win32/win32zip.c	/^ulg filetime(f, a, n, t)$/;"	f
filetimeHHO	novell/Netware.c	/^ulg filetimeHHO(f, a, n, t)$/;"	f
filetimew	win32/win32zip.c	/^ulg filetimew(fw, a, n, t)$/;"	f
filetype	acorn/ReadMe	/^The Acorn port conserves file attributes, including filetype, so if you$/;"	v
filetype	proginfo/fileinfo.cms	/^  filetype, and filemode.$/;"	v
filetype	tandem/tandem.h	/^  unsigned filetype  : 2;$/;"	m	struct:nsk_file_attrs_def	access:public
filetypes	zipup.c	/^local int filetypes(a, s)$/;"	f
fill_window	amiga/deflate.a	/^fill_window:                            ; asm-callable entry point$/;"	v
fill_window	deflate.c	/^local void fill_window()$/;"	f
fill_window	human68k/deflate.s	/^fill_window:                            ; asm-callable entry point$/;"	v
filter	fileio.c	/^int filter(name, casesensitive)$/;"	f
filter	zip.txt	/^       as  a filter, compressing standard input to standard output.  For exam-$/;"	v
filter_match_case	globals.c	/^int filter_match_case = 1;    \/* 1=match case when filter() *\/$/;"	v
filterlist	zip.c	/^struct filterlist_struct *filterlist = NULL;  \/* start of list *\/$/;"	v	typeref:struct:filterlist_struct
filterlist_struct	zip.c	/^struct filterlist_struct {$/;"	s	file:
filterlist_struct::flag	zip.c	/^    char flag;$/;"	m	struct:filterlist_struct	file:	access:public
filterlist_struct::next	zip.c	/^    struct filterlist_struct *next;$/;"	m	struct:filterlist_struct	typeref:struct:filterlist_struct::filterlist_struct	file:	access:public
filterlist_struct::pattern	zip.c	/^    char *pattern;$/;"	m	struct:filterlist_struct	file:	access:public
find	os2/os2zip.c	/^static FILEFINDBUF find;$/;"	v	file:
find	os2/os2zip.c	/^static FILEFINDBUF3 find;$/;"	v	file:
find_dir	vms/vmszip.c	/^int find_dir( char *file_spec, char **start)$/;"	f	signature:( char *file_spec, char **start)
find_next_signature	zipfile.c	/^local int find_next_signature(f)$/;"	f
find_signature	zipfile.c	/^local int find_signature(f, signature)$/;"	f
findit	novell/Netware.c	/^static void findit(char *what)$/;"	f	file:	signature:(char *what)
findzip	novell/Netware.c	/^void findzip(char *s)$/;"	f	signature:(char *s)
finish	zip.c	/^local int finish(e)$/;"	f
fix	globals.c	/^int fix = 0;            \/* 1=fix the zip file, 2=FF, 3=ZipNote *\/$/;"	v
fixRelativpath	novell/Netware.c	/^int fixRelativpath ()$/;"	f
fixes	Betas_Readme.txt	/^We take suggestions, bug fixes, and patches at any time, so send them in.$/;"	v
fjn$v_aijnl	vms/vmsdefs.h	/^  unsigned fjn$v_aijnl : 1;$/;"	m	struct:fjndef	access:public
fjn$v_atjnl	vms/vmsdefs.h	/^  unsigned fjn$v_atjnl : 1;$/;"	m	struct:fjndef	access:public
fjn$v_bijnl	vms/vmsdefs.h	/^  unsigned fjn$v_bijnl : 1;$/;"	m	struct:fjndef	access:public
fjn$v_fill_7	vms/vmsdefs.h	/^  unsigned fjn$v_fill_7 : 1;$/;"	m	struct:fjndef	access:public
fjn$v_journal_file	vms/vmsdefs.h	/^  unsigned fjn$v_journal_file : 1;$/;"	m	struct:fjndef	access:public
fjn$v_never_ru	vms/vmsdefs.h	/^  unsigned fjn$v_never_ru : 1;$/;"	m	struct:fjndef	access:public
fjn$v_only_ru	vms/vmsdefs.h	/^  unsigned fjn$v_only_ru : 1;$/;"	m	struct:fjndef	access:public
fjn$v_rujnl	vms/vmsdefs.h	/^  unsigned fjn$v_rujnl : 1;$/;"	m	struct:fjndef	access:public
fjndef	vms/vmsdefs.h	/^struct fjndef  {$/;"	s
fjndef::fjn$v_aijnl	vms/vmsdefs.h	/^  unsigned fjn$v_aijnl : 1;$/;"	m	struct:fjndef	access:public
fjndef::fjn$v_atjnl	vms/vmsdefs.h	/^  unsigned fjn$v_atjnl : 1;$/;"	m	struct:fjndef	access:public
fjndef::fjn$v_bijnl	vms/vmsdefs.h	/^  unsigned fjn$v_bijnl : 1;$/;"	m	struct:fjndef	access:public
fjndef::fjn$v_fill_7	vms/vmsdefs.h	/^  unsigned fjn$v_fill_7 : 1;$/;"	m	struct:fjndef	access:public
fjndef::fjn$v_journal_file	vms/vmsdefs.h	/^  unsigned fjn$v_journal_file : 1;$/;"	m	struct:fjndef	access:public
fjndef::fjn$v_never_ru	vms/vmsdefs.h	/^  unsigned fjn$v_never_ru : 1;$/;"	m	struct:fjndef	access:public
fjndef::fjn$v_only_ru	vms/vmsdefs.h	/^  unsigned fjn$v_only_ru : 1;$/;"	m	struct:fjndef	access:public
fjndef::fjn$v_rujnl	vms/vmsdefs.h	/^  unsigned fjn$v_rujnl : 1;$/;"	m	struct:fjndef	access:public
flag	amiga/deflate.a	/^; Arg 1 is bool (int) EOF flag, flush_block result is in d0, trashes d1\/a0\/a1$/;"	v
flag	api.h	/^    ulg flag;               \/* bit 0: is_beta   bit 1: uses_zlib *\/$/;"	m	struct:_ZpVer	access:public
flag	human68k/deflate.s	/^; Arg 1 is bool (int) EOF flag, flush_block result is in d0, trashes d1\/a0\/a1$/;"	v
flag	windll/windll.txt	/^    ulg flag;               \/* bit 0: is_beta   bit 1: uses_zlib *\/$/;"	m	struct:_ZpVer	file:	access:public
flag	zip.c	/^    char flag;$/;"	m	struct:filterlist_struct	file:	access:public
flag_bit	trees.c	/^local uch flag_bit;         \/* current bit used in flags *\/$/;"	v
flag_buf	trees.c	/^local uch near flag_buf[(LIT_BUFSIZE\/8)];$/;"	v
flags	crc32.c	/^   error: Inconsistent flags, DYNALLOC_CRCTAB without DYNAMIC_CRC_TABLE.$/;"	v
flags	msdos/match.asm	/^; The different environments are selected by two conditional flags:$/;"	v
flags	tandem/tandem.h	/^  struct nsk_file_flags flags;     \/* 16 *\/$/;"	m	struct:nsk_file_attrs_def	typeref:struct:nsk_file_attrs_def::nsk_file_flags	access:public
flags	trees.c	/^local uch flags;            \/* current flags not yet saved in flag_buf *\/$/;"	v
flags	vms/vms.h	/^    ush flags;$/;"	m	struct:IZ_block	access:public
flg	zip.h	/^  ush vem, ver, flg, how;$/;"	m	struct:zlist	access:public
flist	zip.h	/^struct flist {$/;"	s
flist::dosflag	zip.h	/^  int dosflag;                  \/* Set to force MSDOS file attributes *\/$/;"	m	struct:flist	access:public
flist::iname	zip.h	/^  char *iname;                  \/* Internal file name after cleanup *\/$/;"	m	struct:flist	access:public
flist::inamew	zip.h	/^  wchar_t *inamew;              \/* Windows wide character version of iname *\/$/;"	m	struct:flist	access:public
flist::lst	zip.h	/^  struct flist far *far *lst;   \/* Pointer to link pointing here *\/$/;"	m	struct:flist	typeref:struct:flist::far	access:public
flist::name	zip.h	/^  char *name;                   \/* Raw internal file name *\/$/;"	m	struct:flist	access:public
flist::namew	zip.h	/^  wchar_t *namew;               \/* Windows wide character version of name *\/$/;"	m	struct:flist	access:public
flist::nxt	zip.h	/^  struct flist far *nxt;        \/* Link to next name *\/$/;"	m	struct:flist	typeref:struct:flist::far	access:public
flist::oname	zip.h	/^  char *oname;                  \/* Display version of internal name *\/$/;"	m	struct:flist	access:public
flist::uname	zip.h	/^  char *uname;                  \/* UTF-8 name *\/$/;"	m	struct:flist	access:public
flist::usize	zip.h	/^  uzoff_t usize;                \/* usize from initial scan *\/$/;"	m	struct:flist	access:public
flist::zname	zip.h	/^  char *zname;                  \/* External version of internal name *\/$/;"	m	struct:flist	access:public
flist::znamew	zip.h	/^  wchar_t *znamew;              \/* Windows wide character version of zname *\/$/;"	m	struct:flist	access:public
flist_size	tandem/tandem.c	516;"	d	file:
fliteral	amiga/deflate.a	/^        blo     fliteral$/;"	v
fliteral	human68k/deflate.s	/^        blo     fliteral$/;"	v
flush_block	trees.c	/^uzoff_t flush_block(buf, stored_len, eof)$/;"	f
flush_flg	trees.c	/^local int flush_flg;$/;"	v
flush_outbuf	acorn/sendbits.s	/^        BLHS    flush_outbuf    ; then flush the buffer$/;"	v
flush_outbuf	zipup.c	/^void flush_outbuf(o_buf, o_idx)$/;"	f
fn	cmsmvs/mc.exec	/^'pipe (end ?) < 'fn' makefile',       \/* get all source files from   *\/$/;"	v
fname	cmsmvs/cstat.h	/^    char  fname[FILENAME_MAX];$/;"	m	struct:stat	access:public
fnxt	globals.c	/^struct flist far * far *fnxt = &found;$/;"	v	typeref:struct:far
follows	amiga/deflate.a	/^; The symbols that can be used to select different versions are as follows:$/;"	v
follows	amiga/match_68.a	/^; can be used to select behavior are as follows:$/;"	v
follows	human68k/deflate.s	/^; The symbols that can be used to select different versions are as follows:$/;"	v
fopen	macos/osdep.h	100;"	d
fopen	macos/source/macopen.c	34;"	d	file:
fopen	tandem/tanzip.c	115;"	d	file:
fopen	tandem/tanzip.c	56;"	d	file:
fopen	tandem/tanzip.h	12;"	d
fopen	theos/osdep.h	52;"	d
fopm_id	vms/vms.c	/^int fopm_id = FOPM_ID;          \/* Callback id storage, modify. *\/$/;"	v
fopr_id	vms/vms.c	/^int fopr_id = FOPR_ID;          \/* Callback id storage, read. *\/$/;"	v
fopw_id	vms/vms.c	/^int fopw_id = FOPW_ID;          \/* Callback id storage, write. *\/$/;"	v
force_zip64	globals.c	/^  int force_zip64 = -1;       \/* if 1 force entries to be zip64, 0 force not zip64 *\/$/;"	v
forgotten	proginfo/infozip.who	/^contributed and your name has been forgotten, please send a reminder to us$/;"	v
format	README	/^extended file attributes; conversion from Unix to MSDOS text file format; and,$/;"	v
format	tags	/^!_TAG_FILE_FORMAT	2	\/extended format; --format=1 will not append ;" to lines\/$/;"	v
formats	proginfo/txtvsbin.txt	/^some printable text.  Even the newer, portable text formats, such as$/;"	v
former	proginfo/ZipPorts	/^      As to the former, use #ifdefs for your new code (see rule 0.3).  And$/;"	v
found	globals.c	/^struct flist far *found = NULL;   \/* List of names found *\/$/;"	v	typeref:struct:far
fp	acorn/match.s	/^        LDR     fp, [pc, #|__prev|-.-8]$/;"	v
fp	acorn/sendbits.s	/^        LDMDB   fp,{r4,r5,fp,sp,pc}^$/;"	v
fp	acorn/sendbits.s	/^        SUB     fp,ip,#4$/;"	v
fp	cmsmvs/cstat.h	/^    FILE  *fp;$/;"	m	struct:stat	access:public
fp	vms/vms.h	/^    ush tag_fp; ush len_fp;     byte fp[ATR$S_FPRO];$/;"	m	struct:__anon23	access:public
fp	vms/vms.h	/^    ush tag_fp; ush len_fp;     byte fp[ATR$S_FPRO];$/;"	m	struct:__anon24	access:public
fpb	macos/source/macglob.h	/^    CInfoPBRec      fpb;$/;"	m	struct:__anon17	access:public
fprintf	windll/windll.c	/^int __far __cdecl fprintf(FILE *file, const char *format, ...)$/;"	f	signature:(FILE *file, const char *format, ...)
fqcmp	fileio.c	/^local int fqcmp(a, b)$/;"	f
fqcmpz	fileio.c	/^local int fqcmpz(a, b)$/;"	f
free	util.c	1045;"	d	file:
free	zip.h	590;"	d
free_args	fileio.c	/^int free_args(args)$/;"	f
free_crc_table	crc32.c	/^void free_crc_table()$/;"	f
free_dircontents	os2/os2zip.c	/^static void free_dircontents(struct _dircontents * dp)$/;"	f	file:	signature:(struct _dircontents * dp)
freeup	zip.c	/^local void freeup()$/;"	f
freq	trees.c	/^        ush  freq;       \/* frequency count *\/$/;"	m	union:ct_data::__anon28	file:	access:public
from	msdos/crc_i86.asm	/^; In December 1998, the loop branch commands were changed from "loop dest"$/;"	v
from	win32/gvmat64.asm	/^;   (you can get Windows 2003 server DDK with ml64 and cl for AMD64 from$/;"	v
fseek	acorn/osdep.h	21;"	d
fseekable	util.c	/^int fseekable( fp)$/;"	f
fseekable	win32/win32.c	/^int fseekable(fp)$/;"	f
fstat	amiga/stat.c	/^int fstat(int handle, struct stat *buf)$/;"	f	signature:(int handle, struct stat *buf)
fstat	cmsmvs/cmsmvs.c	/^int fstat(int fd, struct stat *buf)$/;"	f	signature:(int fd, struct stat *buf)
fstat	theos/stat.h	96;"	d
fstat_packet	aosvs/aosvs.c	/^     ZVSFSTAT_STRU  fstat_packet;       \/* the fstat packet *\/$/;"	m	struct:zextrafld	file:	access:public
ftp	acorn/match.s	/^; also may be found at:  ftp:\/\/ftp.cdrom.com\/pub\/infozip\/license.html$/;"	v
ftp	acorn/sendbits.s	/^; also may be found at:  ftp:\/\/ftp.cdrom.com\/pub\/infozip\/license.html$/;"	v
ftp	acorn/swiven.s	/^; also may be found at:  ftp:\/\/ftp.cdrom.com\/pub\/infozip\/license.html$/;"	v
ftp	amiga/crc_68.a	/^; also may be found at:  ftp:\/\/ftp.info-zip.org\/pub\/infozip\/license.html$/;"	v
ftp	amiga/deflate.a	/^; also may be found at:  ftp:\/\/ftp.cdrom.com\/pub\/infozip\/license.html$/;"	v
ftp	amiga/match.a	/^; also may be found at:  ftp:\/\/ftp.cdrom.com\/pub\/infozip\/license.html$/;"	v
ftp	amiga/match_68.a	/^; also may be found at:  ftp:\/\/ftp.cdrom.com\/pub\/infozip\/license.html$/;"	v
ftp	human68k/crc_68.s	/^; also may be found at:  ftp:\/\/ftp.info-zip.org\/pub\/infozip\/license.html$/;"	v
ftp	human68k/deflate.s	/^; also may be found at:  ftp:\/\/ftp.cdrom.com\/pub\/infozip\/license.html$/;"	v
ftp	msdos/crc_i86.asm	/^; also may be found at:  ftp:\/\/ftp.info-zip.org\/pub\/infozip\/license.html$/;"	v
ftp	msdos/match.asm	/^; also may be found at:  ftp:\/\/ftp.info-zip.org\/pub\/infozip\/license.html$/;"	v
ftp	os2/match32.asm	/^; also may be found at:  ftp:\/\/ftp.info-zip.org\/pub\/infozip\/license.html$/;"	v
ftp	qdos/config.s	/^; also may be found at:  ftp:\/\/ftp.cdrom.com\/pub\/infozip\/license.html$/;"	v
ftp	qdos/crc68.s	/^; also may be found at:  ftp:\/\/ftp.info-zip.org\/pub\/infozip\/license.html$/;"	v
ftp	qdos/match.s	/^; also may be found at:  ftp:\/\/ftp.cdrom.com\/pub\/infozip\/license.html$/;"	v
ftp	win32/crc_i386.asm	/^; also may be found at:  ftp:\/\/ftp.info-zip.org\/pub\/infozip\/license.html$/;"	v
ftp	win32/crc_lcc.asm	/^; also may be found at:  ftp:\/\/ftp.info-zip.org\/pub\/infozip\/license.html$/;"	v
ftp	win32/lm32_lcc.asm	/^; also may be found at:  ftp:\/\/ftp.cdrom.com\/pub\/infozip\/license.html$/;"	v
ftp	win32/match32.asm	/^; also may be found at:  ftp:\/\/ftp.info-zip.org\/pub\/infozip\/license.html$/;"	v
ftwfunc	atari/atari.c	/^static int ftwfunc( struct stat *stats, int ftw_status )$/;"	f	file:	signature:( struct stat *stats, int ftw_status )
ftype	acorn/zipup.h	/^typedef FILE *ftype;$/;"	t
ftype	amiga/zipup.h	/^typedef int          ftype;$/;"	t
ftype	atari/zipup.h	/^typedef int ftype;$/;"	t
ftype	atheos/zipup.h	/^typedef int ftype;$/;"	t
ftype	beos/zipup.h	/^typedef int ftype;$/;"	t
ftype	cmsmvs/zipup.h	/^typedef FILE *ftype;$/;"	t
ftype	human68k/zipup.h	/^typedef int ftype;$/;"	t
ftype	macos/zipup.h	/^typedef int ftype;$/;"	t
ftype	msdos/zipup.h	/^typedef int          ftype;$/;"	t
ftype	novell/zipup.h	/^typedef int          ftype;$/;"	t
ftype	os2/zipup.h	/^typedef int ftype;$/;"	t
ftype	qdos/zipup.h	/^typedef int ftype;$/;"	t
ftype	tandem/zipup.h	/^typedef int ftype;$/;"	t
ftype	theos/zipup.h	/^typedef int ftype;$/;"	t
ftype	tops20/zipup.h	/^typedef int ftype;$/;"	t
ftype	unix/zipup.h	/^typedef int ftype;$/;"	t
ftype	vms/zipup.h	/^typedef void *ftype;$/;"	t
ftype	win32/zipup.h	/^typedef int          ftype;$/;"	t
fullpath	atari/atari.c	/^static char   fullpath[FILENAME_MAX], file_arg[FILENAME_MAX];$/;"	v	file:
function	amiga/match_68.a	/^; This is a 68000 assembly language version of the Zip function$/;"	v
function	amiga/match_68.a	/^; that it includes both byte based and word based versions of the function,$/;"	v
function	win32/gvmat64.asm	/^;;; deflate_state structure during the function's setup (before$/;"	v
functionality	LICENSE	/^       modified or added functionality, and dynamic, shared, or static library$/;"	v
functionality	tags	/^functionality	LICENSE	\/^       modified or added functionality, and dynamic, shared, or static library$\/;"	v$/;"	v
functionality	tags	/^shared	LICENSE	\/^       modified or added functionality, and dynamic, shared, or static library$\/;"	v$/;"	v
functions	amiga/deflate.a	/^; ================== Several macros used in deflate() and later functions:$/;"	v
functions	human68k/deflate.s	/^; ================== Several macros used in deflate() and later functions:$/;"	v
fw_refill	amiga/deflate.a	/^        blo     fw_refill               ; eofile is still false$/;"	v
g_VolumeCaps	win32/nt.c	/^VOLUMECAPS g_VolumeCaps;$/;"	v
g_bBackupPrivilege	win32/nt.c	/^BOOL g_bBackupPrivilege = FALSE;    \/* for local get file security override *\/$/;"	v
g_bZipSaclPrivilege	win32/nt.c	/^BOOL g_bZipSaclPrivilege = FALSE;      \/* for local get sacl operations, only when$/;"	v
gen_bitlen	trees.c	/^local void gen_bitlen(desc)$/;"	f
gen_codes	trees.c	/^local void gen_codes (tree, max_code)$/;"	f
gen_node	cmsmvs/mvs.c	/^static int gen_node( DIR *dirp, RECORD *recptr )$/;"	f	file:	signature:( DIR *dirp, RECORD *recptr )
general	vms/zip_msg.msg	/^! general, specific to Zip, this file is not compiled with \/SHARED.$/;"	v
generate_transitions	timezone.c	/^static void generate_transitions(sp, start, end)$/;"	f	file:
generic_gcc	INSTALL	/^     where "system" is one of:  generic, generic_gcc,$/;"	v
getDirEntryAttr	msdos/msdos.c	97;"	d	file:
getRISCOSexts	acorn/riscos.c	/^void getRISCOSexts(char *envstr)$/;"	f	signature:(char *envstr)
getVolumeLabel	atari/atari.c	/^local char *getVolumeLabel(drive, vtime, vmode, utim)$/;"	f
getVolumeLabel	msdos/msdos.c	/^local char *getVolumeLabel(drive, vtime, vmode, vutim)$/;"	f
getVolumeLabel	os2/os2zip.c	/^char *getVolumeLabel(int drive, unsigned long *vtime, unsigned long *vmode,$/;"	f	signature:(int drive, unsigned long *vtime, unsigned long *vmode, time_t *utim)
getVolumeLabel	win32/win32.c	/^char *getVolumeLabel(drive, vtime, vmode, vutim)$/;"	f
get_attr_dir	atheos/atheos.c	/^int get_attr_dir( const char *name, char **attr_buff, off_t *total_size )$/;"	f	signature:( const char *name, char **attr_buff, off_t *total_size )
get_attr_dir	beos/beos.c	/^int get_attr_dir( const char *name, char **attr_buff, off_t *total_size )$/;"	f	signature:( const char *name, char **attr_buff, off_t *total_size )
get_char	macos/source/getenv.c	/^int get_char(FILE *file)$/;"	f	signature:(FILE *file)
get_crc_table	crc32.c	/^ZCONST uLongf *get_crc_table OF((void))$/;"	f	signature:(void)
get_ef_ut_ztime	zipfile.c	/^int get_ef_ut_ztime(z, z_utim)$/;"	f
get_in_split_path	fileio.c	/^char *get_in_split_path(base_path, disk_number)$/;"	f
get_list	vms/cmdline.c	/^get_list (struct dsc$descriptor_s *qual, struct dsc$descriptor_d *rawtail,$/;"	f	file:	signature:(struct dsc$descriptor_s *qual, struct dsc$descriptor_d *rawtail, int delim, char **p_str, unsigned long *p_size, unsigned long *p_end)
get_longopt	fileio.c	/^local unsigned long get_longopt(args, argnum, optchar, negated, value,$/;"	f
get_option	fileio.c	/^unsigned long get_option(pargs, argc, argnum, optchar, value,$/;"	f
get_out_split_path	fileio.c	/^char *get_out_split_path(base_path, disk_number)$/;"	f
get_rms_defaults	vms/vms.c	/^int get_rms_defaults()$/;"	f
get_shortopt	fileio.c	/^local unsigned long get_shortopt(args, argnum, optchar, negated, value,$/;"	f
get_string	macos/source/getenv.c	/^int get_string(char *string, int size, FILE *file, char *terms)$/;"	f	signature:(char *string, int size, FILE *file, char *terms)
get_time	vms/cmdline.c	/^get_time (struct dsc$descriptor_s *qual, char *timearg)$/;"	f	file:	signature:(struct dsc$descriptor_s *qual, char *timearg)
get_vms_version	vms/vms_im.c	/^static int get_vms_version(verbuf, len)$/;"	f	file:
get_wide_argv	win32/win32.c	/^  zchar **get_wide_argv(argv)$/;"	f
getc	macos/ZipLib.h	32;"	d
getc	macos/ZipSx.h	32;"	d
getc	macos/osdep.h	74;"	d
getch	cmsmvs/cmsmvs.h	63;"	d
getch	ttyio.h	118;"	d
getch	ttyio.h	127;"	d
getch	ttyio.h	132;"	d
getch	ttyio.h	137;"	d
getch	ttyio.h	149;"	d
getch	ttyio.h	166;"	d
getch	ttyio.h	187;"	d
getch	ttyio.h	84;"	d
getch	ttyio.h	92;"	d
getch	ttyio.h	99;"	d
getch_win32	win32/win32.c	/^int getch_win32(void)$/;"	f	signature:(void)
getchar	macos/ZipLib.h	33;"	d
getchar	macos/ZipSx.h	33;"	d
getchar	macos/osdep.h	75;"	d
getdirent	os2/os2zip.c	/^static char *getdirent(char *dir)$/;"	f	file:	signature:(char *dir)
getenv	amiga/filedate.c	/^char *getenv(const char *var)         \/* not reentrant! *\/$/;"	f	signature:(const char *var)
getenv	macos/source/getenv.c	/^char *getenv(const char *name)$/;"	f	signature:(const char *name)
getfileattr	fileio.c	/^int getfileattr(f)$/;"	f
getnam	fileio.c	/^char *getnam(fp)$/;"	f
getnum	timezone.c	/^static ZCONST char *getnum(strp, nump, min, max)$/;"	f	file:
getoffset	timezone.c	/^static ZCONST char *getoffset(strp, offsetp)$/;"	f	file:
getp	qdos/qdos.c	/^char *getp(m, p, n)$/;"	f
getpid	tandem/tanzip.h	22;"	d
getrule	timezone.c	/^static ZCONST char *getrule(strp, rulep)$/;"	f	file:
getsecs	timezone.c	/^static ZCONST char *getsecs(strp, secsp)$/;"	f	file:
getzname	timezone.c	/^static ZCONST char *getzname(strp)$/;"	f	file:
gmt	timezone.c	/^static ZCONST char  gmt[] = "GMT";$/;"	v	file:
gmt_to_time_t	tandem/tandem.c	/^static time_t gmt_to_time_t (gmt)$/;"	f	file:
gmtime	acorn/osdep.h	24;"	d
gmtime	acorn/riscos.c	351;"	d	file:
gmtime	timezone.c	/^struct tm *gmtime(when)$/;"	f
go	zip30.ann	/^  information, such as how many entries processed and to go, how$/;"	v
go	zip30.ann	/^  many bytes processed and to go, and adjustable size progress$/;"	v
good_bytes_so_far	globals.c	/^uzoff_t good_bytes_so_far = 0;\/* good bytes read so far *\/$/;"	v
good_length	deflate.c	/^   ush good_length; \/* reduce lazy search above this match length *\/$/;"	m	struct:config	file:	access:public
good_match	deflate.c	/^unsigned near good_match;$/;"	v
greedy	zipsplit.c	/^local extent greedy(a, n, c, d)$/;"	f
group	tandem/tandem.h	/^  unsigned group   : 8;$/;"	m	struct:nsk_owner	access:public
guarded	msdos/crc_i86.asm	/^; In January 2007, the "hand-made" memory model setup section has been guarded$/;"	v
h	crypt.c	/^    ZCONST uch *h;      \/* decrypted header *\/$/;"	v
h	crypt.c	/^    ZCONST uch *h;$/;"	v
hCurrentInst	windll/windll.c	/^HINSTANCE hCurrentInst;$/;"	v
hFile	windll/example.c	/^int hFile;              \/* file handle *\/$/;"	v
hFileList	windll/example.c	/^HANDLE hFileList;$/;"	v
hStr	windll/windll.c	/^HANDLE hStr;$/;"	v
hUnzipDll	windll/example.c	/^HINSTANCE hUnzipDll;$/;"	v
hZUF	windll/example.c	/^HANDLE hZUF = (HANDLE)NULL;$/;"	v
hZipDll	windll/example.c	/^HINSTANCE hZipDll;$/;"	v
hZipInitMutex	win32/nt.c	/^HANDLE hZipInitMutex = NULL;   \/* prevent multiple initialization *\/$/;"	v
handler	zip.c	/^local void handler(s)$/;"	f
handler	zipcloak.c	/^local void handler(sig)$/;"	f
handler	zipnote.c	/^local void handler(s)$/;"	f
handler	zipsplit.c	/^local void handler(s)$/;"	f
handling	CHANGES	/^ 2. win32 volumelabel handling (Paul)$/;"	f
has_win32_wide	win32/win32zip.c	/^int has_win32_wide() {$/;"	f
hash_head	amiga/deflate.a	/^Head    equr    d5              ; local variable hash_head, short$/;"	v
hash_head	human68k/deflate.s	/^Head    reg     d5              ; local variable hash_head, short$/;"	v
have	README	/^   readable in what you have, zip -FF should be able to recover it.$/;"	v
hdir	os2/os2zip.c	/^static HDIR hdir;$/;"	v	file:
he	amiga/match_68.a	/^; time the feature for runtime testing of CPU type is only supported for the$/;"	v
head	deflate.c	/^  Pos    head[HASH_SIZE];$/;"	v
head	deflate.c	/^  Pos far * near head;$/;"	v
header	qdos/qdos.c	/^    struct      qdirect     header __attribute__ ((packed));$/;"	m	struct:__anon33	typeref:struct:__anon33::qdirect	file:	access:public
heap	trees.c	/^local int near heap[2*L_CODES+1]; \/* heap used to build the Huffman trees *\/$/;"	v
heap_len	trees.c	/^local int heap_len;               \/* number of elements in the heap *\/$/;"	v
heap_max	trees.c	/^local int heap_max;               \/* element of largest frequency *\/$/;"	v
heavily	amiga/deflate.a	/^; from, the hottest hot spot in the program and therefore the most heavily$/;"	v
heavily	human68k/deflate.s	/^; from, the hottest hot spot in the program and therefore the most heavily$/;"	v
help	zip.c	/^local void help()$/;"	f
help	zipcloak.c	/^local void help()$/;"	f
help	zipnote.c	/^local void help()$/;"	f
help	zipsplit.c	/^local void help()$/;"	f
help_extended	zip.c	/^local void help_extended()$/;"	f
help_info	zipcloak.c	/^static ZCONST char *help_info[] = {$/;"	v	file:
hex_digit	vms/vmszip.c	/^char hex_digit[ 16] = {$/;"	v
hi	qdos/qdos.c	/^        unsigned char hi __attribute__ ((packed));$/;"	m	struct:__anon33::__anon34	file:	access:public
hidden_files	globals.c	/^int hidden_files = 0;         \/* process hidden and system files *\/$/;"	v
high	proginfo/txtvsbin.txt	/^negatives is sometimes too high, which means that the recall is low.$/;"	v
high	zip.c	/^unsigned long low, high; \/* returning 64 bit values for systems without an _int64 *\/$/;"	v
higher	amiga/deflate.a	/^; for 68020 or higher, use word operations even on odd addresses:$/;"	v
higher	amiga/match_68.a	/^; for 68020 or higher, use word operations even on odd addresses:$/;"	v
higher	human68k/deflate.s	/^; for 68020 or higher, use word operations even on odd addresses:$/;"	v
how	zip.h	/^  ush vem, ver, flg, how;$/;"	m	struct:zlist	access:public
however	INSTALL	/^  set the flags appropriately.  In some cases, however, you may need to$/;"	v
however	amiga/deflate.a	/^; for 386 by Jean-loup Gailly and Kai Uwe Rommel.  Mostly, however, this$/;"	v
however	human68k/deflate.s	/^; on match.s for 386 by Jean-loup Gailly and Kai Uwe Rommel.  Mostly, however,$/;"	v
however	proginfo/txtvsbin.txt	/^the file contents.  It is, however, possible to obtain a fairly high$/;"	v
however	vms/NOTES.TXT	/^is done on an ODS2 or ODS5 disk.  Note, however, that in a world with$/;"	v
http	win32/gvmat64.asm	/^; see http:\/\/weblogs.asp.net\/oldnewthing\/archive\/2004\/01\/14\/58579.aspx and$/;"	v
huge	tailor.h	468;"	d
huge	tailor.h	478;"	d
i386	unix/Packaging/README	/^   Where:  $(arch) := system architecture, currently i386, sparc, or ppc.$/;"	v
iExtraLen	zipfile.c	/^  unsigned iExtraLen;   \/* length of extra field *\/$/;"	v
iRelativOK	novell/Netware.c	/^int	iRelativOK = FALSE;$/;"	v
iRelativPakking	novell/Netware.c	/^int	iRelativPakking = FALSE;$/;"	v
ibs	zip.txt	/^              dd if=\/dev\/nrst0  ibs=16k | funzip | tar xvf -$/;"	v
icompress	tandem/tandem.h	/^  unsigned icompress   : 1;$/;"	m	struct:nsk_file_flags	access:public
icount	globals.c	/^unsigned icount = 0;            \/* number of include only patterns *\/$/;"	v
ideal	INSTALL	/^     if you see optimization for your system is not ideal, send in$/;"	v
ident	util.c	/^local unsigned ident(unsigned chr)$/;"	f	signature:(unsigned chr)
identical	msdos/match.asm	/^;                are identical$/;"	v
ifile	zipup.c	/^local ftype ifile;              \/* file to compress *\/$/;"	v
ignored	acorn/ReadMe	/^machine (PC, Mac, Unix etc..), filetypes will be ignored, but the files$/;"	v
ilist_items	tandem/tandem.c	512;"	d	file:
implementations	INSTALL	/^     free GNU C implementations, respectively.  More detailed instructions$/;"	v
in	amiga/deflate.a	/^; Note: "pair of bytes" means the two low order bytes of the register in$/;"	v
in	human68k/deflate.s	/^; Note: "pair of bytes" means the two low order bytes of the register in$/;"	v
in2ex	acorn/acornzip.c	/^char *in2ex(n)$/;"	f
in2ex	amiga/amigazip.c	/^char *in2ex(n)$/;"	f
in2ex	aosvs/aosvs.c	/^char *in2ex(n)$/;"	f
in2ex	atari/atari.c	/^char *in2ex(n)$/;"	f
in2ex	atheos/atheos.c	/^char *in2ex(n)$/;"	f
in2ex	beos/beos.c	/^char *in2ex(n)$/;"	f
in2ex	cmsmvs/cmsmvs.c	/^char *in2ex(n)$/;"	f
in2ex	human68k/human68k.c	/^char *in2ex(n)$/;"	f
in2ex	macos/source/macos.c	/^char *in2ex(char *n)    \/* internal file name *\/$/;"	f	signature:(char *n)
in2ex	msdos/msdos.c	/^char *in2ex(n)$/;"	f
in2ex	novell/Netware.c	/^char *in2ex(n)$/;"	f
in2ex	os2/os2.c	/^char *in2ex(n)$/;"	f
in2ex	qdos/qfileio.c	/^char *in2ex(n)$/;"	f
in2ex	theos/theos.c	/^char *in2ex(n)$/;"	f
in2ex	tops20/tops20.c	/^char *in2ex(n)$/;"	f
in2ex	unix/unix.c	/^char *in2ex(n)$/;"	f
in2ex	vms/vmszip.c	/^char *in2ex( char *n)$/;"	f	signature:( char *n)
in2ex	win32/win32zip.c	/^char *in2ex(n)$/;"	f
in2exw	win32/win32zip.c	/^wchar_t *in2exw(nw)$/;"	f
in_buf	zipup.c	/^    local char *in_buf;$/;"	v
in_file	globals.c	/^FILE *in_file = NULL;         \/* current input file for splits *\/$/;"	v
in_offset	zipup.c	/^    local unsigned in_offset;$/;"	v
in_path	globals.c	/^char *in_path = NULL;         \/* base name of input archive file *\/$/;"	v
in_size	zipup.c	/^    local unsigned in_size;     \/* size of current input buffer *\/$/;"	v
in_split_path	globals.c	/^char *in_split_path = NULL;   \/* in split path *\/$/;"	v
iname	zip.h	/^  char *iname;                  \/* Internal file name after cleanup (stored in archive) *\/$/;"	m	struct:zlist	access:public
iname	zip.h	/^  char *iname;                  \/* Internal file name after cleanup *\/$/;"	m	struct:flist	access:public
inamew	zip.h	/^  wchar_t *inamew;              \/* Windows wide character version of iname *\/$/;"	m	struct:flist	access:public
inamew	zip.h	/^  wchar_t *inamew;              \/* Windows wide character version of iname *\/$/;"	m	struct:zlist	access:public
inaries	LICENSE	/^       be misrepresented as being the original source or, if binaries,$/;"	v	file:
ind_w	atari/atari.c	/^static short  is_w, ind_w;$/;"	v	file:
indexmade	zipsplit.c	/^local int indexmade = 0;        \/* true if index file made *\/$/;"	v
indll	CHANGES	/^ 7. Updated VB examples for windll (Mike)$/;"	f
initDirSearch	msdos/msdos.c	/^local int initDirSearch(name, ff_context_p)$/;"	f
init_block	trees.c	/^local void init_block()$/;"	f
init_ctx	vms/vms_im.c	/^Ctx init_ctx =$/;"	v
init_dyndesc	vms/cmdline.c	129;"	d	file:
init_keys	crypt.h	111;"	d
init_upper	os2/os2zip.c	/^void init_upper()$/;"	f
init_upper	util.c	/^void init_upper()$/;"	f
initialization	msdos/crc_i86.asm	/^; Selection of the supported CPU instruction set and initialization$/;"	v
initialization	msdos/match.asm	/^; Selection of the supported CPU instruction set and initialization$/;"	v
input	zip.txt	/^       pressed,  in  which  case  it  will  read the file from standard input,$/;"	v
input_len	trees.c	/^local uzoff_t input_len;        \/* total byte length of input file *\/$/;"	v
ins_h	amiga/deflate.a	/^        move.w  \\1,ins_h                ; ins_h = that$/;"	v
ins_h	amiga/deflate.a	/^        move.w  d1,ins_h$/;"	v
ins_h	deflate.c	/^local unsigned ins_h;  \/* hash index of string to be inserted *\/$/;"	v
ins_h	human68k/deflate.s	/^        move.w  _1,ins_h                ; ins_h = that$/;"	v
ins_h	human68k/deflate.s	/^        move.w  d1,ins_h$/;"	v
insert_arg	fileio.c	/^int insert_arg(pargs, arg, at_arg, free_args)$/;"	f
intended	msdos/crc_i86.asm	/^; Optimized 8086 assembler version of the CRC32 calculation loop, intended$/;"	v
interfaces	LICENSE	/^       systems, existing ports with new graphical interfaces, versions with$/;"	v
interfaces	tags	/^systems	LICENSE	\/^       systems, existing ports with new graphical interfaces, versions with$\/;"	v$/;"	v
ioctx_t	vms/vms_pk.c	/^} ioctx_t;$/;"	t	typeref:struct:__anon22	file:
iosb	vms/vms.h	/^struct iosb$/;"	s
iosb	vms/vms_pk.c	/^    struct iosb         iosb;$/;"	m	struct:__anon22	typeref:struct:__anon22::iosb	file:	access:public
iosb::count	vms/vms.h	/^    ush count;$/;"	m	struct:iosb	access:public
iosb::spec	vms/vms.h	/^    ulg spec;$/;"	m	struct:iosb	access:public
iosb::status	vms/vms.h	/^    ush status;$/;"	m	struct:iosb	access:public
ip	acorn/match.s	/^        CMP     ip, r4$/;"	v
ip	acorn/match.s	/^        CMP     ip, r8$/;"	v
ip	acorn/match.s	/^        CMP     ip, r9$/;"	v
ip	acorn/match.s	/^        LDR     ip, [ip]$/;"	v
ip	acorn/match.s	/^        LDR     ip, [pc, #|__good_match|-.-8]$/;"	v
ip	acorn/match.s	/^        LDR     ip, [pc, #|__strstart|-.-8]$/;"	v
ip	acorn/match.s	/^        LDRB    ip, [r2, #1]!$/;"	v
ip	acorn/match.s	/^        LDRB    ip, [r2]$/;"	v
ip	acorn/match.s	/^        LDRB    ip, [r3, #1]$/;"	v
ip	acorn/match.s	/^        LDRB    ip, [r3, ip]$/;"	v
ip	acorn/match.s	/^        LDRB    ip, [r3, r5]$/;"	v
ip	acorn/match.s	/^        SUB     ip, r5, #1$/;"	v
ip	acorn/match.s	/^        SUBCSS  r6, ip, #250                ; r6 = r6 - MAXDIST$/;"	v
ip	acorn/match.s	/^        SUBS    ip, ip, #MAX_DIST-250       ; if r6 > MAX_DIST$/;"	v
ip	acorn/sendbits.s	/^        MOV     ip,sp$/;"	v
ip	acorn/sendbits.s	/^        STR     ip,[r5]$/;"	v
ip	acorn/sendbits.s	/^        SUB     fp,ip,#4$/;"	v
ip	acorn/swiven.s	/^        LDMIA   ip, {r5,r6}$/;"	v
ip	acorn/swiven.s	/^        MOV     ip, lr$/;"	v
ip	acorn/swiven.s	/^        MOV     ip, r3$/;"	v
ip	acorn/swiven.s	/^        MOV     ip, sp$/;"	v
ip	acorn/swiven.s	/^        MOVS    pc, ip$/;"	v
ip	acorn/swiven.s	/^        TEQ     ip, #0$/;"	v
ipc_fstat_packet	aosvs/aosvs.c	/^     P_FSTAT_IPC    ipc_fstat_packet;       \/* IPC file fstat packet *\/$/;"	m	union:zvsfstat_stru	file:	access:public
is	amiga/crc_68.a	/^; prototype of the function is:$/;"	v
is	amiga/match.a	/^; If you have reduced WSIZE in zip.h, then make sure this is$/;"	v
is	amiga/match_68.a	/^; The main difference of this from other longest_match() implementations is$/;"	v
is	bzip2/install.txt	/^  "generic" target, that is, using a command like$/;"	v
is	human68k/crc_68.s	/^; prototype of the function is:$/;"	v
is	msdos/match.asm	/^; from OBJI). If you have reduced WSIZE in zip.h, then make sure this is$/;"	v
is	os2/match32.asm	/^; from OBJI). If you have reduced WSIZE in zip.h, then make sure this is$/;"	v
is	win32/gvmat64.asm	/^;;; both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and edx is$/;"	v
is	win32/lm32_lcc.asm	/^; from OBJI). If you have reduced WSIZE in zip.h, then make sure this is$/;"	v
is	win32/match32.asm	/^; from OBJI). If you have reduced WSIZE in zip.h, then make sure this is$/;"	v
isDirectory	macos/source/macglob.h	/^    Boolean         isDirectory;$/;"	m	struct:__anon17	access:public
isMacStatValid	macos/source/macglob.h	/^    Boolean     isMacStatValid;$/;"	m	struct:__anon17	access:public
isRegularItem	macos/source/recurse.c	/^static Boolean isRegularItem( RecurseGlobals *Globals)$/;"	f	file:	signature:( RecurseGlobals *Globals)
is_ascii_string	fileio.c	/^int is_ascii_string(mbstring)$/;"	f
is_ascii_stringw	fileio.c	/^int is_ascii_stringw(wstring)$/;"	f
is_running_on_windows	msdos/msdos.c	/^local int is_running_on_windows(void)$/;"	f	signature:(void)
is_seekable	zipup.c	/^int is_seekable(y)$/;"	f
is_signature	zipfile.c	/^local int is_signature(sig1, sig2)$/;"	f
is_text_buf	util.c	/^int is_text_buf(buf_ptr, buf_size)$/;"	f
is_w	atari/atari.c	/^static short  is_w, ind_w;$/;"	v	file:
isaligned	amiga/deflate.a	/^isaligned:$/;"	v
isaligned	human68k/deflate.s	/^isaligned:$/;"	v
isatty	acorn/osdep.h	20;"	d
isatty	cmsmvs/cmsmvs.h	68;"	d
isatty	macos/source/unixlike.h	58;"	d
isatty	tandem/tandem.c	/^int isatty (fnum)$/;"	f
isatty	theos/osdep.h	27;"	d
isize	zipup.c	/^    local zoff_t isize;         \/* input file size. global only for debugging *\/$/;"	v
isize	zipup.c	/^    zoff_t isize;               \/* input file size. global only for debugging *\/$/;"	v
islicensed	tandem/tandem.c	/^int islicensed(void)$/;"	f	signature:(void)
ismbblead	human68k/osdep.h	27;"	d
ismember	theos/theos.c	/^int ismember(char* path)$/;"	f	signature:(char* path)
iso2oem	ebcdic.h	/^ZCONST uch Far iso2oem[] = {$/;"	v
iso2ths	theos/charconv.h	/^ZCONST uch Far iso2ths[] = {$/;"	v
isshexp	util.c	/^char *isshexp(p)$/;"	f
isshexpw	util.c	/^wchar_t *isshexpw(pw)$/;"	f
issymlnk	fileio.c	/^int issymlnk(a)$/;"	f
it	amiga/deflate.a	/^;               function calls.  At present, if AMIGA is not defined, it$/;"	v
it	amiga/deflate.a	/^; But on some files it's slower.  It probably pays off only when there are$/;"	v
it	amiga/deflate.a	/^; arg 2 is the byte value to be hashed into it, which must not be the same reg$/;"	v
it	human68k/deflate.s	/^;               function calls.  At present, if AMIGA is not defined, it$/;"	v
it	human68k/deflate.s	/^; But on some files it's slower.  It probably pays off only when there are$/;"	v
it	human68k/deflate.s	/^; arg 2 is the byte value to be hashed into it, which must not be the same reg$/;"	v
it	proginfo/ZipPorts	/^      No doubt about it, this is the one which really pisses us off and$/;"	v
it	proginfo/fileinfo.cms	/^  specify it, it must be any of the digits 0-6.  You cannot specify$/;"	v
it	win32/readme.a64	/^to compile it, start the C++ AMD64 build environnement prompt,$/;"	v
itemName	macos/source/recurse.c	/^    unsigned char           *itemName;      \/* the name of the current item *\/$/;"	m	struct:RecurseGlobals	file:	access:public
itm_cod	vms/vms.c	/^    short itm_cod;$/;"	m	struct:__anon25	file:	access:public
itself	amiga/deflate.a	/^; This is the deflate() function itself, our main entry point.  It calls$/;"	v
itself	human68k/deflate.s	/^; This is the deflate() function itself, our main entry point.  It calls$/;"	v
iz_w32_prepareTZenv	win32/osdep.h	535;"	d
iz_w32_prepareTZenv	win32/osdep.h	537;"	d
iztimes	zip.h	/^typedef struct iztimes {$/;"	s
iztimes	zip.h	/^} iztimes;$/;"	t	typeref:struct:iztimes
iztimes::atime	zip.h	/^   time_t atime;                \/* new access time *\/$/;"	m	struct:iztimes	access:public
iztimes::ctime	zip.h	/^   time_t ctime;                \/* new creation time (!= Unix st.ctime) *\/$/;"	m	struct:iztimes	access:public
iztimes::mtime	zip.h	/^   time_t mtime;                \/* new modification time *\/$/;"	m	struct:iztimes	access:public
jpi_item_t	vms/vms.c	/^    } jpi_item_t;$/;"	t	typeref:struct:__anon25	file:
jpi_itm_lst	vms/vms.c	/^    } jpi_itm_lst =$/;"	v	typeref:struct:__anon26
jr	vms/vms.h	/^    ush tag_jr; ush len_jr;     byte jr[ATR$S_JOURNAL];$/;"	m	struct:__anon23	access:public
jr	vms/vms.h	/^    ush tag_jr; ush len_jr;     byte jr[ATR$S_JOURNAL];$/;"	m	struct:__anon24	access:public
junk_sfx	zip.c	/^local int junk_sfx = 0; \/* 1=junk the sfx prefix *\/$/;"	v
kAPPLResType	macos/source/macstuff.c	/^    kAPPLResType    = 'APPL'$/;"	e	enum:__anon16	file:
kBNDLResType	macos/source/macstuff.c	/^    kBNDLResType    = 'BNDL',$/;"	e	enum:__anon16	file:
kByte	msdos/crc_i86.asm	/^;   + char buffer size < 64 kByte$/;"	v
kByte	msdos/crc_i86.asm	/^;   for this routine, the char buffer size is limited to less than 64 kByte,$/;"	v
kFCMTResType	macos/source/macstuff.c	/^    kFCMTResType    = 'FCMT',$/;"	e	enum:__anon16	file:
kFREFResType	macos/source/macstuff.c	/^    kFREFResType    = 'FREF',$/;"	e	enum:__anon16	file:
kIconFamResType	macos/source/macstuff.c	/^    kIconFamResType = 'ICN#',$/;"	e	enum:__anon16	file:
keep	vms/descrip.mms	/^	purge \/noconfirm \/nolog \/keep = 1 [.VMS]ZIP_CLI.RNH$/;"	v
key	crypt.c	/^    ZCONST char *key;   \/* decryption password to test *\/$/;"	v
key	globals.c	/^char *key = NULL;       \/* Scramble password if scrambling *\/$/;"	v
key	macos/source/getenv.c	/^    char *key;$/;"	m	struct:_EnviromentPair	file:	access:public
keylen	tandem/tandem.h	/^  unsigned keylen    : 8;$/;"	m	struct:nsk_file_attrs_def	access:public
keyoff	tandem/tandem.h	/^  unsigned keyoff    : 11;$/;"	m	struct:nsk_file_attrs_def	access:public
keys	crypt.c	/^   local z_uint4 keys[3];       \/* keys defining the pseudo-random sequence *\/$/;"	v
klist_items	tandem/tandem.c	513;"	d	file:
lSize	os2/os2zip.c	/^  ULONG lSize;$/;"	m	struct:__anon13	file:	access:public
lSize	win32/nt.h	/^  ULONG lSize;  \/* uncompressed security descriptor data size *\/$/;"	m	struct:__anon5	access:public
lSize	win32/nt.h	/^  ULONG lSize;$/;"	m	struct:__anon4	access:public
l_buf	trees.c	/^  local uch far *l_buf;$/;"	v
l_buf	trees.c	/^  local uch far l_buf[LIT_BUFSIZE];  \/* buffer for literals\/lengths *\/$/;"	v
l_desc	trees.c	/^local tree_desc near l_desc =$/;"	v
label	fileio.c	/^char *label = NULL;                \/* global, but only used in `system'.c *\/$/;"	v
label_mode	acorn/acornzip.c	/^local ulg label_mode = 0;$/;"	v
label_mode	amiga/amigazip.c	/^local ulg label_mode = 0;$/;"	v
label_mode	aosvs/aosvs.c	/^local ulg label_mode = 0;$/;"	v
label_mode	atari/atari.c	/^local ulg label_mode = 0;$/;"	v
label_mode	atheos/atheos.c	/^local ulg label_mode = 0;$/;"	v
label_mode	beos/beos.c	/^local ulg label_mode = 0;$/;"	v
label_mode	cmsmvs/cmsmvs.c	/^local ulg label_mode = 0;$/;"	v
label_mode	msdos/msdos.c	/^local ulg label_mode = 0;$/;"	v
label_mode	novell/Netware.c	/^local ulg label_mode = 0;$/;"	v
label_mode	os2/os2.c	/^local ulg label_mode = 0;$/;"	v
label_mode	qdos/qfileio.c	/^local ulg label_mode = 0;$/;"	v
label_mode	theos/theos.c	/^local ulg label_mode = 0;$/;"	v
label_mode	tops20/tops20.c	/^local ulg label_mode = 0;$/;"	v
label_mode	unix/unix.c	/^local ulg label_mode = 0;$/;"	v
label_mode	vms/vmszip.c	/^local ulg label_mode = 0;$/;"	v
label_mode	win32/win32zip.c	/^local ulg label_mode = 0;$/;"	v
label_time	acorn/acornzip.c	/^local ulg label_time = 0;$/;"	v
label_time	amiga/amigazip.c	/^local ulg label_time = 0;$/;"	v
label_time	aosvs/aosvs.c	/^local ulg label_time = 0;$/;"	v
label_time	atari/atari.c	/^local ulg label_time = 0;$/;"	v
label_time	atheos/atheos.c	/^local ulg label_time = 0;$/;"	v
label_time	beos/beos.c	/^local ulg label_time = 0;$/;"	v
label_time	cmsmvs/cmsmvs.c	/^local ulg label_time = 0;$/;"	v
label_time	msdos/msdos.c	/^local ulg label_time = 0;$/;"	v
label_time	novell/Netware.c	/^local ulg label_time = 0;$/;"	v
label_time	os2/os2.c	/^local ulg label_time = 0;$/;"	v
label_time	qdos/qfileio.c	/^local ulg label_time = 0;$/;"	v
label_time	theos/theos.c	/^local ulg label_time = 0;$/;"	v
label_time	tops20/tops20.c	/^local ulg label_time = 0;$/;"	v
label_time	unix/unix.c	/^local ulg label_time = 0;$/;"	v
label_time	vms/vmszip.c	/^local ulg label_time = 0;$/;"	v
label_time	win32/win32zip.c	/^local ulg label_time = 0;$/;"	v
label_utim	acorn/acornzip.c	/^local time_t label_utim = 0;$/;"	v
label_utim	amiga/amigazip.c	/^local time_t label_utim = 0;$/;"	v
label_utim	aosvs/aosvs.c	/^local time_t label_utim = 0;$/;"	v
label_utim	atari/atari.c	/^local time_t label_utim = 0;$/;"	v
label_utim	atheos/atheos.c	/^local time_t label_utim = 0;$/;"	v
label_utim	beos/beos.c	/^local time_t label_utim = 0;$/;"	v
label_utim	cmsmvs/cmsmvs.c	/^local time_t label_utim = 0;$/;"	v
label_utim	msdos/msdos.c	/^local time_t label_utim = 0;$/;"	v
label_utim	novell/Netware.c	/^local time_t label_utim = 0;$/;"	v
label_utim	os2/os2.c	/^local time_t label_utim = 0;$/;"	v
label_utim	qdos/qfileio.c	/^local time_t label_utim = 0;$/;"	v
label_utim	theos/theos.c	/^local time_t label_utim = 0;$/;"	v
label_utim	tops20/tops20.c	/^local time_t label_utim = 0;$/;"	v
label_utim	unix/unix.c	/^local time_t label_utim = 0;$/;"	v
label_utim	vms/vmszip.c	/^local time_t label_utim = 0;$/;"	v
label_utim	win32/win32zip.c	/^local time_t label_utim = 0;$/;"	v
labels	proginfo/3rdparty.bug	/^   support volume labels, too.$/;"	v
last	fileio.c	/^char *last(p, c)$/;"	f
last_dist	trees.c	/^local unsigned last_dist;   \/* running index in d_buf *\/$/;"	v
last_flags	trees.c	/^local unsigned last_flags;  \/* running index in flag_buf *\/$/;"	v
last_lit	trees.c	/^local unsigned last_lit;    \/* running index in l_buf *\/$/;"	v
lastchar	tailor.h	360;"	d
lastchar	util.c	/^int lastchar(ptr)$/;"	f
lastfile	zip.c	/^struct filelist_struct *lastfile = NULL;  \/* last file in list *\/$/;"	v	typeref:struct:filelist_struct
lastfilter	zip.c	/^struct filterlist_struct *lastfilter = NULL;  \/* last filter in list *\/$/;"	v	typeref:struct:filterlist_struct
lastw	fileio.c	/^wchar_t *lastw(pw, c)$/;"	f
later	win32/gvmat64.asm	/^;    value of zlib1222add later)$/;"	v
latest	zip.c	/^local int latest = 0;   \/* 1=set zip file time to time of latest file *\/$/;"	v
latter	msdos/crc_i86.asm	/^; into "dec cx; jnz dest". On modern systems (486 and newer), the latter$/;"	v
lea	amiga/deflate.a	/^        lea     \\1,\\2$/;"	v
leap	msdos/msdos.c	1077;"	d	file:
leap	timezone.c	80;"	d	file:
leftStatusString	macos/source/helpers.c	/^void leftStatusString(char *status)$/;"	f	signature:(char *status)
len	qdos/qdos.c	/^    } len __attribute__ ((packed));$/;"	m	struct:__anon33	typeref:struct:__anon33::__anon34	file:	access:public
len	trees.c	/^        ush  len;        \/* length of bit string *\/$/;"	m	union:ct_data::__anon29	file:	access:public
len	win32/gvmat64.asm	/^ chainlenwmask   equ  rsp + 8 - LocalVarsSize    ; high word: current chain len$/;"	v
len	zip.h	/^  uzoff_t siz, len;             \/* zip64 support 08\/29\/2003 R.Nausedat *\/$/;"	m	struct:zlist	access:public
len_bd	vms/vms.h	/^    ush tag_bd; ush len_bd;     byte bd[ATR$S_BAKDATE];$/;"	m	struct:__anon23	access:public
len_bd	vms/vms.h	/^    ush tag_bd; ush len_bd;     byte bd[ATR$S_BAKDATE];$/;"	m	struct:__anon24	access:public
len_cd	vms/vms.h	/^    ush tag_cd; ush len_cd;     byte cd[ATR$S_CREDATE];$/;"	m	struct:__anon23	access:public
len_cd	vms/vms.h	/^    ush tag_cd; ush len_cd;     byte cd[ATR$S_CREDATE];$/;"	m	struct:__anon24	access:public
len_ed	vms/vms.h	/^    ush tag_ed; ush len_ed;     byte ed[ATR$S_EXPDATE];$/;"	m	struct:__anon23	access:public
len_ed	vms/vms.h	/^    ush tag_ed; ush len_ed;     byte ed[ATR$S_EXPDATE];$/;"	m	struct:__anon24	access:public
len_fp	vms/vms.h	/^    ush tag_fp; ush len_fp;     byte fp[ATR$S_FPRO];$/;"	m	struct:__anon23	access:public
len_fp	vms/vms.h	/^    ush tag_fp; ush len_fp;     byte fp[ATR$S_FPRO];$/;"	m	struct:__anon24	access:public
len_jr	vms/vms.h	/^    ush tag_jr; ush len_jr;     byte jr[ATR$S_JOURNAL];$/;"	m	struct:__anon23	access:public
len_jr	vms/vms.h	/^    ush tag_jr; ush len_jr;     byte jr[ATR$S_JOURNAL];$/;"	m	struct:__anon24	access:public
len_ra	vms/vms.h	/^    ush tag_ra; ush len_ra;     byte ra[ATR$S_RECATTR];$/;"	m	struct:__anon23	access:public
len_ra	vms/vms.h	/^    ush tag_ra; ush len_ra;     byte ra[ATR$S_RECATTR];$/;"	m	struct:__anon24	access:public
len_rd	vms/vms.h	/^    ush tag_rd; ush len_rd;     byte rd[ATR$S_REVDATE];$/;"	m	struct:__anon23	access:public
len_rd	vms/vms.h	/^    ush tag_rd; ush len_rd;     byte rd[ATR$S_REVDATE];$/;"	m	struct:__anon24	access:public
len_rn	vms/vms.h	/^    ush tag_rn; ush len_rn;     ush  rn;$/;"	m	struct:__anon23	access:public
len_rn	vms/vms.h	/^    ush tag_rn; ush len_rn;     ush  rn;$/;"	m	struct:__anon24	access:public
len_rp	vms/vms.h	/^    ush tag_rp; ush len_rp;     byte rp[ATR$S_RPRO];$/;"	m	struct:__anon23	access:public
len_rp	vms/vms.h	/^    ush tag_rp; ush len_rp;     byte rp[ATR$S_RPRO];$/;"	m	struct:__anon24	access:public
len_uc	vms/vms.h	/^    ush tag_uc; ush len_uc;     byte uc[ATR$S_UCHAR];$/;"	m	struct:__anon23	access:public
len_uc	vms/vms.h	/^    ush tag_uc; ush len_uc;     byte uc[ATR$S_UCHAR];$/;"	m	struct:__anon24	access:public
len_ui	vms/vms.h	/^    ush tag_ui; ush len_ui;     byte ui[ATR$S_UIC];$/;"	m	struct:__anon23	access:public
len_ui	vms/vms.h	/^    ush tag_ui; ush len_ui;     byte ui[ATR$S_UIC];$/;"	m	struct:__anon24	access:public
lenght	acorn/riscos.h	/^  int lenght;$/;"	m	struct:__anon9	access:public
length	proginfo/fileinfo.cms	/^     maximum expected length of the record, fread() returns the length,$/;"	v
length	vms/vms.h	/^    ush length;$/;"	m	struct:IZ_block	access:public
length	win32/crc_i386.asm	/^;   first item in each table is input buffer length, even multiple of 8$/;"	v
length	win32/crc_i386.asm	/^;   second item in each table is input buffer length, > 8$/;"	v
length	win32/crc_i386.asm	/^;   third item in each table is input buffer length, < 8$/;"	v
length_code	trees.c	/^local uch length_code[MAX_MATCH-MIN_MATCH+1];$/;"	v
level	cmsmvs/README.CMS	/^their level, etc.$/;"	v
level	globals.c	/^int level = 6;          \/* 0=fastest compression, 9=best compression *\/$/;"	v
lf	unix/configure	/^          lf='-Wl,-search_paths_first'$/;"	v
lflg	zip.h	/^  ush att, lflg;                \/* offset of lflg must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
lib$establish	vms/cmdline.c	99;"	d	file:
lib$establish	zip.h	361;"	d
lib$get_foreign	vms/cmdline.c	100;"	d	file:
lib$get_foreign	zip.h	362;"	d
lib$get_input	vms/cmdline.c	101;"	d	file:
lib$get_input	zip.h	363;"	d
lib$sig_to_ret	vms/cmdline.c	102;"	d	file:
lib$sig_to_ret	zip.h	364;"	d
libname	theos/theos.c	/^char* libname(char* path)$/;"	f	signature:(char* path)
library	bzip2/install.txt	/^file, "bzlib.h", and the object library, typically "libbz2.a", except$/;"	v
library	macos/Contents	/^  ZipLib.h          used to build a static library, global to the project$/;"	v	file:
library$	tags	/^functionality	LICENSE	\/^       modified or added functionality, and dynamic, shared, or static library$\/;"	v$/;"	v	file:
library$	tags	/^shared	LICENSE	\/^       modified or added functionality, and dynamic, shared, or static library$\/;"	v$/;"	v	file:
license	zip.c	/^local void license()$/;"	f
license	zipcloak.c	/^local void license()$/;"	f
license	zipnote.c	/^local void license()$/;"	f
license	zipsplit.c	/^local void license()$/;"	f
licensed	tandem/tandem.h	/^  unsigned licensed  : 1;$/;"	m	struct:nsk_file_attrs_def	access:public
licensing	bzip2/install.txt	/^the bzip2 code and algorithms or bzip2 licensing, for example, should be$/;"	v
limit	win32/gvmat64.asm	/^;;; IPos limit = s->strstart > (IPos)MAX_DIST(s) ?$/;"	v
line	windll/VBz64/readVB64.txt	/^do this is to open each file in WordPad, select and cut a line, paste$/;"	v
line	windll/Vb/readmeVB.txt	/^do this is to open each file in WordPad, select and cut a line, paste$/;"	v
lines	zip30.ann	/^  more readable command lines, and also allows lists for the -x$/;"	v
link	cmsmvs/cmsmvs.h	74;"	d
link	qdos/osdep.h	28;"	d
linkput	globals.c	/^int linkput = 0;              \/* 1=store symbolic links as such *\/$/;"	v
list	os2/os2zip.c	/^  FEA2 list[1];$/;"	m	struct:__anon15	file:	access:public
literal	amiga/deflate.a	/^        blo     literal$/;"	v
literal	human68k/deflate.s	/^        blo     literal$/;"	v
lm_free	deflate.c	/^void lm_free()$/;"	f
lm_init	deflate.c	/^void lm_init (pack_level, flags)$/;"	f
lo	qdos/qdos.c	/^        unsigned char lo __attribute__ ((packed));$/;"	m	struct:__anon33::__anon34	file:	access:public
load_addr	acorn/riscos.h	/^  unsigned int load_addr;$/;"	m	struct:__anon9	access:public
load_entry	macos/source/getenv.c	/^char *load_entry(FILE *file)$/;"	f	signature:(FILE *file)
loadaddr	acorn/riscos.h	/^  unsigned int  loadaddr;$/;"	m	struct:__anon10	access:public
loaded	acorn/ReadMe	/^means that if you have, say, SparkFS loaded, zipping a Spark archive will$/;"	v
local	zip.h	82;"	d
local_to_display_string	fileio.c	/^char *local_to_display_string(local_string)$/;"	f
local_to_escape_string	fileio.c	/^char *local_to_escape_string(local_string)$/;"	f
local_to_oem_string	win32/win32.c	/^char *local_to_oem_string(oem_string, local_string)$/;"	f
local_to_utf8_string	fileio.c	/^char *local_to_utf8_string(local_string)$/;"	f
local_to_wchar_string	win32/win32zip.c	/^wchar_t *local_to_wchar_string(local_string)$/;"	f
local_to_wide_string	fileio.c	/^zwchar *local_to_wide_string(local_string)$/;"	f
local_to_wide_string	win32/win32.c	/^zwchar *local_to_wide_string(local_string)$/;"	f
localtime	acorn/osdep.h	23;"	d
localtime	acorn/riscos.c	347;"	d	file:
localtime	msdos/msdos.c	1058;"	d	file:
localtime	msdos/osdep.h	203;"	d
localtime	novell/osdep.h	198;"	d
localtime	timezone.c	/^struct tm *localtime(when)$/;"	f
lodsb	win32/crc_i386.asm	/^;   than lodsb, and other misc. changes resulting in the following performance$/;"	v
logall	globals.c	/^int logall = 0;               \/* 0 = warnings\/errors, 1 = all *\/$/;"	v
logfile	globals.c	/^FILE *logfile = NULL;         \/* pointer to open logfile or NULL *\/$/;"	v
logfile_append	globals.c	/^int logfile_append = 0;       \/* append to existing logfile *\/$/;"	v
logfile_line_started	globals.c	/^int logfile_line_started = 0;     \/* 1=started writing a line to logfile *\/$/;"	v
logfile_path	globals.c	/^char *logfile_path = NULL;    \/* pointer to path of logfile *\/$/;"	v
logs	proginfo/txtvsbin.txt	/^including plain old texts, system logs, source code, formatted office$/;"	v
long_loop	msdos/match.asm	/^long_loop:$/;"	v
long_loop	os2/match32.asm	/^long_loop:$/;"	v
long_loop	win32/match32.asm	/^long_loop:$/;"	v
long_op_ambig_err	fileio.c	/^static ZCONST char Far long_op_ambig_err[] = "long option '%s' ambiguous";$/;"	v	file:
long_op_not_sup_err	fileio.c	/^static ZCONST char Far long_op_not_sup_err[] = "long option '%s' not supported";$/;"	v	file:
longer	proginfo/ZipPorts	/^      still compiles on machines dating back even longer, at least in spirit$/;"	v
longest_match	amiga/deflate.a	/^        bsr     longest_match           ; sets match_start$/;"	v
longest_match	amiga/deflate.a	/^;   QUADLONG   this selects a different version of the innermost longest_match$/;"	v
longest_match	amiga/match_68.a	/^        xdef    @longest_match      ; ditto$/;"	v
longest_match	deflate.c	/^int longest_match(cur_match)$/;"	f
longest_match	human68k/deflate.s	/^        bsr     longest_match           ; sets match_start$/;"	v
longest_match	human68k/deflate.s	/^;   QUADLONG   this selects a different version of the innermost longest_match$/;"	v
longest_match	win32/gvmat64.asm	/^; File written by Gilles Vollant, by converting to assembly the longest_match$/;"	v
longid	qdos/qdos.c	/^    char        longid[8] __attribute__ ((packed));$/;"	m	struct:__anon33	file:	access:public
longopt	zip.h	/^  char Far *longopt;        \/* char * to long option string *\/$/;"	m	struct:option_struct	access:public
lookahead	amiga/deflate.a	/^; strstart, lookahead, and window must be cached in Strst, Look, and Window:$/;"	v
lookahead	deflate.c	/^local unsigned      lookahead;     \/* number of valid bytes ahead in window *\/$/;"	v
lookahead	human68k/deflate.s	/^; strstart, lookahead, and window must be cached in Strst, Look, and Window:$/;"	v
loop	amiga/crc_68.a	/^; textlen parm is usually large enough so that savings outside the loop$/;"	v
loop	human68k/crc_68.s	/^; textlen parm is usually large enough so that savings outside the loop$/;"	v
loop	msdos/crc_i86.asm	/^; Optimized 8086 assembler version of the CRC32 calculation loop, intended$/;"	v
loop	win32/crc_i386.asm	/^;   avoid using loop, and j[e]cxz where possible.  Use mov + inc, rather$/;"	v
loop	win32/gvmat64.asm	/^;;; Within this loop:$/;"	v
loop	win32/gvmat64.asm	/^;;; majority of its time in this loop, and majority of that time will$/;"	v
low	zip.c	/^unsigned long low, high; \/* returning 64 bit values for systems without an _int64 *\/$/;"	v
lower	util.c	/^uch upper[256], lower[256];$/;"	v
lpZipPassword	api.c	/^DLLPASSWORD *lpZipPassword;$/;"	v
lpZipPrint	api.c	/^DLLPRNT *lpZipPrint;$/;"	v
lpZipUserFunctions	api.c	/^ZIPUSERFUNCTIONS ZipUserFunctions, far * lpZipUserFunctions;$/;"	v
lpZipUserFunctions	windll/example.c	/^LPZIPUSERFUNCTIONS lpZipUserFunctions;$/;"	v
lpszAltFNL	api.h	/^  LPSTR lpszAltFNL;     \/* pointer to a string containing a list of file$/;"	m	struct:__anon31	access:public
lpszZipFN	api.h	/^  LPSTR lpszZipFN;      \/* name of archive to create\/update *\/$/;"	m	struct:__anon31	access:public
lr	acorn/match.s	/^        ADD     r2, lr, ip$/;"	v
lr	acorn/match.s	/^        ADD     r3, lr, r0$/;"	v
lr	acorn/match.s	/^        LDR     lr, [pc, #|__window|-.-8]$/;"	v
lr	acorn/swiven.s	/^        LDR     lr, [sp ,#24]$/;"	v
lr	acorn/swiven.s	/^        LDR     lr, [sp ,#28]$/;"	v
lr	acorn/swiven.s	/^        LDR     lr, [sp, #4]$/;"	v
lr	acorn/swiven.s	/^        LDR     lr, [sp, #8]$/;"	v
lr	acorn/swiven.s	/^        LDR     lr, [sp]$/;"	v
lr	acorn/swiven.s	/^        TEQ     lr ,#0$/;"	v
lr	acorn/swiven.s	/^        TEQ     lr, #0$/;"	v
lrecl	proginfo/fileinfo.cms	/^     the open, the blksize can be a multiple of the lrecl, and the$/;"	v
lst	zip.h	/^  struct flist far *far *lst;   \/* Pointer to link pointing here *\/$/;"	m	struct:flist	typeref:struct:flist::far	access:public
lstat	macos/ZipLib.h	63;"	d
lstat	macos/ZipSx.h	62;"	d
m	ttyio.c	/^    ZCONST char *m;             \/* prompt for password *\/$/;"	v
m	zipfile.c	/^  extent m;                 \/* length of zip file comment (0 if none) *\/$/;"	v
macgetch	macos/source/macos.c	/^int macgetch(void)$/;"	f	signature:(void)
machine	proginfo/txtvsbin.txt	/^intended reader of that file is a machine, rather than a human.$/;"	v
macro	proginfo/ZipPorts	/^      and therefore are included in the UNIX macro, but DOS djgpp ports and$/;"	v
macros	msdos/crc_i86.asm	/^; of CPU type related macros:$/;"	v
macros	msdos/crc_i86.asm	/^; related macros:$/;"	v
macros	msdos/match.asm	/^; of CPU type related macros:$/;"	v
main	cmsmvs/cmsmvs.c	/^int main(void)$/;"	f	signature:(void)
main	macos/source/macos.c	/^int main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	unix/configure	/^int main()$/;"	f
main	vms/cmdline.c	/^main(int argc, char **argv)     \/* Main program. *\/$/;"	f	signature:(int argc, char **argv)
main	vms/vms_msg_gen.c	/^main()$/;"	f
main	windll/example.c	/^int main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	zipcloak.c	/^int main()$/;"	f
main	zipcloak.c	/^int main(argc, argv)$/;"	f
main	zipnote.c	/^int main(argc, argv)$/;"	f
main	zipsplit.c	/^int main(argc, argv)$/;"	f
major	api.h	/^    uch major;              \/* e.g., integer 5 *\/$/;"	m	struct:_zip_ver	access:public
make_EF_Head_MAC3	macos/source/extrafld.c	/^static char *make_EF_Head_MAC3(char *ef, unsigned compsize, ulg attrsize,$/;"	f	file:	signature:(char *ef, unsigned compsize, ulg attrsize, unsigned flag)
make_crc_table	crc32.c	/^local void make_crc_table()$/;"	f
make_extrafield_JLEE	macos/source/extrafld.c	/^static void make_extrafield_JLEE(char *ef)$/;"	f	file:	signature:(char *ef)
make_extrafield_MAC3	macos/source/extrafld.c	/^unsigned make_extrafield_MAC3(char *ef)$/;"	f	signature:(char *ef)
mark	zip.h	/^  int mark;                     \/* Marker for files to operate on *\/$/;"	m	struct:zlist	access:public
masm	win32/gvmat64.asm	/^;  and by taking inspiration on asm686 with masm, optimised assembly code $/;"	v
match	theos/theos.c	/^int match(char *s, char *p)    \/*S Returns non-zero if string matches$/;"	f	signature:(char *s, char *p)
match_init	amiga/match_68.a	/^        xdef    @match_init         ; for SAS assembler$/;"	v
match_length	amiga/deflate.a	/^MatchL  equr    d3              ; local variable match_length, unsigned short$/;"	v
match_length	human68k/deflate.s	/^MatchL  reg     d3              ; local variable match_length, unsigned short$/;"	v
match_start	amiga/deflate.a	/^        ; CHECK_MATCH   Strst,match_start,MatchL$/;"	v
match_start	deflate.c	/^      unsigned near match_start;   \/* start of matching string *\/$/;"	v
match_start	human68k/deflate.s	/^        ; CHECK_MATCH   Strst,match_start,MatchL$/;"	v
match_start	msdos/match.asm	/^        ma_start equ cs:match_start     ; does not work on OS\/2$/;"	v
match_start	win32/gvmat64.asm	/^        mov match_start, r8d$/;"	v
matching	zip.txt	/^              pattern matching, and more obscure options.$/;"	v
max	amiga/filedate.c	172;"	d	file:
max	os2/os2zip.c	42;"	d	file:
maxLevels	macos/source/recurse.c	/^    unsigned short          maxLevels;      \/* Maximum levels to$/;"	m	struct:RecurseGlobals	file:	access:public
max_chain	deflate.c	/^   ush max_chain;$/;"	m	struct:config	file:	access:public
max_chain_length	deflate.c	/^unsigned near max_chain_length;$/;"	v
max_chain_length	os2/match32.asm	/^        mov     ebp,max_chain_length    ; chain_length = max_chain_length$/;"	v
max_code	trees.c	/^    int     max_code;            \/* largest code with non zero frequency *\/$/;"	m	struct:tree_desc	file:	access:public
max_insert_length	deflate.c	205;"	d	file:
max_lazy	deflate.c	/^   ush max_lazy;    \/* do not perform lazy search above this match length *\/$/;"	m	struct:config	file:	access:public
max_lazy_match	deflate.c	/^local unsigned int max_lazy_match;$/;"	v
max_length	trees.c	/^    int     max_length;          \/* max bit length for the codes *\/$/;"	m	struct:tree_desc	file:	access:public
maxext	tandem/tandem.h	/^  unsigned maxext    : 10;$/;"	m	struct:nsk_file_attrs_def	access:public
maxmatch	msdos/match.asm	/^        je      maxmatch                ; match of length MAX_MATCH?$/;"	v
maxmatch	os2/match32.asm	/^        je      maxmatch                ; match of length MAX_MATCH?$/;"	v
maxmatch	win32/lm32_lcc.asm	/^        je      maxmatch$/;"	v
maxmatch	win32/match32.asm	/^        je      short maxmatch          ; match of length MAX_MATCH?$/;"	v
mb_clen	fileio.c	/^  int mb_clen(ptr)$/;"	f
means	msdos/crc_i86.asm	/^;   This means:$/;"	v
mem_read	zipup.c	/^local unsigned mem_read(b, bsize)$/;"	f
memcmp	fileio.c	/^memcmp(b1,b2,len)                     \/* jpd@usl.edu -- 11\/16\/90 *\/$/;"	f
memcompress	zipup.c	/^ulg memcompress(tgt, tgtsize, src, srcsize)$/;"	f
memcpy	fileio.c	/^memcpy(dst,src,len)             \/* v2.0f *\/$/;"	f
memmove	unix/unix.c	/^void *memmove(dest0, source0, length)$/;"	f
memset	fileio.c	/^memset(buf, init, len)$/;"	f
memtoasc	util.c	/^char *memtoasc(char *mem1, ZCONST char *mem2, unsigned len)$/;"	f	signature:(char *mem1, ZCONST char *mem2, unsigned len)
memtoebc	util.c	/^char *memtoebc(char *mem1, ZCONST char *mem2, unsigned len)$/;"	f	signature:(char *mem1, ZCONST char *mem2, unsigned len)
mesg	globals.c	/^FILE *mesg;             \/* stdout by default, stderr for piping *\/$/;"	v
mesg_line_started	globals.c	/^int mesg_line_started = 0;        \/* 1=started writing a line to mesg *\/$/;"	v
messages	msdos/crc_i86.asm	/^; Setup of amount of assemble time informational messages:$/;"	v
method	globals.c	/^int method = BEST;      \/* one of BEST, DEFLATE (only), or STORE (only) *\/$/;"	v
min	amiga/filedate.c	171;"	d	file:
minix	INSTALL	/^     att6300, coherent, cray_v3, minix, sco_x286, xenix, zilog.$/;"	v
minor	api.h	/^    uch minor;              \/* e.g., 2 *\/$/;"	m	struct:_zip_ver	access:public
missed	zip.txt	/^              archive are missed, then try$/;"	v
missing	acorn/match.s	/^; If, for some reason, both of these files are missing, the Info-ZIP license$/;"	v
missing	acorn/sendbits.s	/^; If, for some reason, both of these files are missing, the Info-ZIP license$/;"	v
missing	acorn/swiven.s	/^; If, for some reason, both of these files are missing, the Info-ZIP license$/;"	v
missing	amiga/crc_68.a	/^; If, for some reason, all these files are missing, the Info-ZIP license$/;"	v
missing	amiga/deflate.a	/^; If, for some reason, both of these files are missing, the Info-ZIP license$/;"	v
missing	amiga/match.a	/^; If, for some reason, both of these files are missing, the Info-ZIP license$/;"	v
missing	amiga/match_68.a	/^; If, for some reason, both of these files are missing, the Info-ZIP license$/;"	v
missing	human68k/crc_68.s	/^; If, for some reason, all these files are missing, the Info-ZIP license$/;"	v
missing	human68k/deflate.s	/^; If, for some reason, both of these files are missing, the Info-ZIP license$/;"	v
missing	human68k/match.s	/^* If, for some reason, both of these files are missing, the Info-ZIP license$/;"	v
missing	msdos/crc_i86.asm	/^; If, for some reason, all these files are missing, the Info-ZIP license$/;"	v
missing	msdos/match.asm	/^; If, for some reason, all these files are missing, the Info-ZIP license$/;"	v
missing	os2/match32.asm	/^; If, for some reason, all these files are missing, the Info-ZIP license$/;"	v
missing	qdos/config.s	/^; If, for some reason, both of these files are missing, the Info-ZIP license$/;"	v
missing	qdos/crc68.s	/^; If, for some reason, all these files are missing, the Info-ZIP license$/;"	v
missing	qdos/match.s	/^; If, for some reason, both of these files are missing, the Info-ZIP license$/;"	v
missing	win32/crc_i386.asm	/^; If, for some reason, all these files are missing, the Info-ZIP license$/;"	v
missing	win32/crc_lcc.asm	/^; If, for some reason, all these files are missing, the Info-ZIP license$/;"	v
missing	win32/lm32_lcc.asm	/^; If, for some reason, both of these files are missing, the Info-ZIP license$/;"	v
missing	win32/match32.asm	/^; If, for some reason, all these files are missing, the Info-ZIP license$/;"	v
missing	zip.txt	/^              this file is missing, you must use -FF to fix the archive, which$/;"	v
mistake	proginfo/txtvsbin.txt	/^codes, either by mistake, or by peculiar design considerations.  In such$/;"	v
mkgmtime	timezone.c	/^time_t mkgmtime(tm)$/;"	f
mktime	timezone.c	/^time_t mktime(tm)$/;"	f
mode	proginfo/fileinfo.cms	/^  * If you have specified a read mode, C\/370 looks for the named file$/;"	v
mode	zip.txt	/^       The new File Sync option (-FS) is also considered a new mode, though it$/;"	v
model	msdos/crc_i86.asm	/^; Selection of memory model, and initialization of memory model$/;"	v
model	proginfo/fileinfo.cms	/^     but because CMS follows the record model, you must still account$/;"	v
models	msdos/crc_i86.asm	/^; The code in this module should work with all kinds of C memory models$/;"	v
modified	win32/crc_i386.asm	/^; registers modified:$/;"	v
modtime	tailor.h	/^    time_t modtime;             \/* new modification time *\/$/;"	m	struct:ztimbuf	access:public
modtime	vms/vmsmunch.h	/^    char *modtime;      \/* VMS creation date, ASCII format *\/$/;"	m	struct:VMStimbuf	access:public
module	msdos/crc_i86.asm	/^; Declare the segments used in this module:$/;"	v
mon_lengths	timezone.c	/^static ZCONST int    mon_lengths[2][MONSPERYEAR] = {$/;"	v	file:
monthlen	timezone.c	89;"	d	file:
more	amiga/crc_68.a	/^; Define NO_UNROLLED_LOOPS to use a simple short loop which might be more$/;"	v
more	human68k/crc_68.s	/^; Define NO_UNROLLED_LOOPS to use a simple short loop which might be more$/;"	v
more	tops20/tops20.c	/^   int  more;$/;"	m	struct:__anon3	file:	access:public
mov	win32/gvmat64.asm	/^        mov [chainlenwmask], ebx$/;"	v
mov	win32/gvmat64.asm	/^        mov [nicematch],r10d$/;"	v
mov	win32/gvmat64.asm	/^        mov [save_r12],r12$/;"	v
mov	win32/gvmat64.asm	/^        mov [save_r13],r13$/;"	v
mov	win32/gvmat64.asm	/^        mov [save_rbp],rbp$/;"	v
mov	win32/gvmat64.asm	/^        mov [save_rbx],rbx$/;"	v
mov	win32/gvmat64.asm	/^        mov [save_rdi],rdi$/;"	v
mov	win32/gvmat64.asm	/^        mov [save_rsi],rsi$/;"	v
moveq	amiga/deflate.a	/^        moveq   #0,Avail$/;"	v
moveq	amiga/deflate.a	/^        moveq   #0,Head                 ; ditto for hash_head$/;"	v
moveq	amiga/deflate.a	/^        moveq   #0,MatchL               ; not needed?$/;"	v
moveq	amiga/deflate.a	/^        moveq   #0,MatchL$/;"	v
moveq	amiga/deflate.a	/^        moveq   #0,PrevL                ; not needed?$/;"	v
moveq	amiga/deflate.a	/^        moveq   #0,Scan_End             ; likewise$/;"	v
moveq	amiga/deflate.a	/^        moveq   #0,Scan_Start           ; clear 2nd & 4th bytes, use 1st & 3rd$/;"	v
moveq	amiga/deflate.a	/^        moveq   #0,Scan_Test            ; likewise$/;"	v
moveq	amiga/deflate.a	/^        moveq   #0,d0$/;"	v
moveq	amiga/deflate.a	/^        moveq   #0,d1                   ; preserve d0$/;"	v
moveq	amiga/match_68.a	/^        moveq   #0,Scan_End$/;"	v
moveq	amiga/match_68.a	/^        moveq   #0,Scan_Start       ; clear 2nd and 4th bytes, use 1st & 3rd$/;"	v
moveq	amiga/match_68.a	/^        moveq   #0,Scan_Test$/;"	v
moveq	human68k/deflate.s	/^        moveq   #0,Avail$/;"	v
moveq	human68k/deflate.s	/^        moveq   #0,Head                 ; ditto for hash_head$/;"	v
moveq	human68k/deflate.s	/^        moveq   #0,MatchL               ; not needed?$/;"	v
moveq	human68k/deflate.s	/^        moveq   #0,MatchL$/;"	v
moveq	human68k/deflate.s	/^        moveq   #0,PrevL                ; not needed?$/;"	v
moveq	human68k/deflate.s	/^        moveq   #0,Scan_End             ; likewise$/;"	v
moveq	human68k/deflate.s	/^        moveq   #0,Scan_Start           ; clear 2nd & 4th bytes, use 1st & 3rd$/;"	v
moveq	human68k/deflate.s	/^        moveq   #0,Scan_Test            ; likewise$/;"	v
moveq	human68k/deflate.s	/^        moveq   #0,d0$/;"	v
moveq	human68k/deflate.s	/^        moveq   #0,d1                   ; preserve d0$/;"	v
moveq	qdos/crc68.s	/^        moveq  #0,d0$/;"	v
moveq	qdos/crc68.s	/^loop8:  moveq  #0,d3$/;"	v
moveq	qdos/match.s	/^        moveq   #0,d5$/;"	v
msc7_localtime	msdos/msdos.c	/^struct tm *msc7_localtime(const time_t *clock)$/;"	f	signature:(const time_t *clock)
msname	fileio.c	/^char *msname(n)$/;"	f
msnamew	fileio.c	/^wchar_t *msnamew(nw)$/;"	f
mtime	zip.h	/^   time_t mtime;                \/* new modification time *\/$/;"	m	struct:iztimes	access:public
much	amiga/deflate.a	/^; This code is not commented very much; see deflate.c for comments that explain$/;"	v
much	human68k/deflate.s	/^; This code is not commented very much; see deflate.c for comments that explain$/;"	v
myReadLocation	macos/source/mactime.c	/^static void myReadLocation(MachineLocation * loc)$/;"	f	file:	signature:(MachineLocation * loc)
my_gmtime	macos/source/mactime.c	/^struct tm *my_gmtime(const time_t *timer)$/;"	f	signature:(const time_t *timer)
my_gmtime	macos/source/mactime.c	49;"	d	file:
my_localtime	macos/source/mactime.c	/^struct tm *my_localtime(const time_t *timer)$/;"	f	signature:(const time_t *timer)
my_localtime	macos/source/mactime.c	50;"	d	file:
my_mktime	macos/source/mactime.c	/^time_t my_mktime(struct tm *tp)$/;"	f	signature:(struct tm *tp)
my_mktime	macos/source/mactime.c	51;"	d	file:
my_open	macos/source/macopen.c	/^int my_open(char *path, int oflag)$/;"	f	signature:(char *path, int oflag)
my_time	macos/source/mactime.c	/^time_t my_time(time_t *time)$/;"	f	signature:(time_t *time)
my_time	macos/source/mactime.c	52;"	d	file:
myftw	atari/atari.c	/^static int myftw( int depth )$/;"	f	file:	signature:( int depth )
n	tandem/tandem.c	/^  char *n;              \/* internal file name *\/$/;"	v
n	ttyio.c	/^    int n;                      \/* bytes available in p[] *\/$/;"	v
nID	os2/os2zip.c	/^  USHORT nID;$/;"	m	struct:__anon13	file:	access:public
nID	win32/nt.h	/^  USHORT nID;   \/* tag for this extra block type *\/$/;"	m	struct:__anon5	access:public
nID	win32/nt.h	/^  USHORT nID;$/;"	m	struct:__anon4	access:public
nSize	os2/os2zip.c	/^  USHORT nSize;$/;"	m	struct:__anon13	file:	access:public
nSize	win32/nt.h	/^  USHORT nSize; \/* total data size for this block *\/$/;"	m	struct:__anon5	access:public
nSize	win32/nt.h	/^  USHORT nSize;$/;"	m	struct:__anon4	access:public
nam	vms/vms_im.c	/^    struct NAM_STRUCT *nam;$/;"	m	struct:user_context	typeref:struct:user_context::NAM_STRUCT	file:	access:public
nam	vms/vmszip.c	/^  struct NAM_STRUCT nam;$/;"	m	struct:zdirent	typeref:struct:zdirent::NAM_STRUCT	file:	access:public
nam	zip.h	/^  ush nam, ext, cext, com;      \/* offset of ext must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
name	acorn/riscos.h	/^  char name[13];$/;"	m	struct:__anon9	access:public
name	vms/vms.c	/^   char *name;$/;"	m	struct:__anon27	file:	access:public
name	zip.c	/^    char *name;$/;"	m	struct:filelist_struct	file:	access:public
name	zip.h	/^  char *name;                   \/* File name in zip file *\/$/;"	m	struct:zlist	access:public
name	zip.h	/^  char *name;                   \/* Raw internal file name *\/$/;"	m	struct:flist	access:public
name	zip.h	/^  char Far *name;           \/* optional string for option returned on some errors *\/$/;"	m	struct:option_struct	access:public
name	zip.txt	/^       where the option starts with --, has a multicharacter name, can include$/;"	v
name	ziperr.h	/^    char *name;$/;"	m	struct:__anon1	access:public
name	ziperr.h	/^    char *name;$/;"	m	struct:__anon2	access:public
name	zipsplit.c	/^local char *name;               \/* where name goes in path[] *\/$/;"	v
name$	tags	/^archive	man\/zip.1	\/^In cmd, {} is replaced by the name of the temporary archive, otherwise the name$\/;"	v$/;"	v
namecmp	util.c	/^int namecmp(string1, string2)$/;"	f
named	acorn/ReadMe	/^exactly as named; in this example:$/;"	v
namew	zip.h	/^  wchar_t *namew;               \/* Windows wide character version of name *\/$/;"	m	struct:flist	access:public
namew	zip.h	/^  wchar_t *namew;               \/* Windows wide character version of name *\/$/;"	m	struct:zlist	access:public
ndexed	proginfo/extrafld.txt	/^          filegrow      Byte        growing factor for indexed,keyed and direct$/;"	v
ndexed	proginfo/extrafld.txt	/^          reclen        Short       record length for indexed,keyed and direct,$/;"	v
near	api.h	34;"	d
near	msdos/match.asm	/^        extrn   _exit : near            ; 'near' for compact model$/;"	v
near	msdos/match.asm	/^_longest_match  proc near                ; 'proc near' for compact model$/;"	v
near	msdos/match.asm	/^_match_init proc near                   ; 'proc near' for compact model$/;"	v
near	tailor.h	470;"	d
near	tailor.h	474;"	d
near	tailor.h	484;"	d
near	win32/crc_i386.asm	/^extrn   _get_crc_table:near    ; ZCONST ulg near *get_crc_table(void);$/;"	v
near	windll/structs.h	23;"	d
nearfree	msdos/osdep.h	97;"	d
nearfree	novell/osdep.h	97;"	d
nearfree	os2/osdep.h	64;"	d
nearfree	tailor.h	488;"	d
nearmalloc	msdos/osdep.h	96;"	d
nearmalloc	novell/osdep.h	96;"	d
nearmalloc	os2/osdep.h	63;"	d
nearmalloc	tailor.h	487;"	d
needed	zip30f.ann	/^  files on the file system, adding, updating, and deleting entries as needed,$/;"	v
negatable	zip.h	/^  int  negatable;           \/* from above *\/$/;"	m	struct:option_struct	access:public
nenu	human68k/deflate.s	/^        local   nenu,nun$/;"	v
new	vms/cvthelp.tpu	/^        copy_text(new);$/;"	v
new	vms/cvthelp.tpu	/^!               copy_text(new); split_line;$/;"	v
new_ptr	msdos/msdos.c	/^    zvoid far *new_ptr;$/;"	m	struct:ptr_table_s	file:	access:public
newname	fileio.c	/^int newname(name, isdir, casesensitive)$/;"	f
newnamew	fileio.c	/^int newnamew(namew, isdir, casesensitive)$/;"	f
next	zip.c	/^    struct filelist_struct *next;$/;"	m	struct:filelist_struct	typeref:struct:filelist_struct::filelist_struct	file:	access:public
next	zip.c	/^    struct filterlist_struct *next;$/;"	m	struct:filterlist_struct	typeref:struct:filterlist_struct::filterlist_struct	file:	access:public
next_arg	novell/Netware.c	/^char *next_arg(char *s)$/;"	f	signature:(char *s)
next_ptr	msdos/msdos.c	/^local int next_ptr = 0;$/;"	v
nextspace	novell/Netware.c	24;"	d	file:
nice	msdos/match.asm	/^        mov     nice,ax                 ; ugly write to code, crash on OS\/2$/;"	v
nice_length	deflate.c	/^   ush nice_length; \/* quit search above this match length *\/$/;"	m	struct:config	file:	access:public
nice_match	deflate.c	/^  int near nice_match; \/* Stop searching when current match exceeds this *\/$/;"	v
nice_match	deflate.c	215;"	d	file:
nice_match	win32/gvmat64.asm	/^; on infozip nice_match = [nice_match]$/;"	v
nix	macos/README.TXT	/^Zip is a compression and file packaging utility for Unix,$/;"	v
nleap	msdos/msdos.c	1080;"	d	file:
nleap	timezone.c	86;"	d	file:
no_arg_files_err	fileio.c	/^static ZCONST char Far no_arg_files_err[] = "argument files not enabled\\n";$/;"	v	file:
no_wild	globals.c	/^int no_wild = 0;             \/* 1 = wildcards are disabled *\/$/;"	v
no_win32_wide	globals.c	/^   int no_win32_wide = -1; \/* 1 = no wide functions, like GetFileAttributesW() *\/$/;"	v
noisy	globals.c	/^int noisy = 1;                \/* 0=quiet operation *\/$/;"	v
noisy_splits	globals.c	/^int noisy_splits = 0;             \/* note when splits are being created *\/$/;"	v
nonlocal_name	globals.c	/^  int nonlocal_name = 0;          \/* Name has non-local characters *\/$/;"	v
nonlocal_path	globals.c	/^  int nonlocal_path = 0;          \/* Path has non-local characters *\/$/;"	v
nonportable	amiga/deflate.a	/^;               Runtime test is nonportable; it is different for each OS.$/;"	v
nonportable	human68k/deflate.s	/^;               Runtime test is nonportable; it is different for each OS.$/;"	v
norm_fstat_packet	aosvs/aosvs.c	/^     P_FSTAT        norm_fstat_packet;      \/* normal fstat packet *\/$/;"	m	union:zvsfstat_stru	file:	access:public
normalize	macos/source/mactime.c	/^static void normalize(int *i,int *j,int norm)$/;"	f	file:	signature:(int *i,int *j,int norm)
not	amiga/deflate.a	/^; longest_match, above, and some outside functions.  It is a hot spot, but not$/;"	v
not	human68k/deflate.s	/^; longest_match, above, and some outside functions.  It is a hot spot, but not$/;"	v
not_used	api.h	/^    uch not_used;$/;"	m	struct:_zip_ver	access:public
nothing	msdos/crc_i86.asm	/^        ASSUME  DS: nothing, SS: DGROUP$/;"	v
nothing	msdos/crc_i86.asm	/^;       ASSUME  DS: nothing$/;"	v
now	README.CR	/^source distributions for all of these now, but the encryption patch is still$/;"	v
nsk_delim	tandem/tanzip.c	/^  char nsk_delim[2] = {'\\r', '\\n'}; \/* CR\/LF *\/$/;"	v
nsk_delim_len	tandem/tanzip.c	/^  int nsk_delim_len = 2;$/;"	v
nsk_ef_region	tandem/tandem.h	/^  nsk_file_attrs nsk_ef_region;$/;"	m	struct:nsk_stat_overlay	access:public
nsk_file_attrs	tandem/tandem.h	/^typedef struct nsk_file_attrs_def nsk_file_attrs;$/;"	t	typeref:struct:nsk_file_attrs_def
nsk_file_attrs_def	tandem/tandem.h	/^struct nsk_file_attrs_def$/;"	s
nsk_file_attrs_def::block	tandem/tandem.h	/^  unsigned short block;     \/* 16 *\/  \/* Allow of block > 4096 one day ! *\/$/;"	m	struct:nsk_file_attrs_def	access:public
nsk_file_attrs_def::delete	tandem/tandem.h	/^  unsigned delete    : 3;$/;"	m	struct:nsk_file_attrs_def	access:public
nsk_file_attrs_def::execute	tandem/tandem.h	/^  unsigned execute   : 3;$/;"	m	struct:nsk_file_attrs_def	access:public
nsk_file_attrs_def::filecode	tandem/tandem.h	/^  unsigned short filecode;  \/* 16 *\/$/;"	m	struct:nsk_file_attrs_def	access:public
nsk_file_attrs_def::fileopen	tandem/tandem.h	/^  unsigned fileopen  : 1;$/;"	m	struct:nsk_file_attrs_def	access:public
nsk_file_attrs_def::filetype	tandem/tandem.h	/^  unsigned filetype  : 2;$/;"	m	struct:nsk_file_attrs_def	access:public
nsk_file_attrs_def::flags	tandem/tandem.h	/^  struct nsk_file_flags flags;     \/* 16 *\/$/;"	m	struct:nsk_file_attrs_def	typeref:struct:nsk_file_attrs_def::nsk_file_flags	access:public
nsk_file_attrs_def::keylen	tandem/tandem.h	/^  unsigned keylen    : 8;$/;"	m	struct:nsk_file_attrs_def	access:public
nsk_file_attrs_def::keyoff	tandem/tandem.h	/^  unsigned keyoff    : 11;$/;"	m	struct:nsk_file_attrs_def	access:public
nsk_file_attrs_def::licensed	tandem/tandem.h	/^  unsigned licensed  : 1;$/;"	m	struct:nsk_file_attrs_def	access:public
nsk_file_attrs_def::maxext	tandem/tandem.h	/^  unsigned maxext    : 10;$/;"	m	struct:nsk_file_attrs_def	access:public
nsk_file_attrs_def::owner	tandem/tandem.h	/^  struct nsk_owner owner;   \/* 16 *\/$/;"	m	struct:nsk_file_attrs_def	typeref:struct:nsk_file_attrs_def::nsk_owner	access:public
nsk_file_attrs_def::priext	tandem/tandem.h	/^  unsigned short priext;    \/* 16 *\/$/;"	m	struct:nsk_file_attrs_def	access:public
nsk_file_attrs_def::progid	tandem/tandem.h	/^  unsigned progid    : 1;$/;"	m	struct:nsk_file_attrs_def	access:public
nsk_file_attrs_def::read	tandem/tandem.h	/^  unsigned read      : 3;$/;"	m	struct:nsk_file_attrs_def	access:public
nsk_file_attrs_def::reclen	tandem/tandem.h	/^  unsigned reclen    : 12;$/;"	m	struct:nsk_file_attrs_def	access:public
nsk_file_attrs_def::secext	tandem/tandem.h	/^  unsigned short secext;    \/* 16 *\/$/;"	m	struct:nsk_file_attrs_def	access:public
nsk_file_attrs_def::write	tandem/tandem.h	/^  unsigned write     : 3;$/;"	m	struct:nsk_file_attrs_def	access:public
nsk_file_flags	tandem/tandem.h	/^struct nsk_file_flags$/;"	s
nsk_file_flags::acompress	tandem/tandem.h	/^  unsigned acompress   : 1;$/;"	m	struct:nsk_file_flags	access:public
nsk_file_flags::audited	tandem/tandem.h	/^  unsigned audited     : 1;$/;"	m	struct:nsk_file_flags	access:public
nsk_file_flags::broken	tandem/tandem.h	/^  unsigned broken      : 1;$/;"	m	struct:nsk_file_flags	access:public
nsk_file_flags::buffered	tandem/tandem.h	/^  unsigned buffered    : 1;$/;"	m	struct:nsk_file_flags	access:public
nsk_file_flags::clearonpurge	tandem/tandem.h	/^  unsigned clearonpurge: 1;$/;"	m	struct:nsk_file_flags	access:public
nsk_file_flags::corrupt	tandem/tandem.h	/^  unsigned corrupt     : 1;$/;"	m	struct:nsk_file_flags	access:public
nsk_file_flags::crashopen	tandem/tandem.h	/^  unsigned crashopen   : 1;$/;"	m	struct:nsk_file_flags	access:public
nsk_file_flags::dcompress	tandem/tandem.h	/^  unsigned dcompress   : 1;$/;"	m	struct:nsk_file_flags	access:public
nsk_file_flags::icompress	tandem/tandem.h	/^  unsigned icompress   : 1;$/;"	m	struct:nsk_file_flags	access:public
nsk_file_flags::oddunstr	tandem/tandem.h	/^  unsigned oddunstr    : 1;$/;"	m	struct:nsk_file_flags	access:public
nsk_file_flags::primpart	tandem/tandem.h	/^  unsigned primpart    : 1;$/;"	m	struct:nsk_file_flags	access:public
nsk_file_flags::refresheof	tandem/tandem.h	/^  unsigned refresheof  : 1;$/;"	m	struct:nsk_file_flags	access:public
nsk_file_flags::rollforward	tandem/tandem.h	/^  unsigned rollforward : 1;$/;"	m	struct:nsk_file_flags	access:public
nsk_file_flags::secpart	tandem/tandem.h	/^  unsigned secpart     : 1;$/;"	m	struct:nsk_file_flags	access:public
nsk_file_flags::serial	tandem/tandem.h	/^  unsigned serial      : 1;$/;"	m	struct:nsk_file_flags	access:public
nsk_file_flags::verified	tandem/tandem.h	/^  unsigned verified    : 1;$/;"	m	struct:nsk_file_flags	access:public
nsk_large_read	tandem/tanzip.c	/^  unsigned short nsk_large_read = MAX_LARGE_READ;$/;"	v
nsk_owner	tandem/tandem.h	/^struct nsk_owner$/;"	s
nsk_owner::group	tandem/tandem.h	/^  unsigned group   : 8;$/;"	m	struct:nsk_owner	access:public
nsk_owner::user	tandem/tandem.h	/^  unsigned user    : 8;$/;"	m	struct:nsk_owner	access:public
nsk_space_fill	tandem/tanzip.c	/^  int nsk_space_fill = 0;   \/* 0 = No, 1 = Yes          *\/$/;"	v
nsk_stat_ov	tandem/tandem.h	/^} nsk_stat_ov;$/;"	t	typeref:union:__anon35
nsk_stat_overlay	tandem/tandem.h	/^struct nsk_stat_overlay$/;"	s
nsk_stat_overlay::creation_time	tandem/tandem.h	/^  time_t creation_time;       \/* 32 bits *\/$/;"	m	struct:nsk_stat_overlay	access:public
nsk_stat_overlay::nsk_ef_region	tandem/tandem.h	/^  nsk_file_attrs nsk_ef_region;$/;"	m	struct:nsk_stat_overlay	access:public
nsk_stat_reserved	tandem/tandem.h	/^struct nsk_stat_reserved$/;"	s
nsk_stat_reserved::spare	tandem/tandem.h	/^  int64_t spare[3];$/;"	m	struct:nsk_stat_reserved	access:public
nsk_trim_space	tandem/tanzip.c	/^  int nsk_trim_space = 0;   \/* 0 = No, 1 = Yes          *\/$/;"	v
nskformatopt	tandem/tanzip.c	/^void nskformatopt(p)$/;"	f
nskopen	tandem/tanzip.c	/^FILE *nskopen(fname, opt)$/;"	f
null	unix/configure	/^  if \/usr\/bin\/hostinfo | grep NeXT > \/dev\/null; then$/;"	v
num_req_val_err	fileio.c	/^static ZCONST char Far num_req_val_err[] = "option %s requires number value";$/;"	v	file:
nxt	zip.h	/^  struct flist far *nxt;        \/* Link to next name *\/$/;"	m	struct:flist	typeref:struct:flist::far	access:public
nxt	zip.h	/^  struct zlist far *nxt;        \/* Pointer to next header in list *\/$/;"	m	struct:zlist	typeref:struct:zlist::far	access:public
ny	amiga/match_68.a	/^; Amiga.  Hopefully a similar test for the Macintosh is possible, and for any$/;"	v
oERR	fileio.c	3620;"	d	file:
oNext	os2/os2zip.c	/^  ULONG oNext;$/;"	m	struct:__anon11	file:	access:public
oNext	os2/os2zip.c	/^  ULONG oNext;$/;"	m	struct:__anon12	file:	access:public
oNextEntryOffset	os2/os2zip.c	/^  ULONG oNextEntryOffset;$/;"	m	struct:__anon14	file:	access:public
oWARN	fileio.c	3619;"	d	file:
o_AC	zip.c	1897;"	d	file:
o_ARG_FILE_ERR	zip.h	1022;"	d
o_AS	zip.c	1898;"	d	file:
o_C2	zip.c	1899;"	d	file:
o_C5	zip.c	1900;"	d	file:
o_DF	zip.c	1906;"	d	file:
o_FF	zip.c	1911;"	d	file:
o_FI	zip.c	1912;"	d	file:
o_FS	zip.c	1913;"	d	file:
o_MM	zip.c	1922;"	d	file:
o_NEGATABLE	zip.h	1013;"	d
o_NON_OPTION_ARG	zip.h	1020;"	d
o_NOT_NEGATABLE	zip.h	1012;"	d
o_NO_OPTION_MATCH	zip.h	1017;"	d
o_NO_VALUE	zip.h	1003;"	d
o_NUMBER_VALUE	zip.h	1008;"	d
o_ONE_CHAR_VALUE	zip.h	1007;"	d
o_OPTIONAL_VALUE	zip.h	1005;"	d
o_RE	zip.c	1924;"	d	file:
o_REQUIRED_VALUE	zip.h	1004;"	d
o_TT	zip.c	1935;"	d	file:
o_UN	zip.c	1936;"	d	file:
o_VALUE_LIST	zip.h	1006;"	d
o_VV	zip.c	1938;"	d	file:
o_db	zip.c	1901;"	d	file:
o_dc	zip.c	1902;"	d	file:
o_dd	zip.c	1903;"	d	file:
o_des	zip.c	1904;"	d	file:
o_df	zip.c	1905;"	d	file:
o_dg	zip.c	1907;"	d	file:
o_ds	zip.c	1908;"	d	file:
o_du	zip.c	1909;"	d	file:
o_dv	zip.c	1910;"	d	file:
o_h2	zip.c	1914;"	d	file:
o_ic	zip.c	1915;"	d	file:
o_jj	zip.c	1916;"	d	file:
o_la	zip.c	1917;"	d	file:
o_lf	zip.c	1918;"	d	file:
o_li	zip.c	1919;"	d	file:
o_ll	zip.c	1920;"	d	file:
o_mm	zip.c	1921;"	d	file:
o_nw	zip.c	1923;"	d	file:
o_sC	zip.c	1943;"	d	file:
o_sU	zip.c	1932;"	d	file:
o_sb	zip.c	1925;"	d	file:
o_sc	zip.c	1926;"	d	file:
o_sd	zip.c	1927;"	d	file:
o_sf	zip.c	1928;"	d	file:
o_so	zip.c	1929;"	d	file:
o_sp	zip.c	1930;"	d	file:
o_su	zip.c	1931;"	d	file:
o_sv	zip.c	1933;"	d	file:
o_tt	zip.c	1934;"	d	file:
o_ve	zip.c	1937;"	d	file:
o_ws	zip.c	1939;"	d	file:
o_ww	zip.c	1940;"	d	file:
o_z64	zip.c	1941;"	d	file:
object	vms/build_zip.com	/^$         message \/object = [.'dest']ZIP_MSG.OBJ \/nosymbols -$/;"	v
objtype	acorn/riscos.h	/^  int objtype;$/;"	m	struct:__anon9	access:public
oco_no_mbc_err	fileio.c	/^static ZCONST char Far oco_no_mbc_err[] = "option %s does not support multibyte values";$/;"	v	file:
oco_req_val_err	fileio.c	/^static ZCONST char Far oco_req_val_err[] = "option %s requires one character value";$/;"	v	file:
oddunstr	tandem/tandem.h	/^  unsigned oddunstr    : 1;$/;"	m	struct:nsk_file_flags	access:public
oem2iso	ebcdic.h	/^ZCONST uch Far oem2iso[] = {$/;"	v
oem2ths	theos/charconv.h	/^ZCONST uch Far oem2ths[] = {$/;"	v
oem_to_local_string	win32/win32.c	/^char *oem_to_local_string(local_string, oem_string)$/;"	f
of	README	/^   of "unzip zipfile", to let unzip know which file is the zip archive$/;"	v
of	win32/crc_i386.asm	/^;   first item in each table is input buffer length, even multiple of 8$/;"	v
of	win32/crc_lcc.asm	/^; The TAB characters in this source file are required by the parser of$/;"	v
of	win32/crc_lcc.asm	/^; This version of the code uses the "optimized for i686" variant of$/;"	v
of	win32/lm32_lcc.asm	/^; The TAB characters in this source file are required by the parser of$/;"	v
off	zip.h	/^  uzoff_t off;$/;"	m	struct:zlist	access:public
offset	acorn/riscos.h	/^  int offset;$/;"	m	struct:__anon8	access:public
offset	zipfile.c	/^  extent *offset;         \/* next byte to write *\/$/;"	v
offset	zipfile.c	/^  extent *offset;$/;"	v
on	msdos/crc_i86.asm	/^; Likewise, "jcxz" was replaced by "jz", because the latter is faster on$/;"	v
oname	zip.h	/^  char *oname;                  \/* Display version of internal name *\/$/;"	m	struct:flist	access:public
oname	zip.h	/^  char *oname;                  \/* Display version of name used in messages *\/$/;"	m	struct:zlist	access:public
one	vms/build_zip.com	/^$!     one "=", to avoid affecting other procedures.  For example:$/;"	v
only	win32/gvmat64.asm	/^;;; on zlib only$/;"	v
only_archive_set	globals.c	/^int only_archive_set = 0;     \/* include only files with DOS archive bit set *\/$/;"	v
op_no_allow_val_err	fileio.c	/^static ZCONST char Far op_no_allow_val_err[] = "option %s does not allow a value";$/;"	v	file:
op_not_neg_err	fileio.c	/^static ZCONST char Far op_not_neg_err[] = "option %s not negatable";$/;"	v	file:
op_req_val_err	fileio.c	/^static ZCONST char Far op_req_val_err[] = "option %s requires a value";$/;"	v	file:
open	macos/osdep.h	101;"	d
open	macos/source/macopen.c	33;"	d	file:
open	theos/_stat.c	214;"	d	file:
open	theos/osdep.h	51;"	d
open	theos/osdep.h	54;"	d
opendir	acorn/riscos.c	/^DIR *opendir(char *dirname)$/;"	f	signature:(char *dirname)
opendir	amiga/stat.c	/^DIR *opendir(const char *path)$/;"	f	signature:(const char *path)
opendir	beos/beos.c	72;"	d	file:
opendir	cmsmvs/mvs.c	/^DIR *opendir(const char *dirname)$/;"	f	signature:(const char *dirname)
opendir	os2/os2zip.c	/^DIR *opendir(const char *name)$/;"	f	signature:(const char *name)
opendir	tandem/tandem.c	/^DIR *opendir(const char *dirname)$/;"	f	signature:(const char *dirname)
opendir	theos/theos.c	33;"	d	file:
opendir	tops20/tops20.c	/^local DIR *opendir(n)$/;"	f
opendir	unix/unix.c	76;"	d	file:
operation	amiga/deflate.a	/^; all registers available to be clobbered by the sliding operation:$/;"	v
operation	human68k/deflate.s	/^; all registers available to be clobbered by the sliding operation:$/;"	v
operations	amiga/deflate.a	/^;               loop code for 68020 operations, comparing bytes four at a time$/;"	v
operations	human68k/deflate.s	/^;               loop code for 68020 operations, comparing bytes four at a time$/;"	v
opt_len	trees.c	/^local ulg opt_len;        \/* bit length of current block with optimal trees *\/$/;"	v
option	README.CR	/^      option; the dummy files may be newer than the real sources in$/;"	v
option	os2/match32.asm	/^; To be used only with 32 bit flat model. To simplify the code, the option$/;"	v
option	win32/gvmat64.asm	/^; to compile this file for infozip Zip, I use option:$/;"	v
option	win32/gvmat64.asm	/^; to compile this file for zLib, I use option:$/;"	v
option	win32/lm32_lcc.asm	/^; To be used only with 32 bit flat model. To simplify the code, the option$/;"	v
option	win32/match32.asm	/^; To be used only with 32 bit flat model. To simplify the code, the option$/;"	v
option_ID	zip.h	/^  unsigned long option_ID;  \/* value returned by get_option when this option is found *\/$/;"	m	struct:option_struct	access:public
option_struct	zip.h	/^struct option_struct {$/;"	s
option_struct::longopt	zip.h	/^  char Far *longopt;        \/* char * to long option string *\/$/;"	m	struct:option_struct	access:public
option_struct::name	zip.h	/^  char Far *name;           \/* optional string for option returned on some errors *\/$/;"	m	struct:option_struct	access:public
option_struct::negatable	zip.h	/^  int  negatable;           \/* from above *\/$/;"	m	struct:option_struct	access:public
option_struct::option_ID	zip.h	/^  unsigned long option_ID;  \/* value returned by get_option when this option is found *\/$/;"	m	struct:option_struct	access:public
option_struct::shortopt	zip.h	/^  char *shortopt;           \/* char * to sequence of char that is short option *\/$/;"	m	struct:option_struct	access:public
option_struct::value_type	zip.h	/^  int  value_type;          \/* from above *\/$/;"	m	struct:option_struct	access:public
optionerr	fileio.c	/^local int optionerr(buf, err, optind, islong)$/;"	f
optionerrbuf	fileio.c	/^local char Far optionerrbuf[OPTIONERR_BUF_SIZE + 1];$/;"	v
options	zipcloak.c	/^struct option_struct far options[] = {$/;"	v	typeref:struct:far
options	zipnote.c	/^struct option_struct far options[] = {$/;"	v	typeref:struct:far
options	zipsplit.c	/^struct option_struct far options[] = {$/;"	v	typeref:struct:far
opts	cmsmvs/pipzip.rexx	/^   '| specs \/zip 'opts'\/ 1 1-* nw',$/;"	v
opts	cmsmvs/pipzip.rexx	/^parse arg opts$/;"	v
or	README	/^favorite port is broke, send us the details or, better, send bug fixes.  It's$/;"	v
or	amiga/match_68.a	/^; and various symbols can be defined to select whether to use one routine or$/;"	v
or	proginfo/fileinfo.cms	/^     equal to 1, fread() returns either 0 or 1, indicating whether a$/;"	v
org_ptr	msdos/msdos.c	/^    zvoid far *org_ptr;$/;"	m	struct:ptr_table_s	file:	access:public
orig_filespec	vms/cvthelp.tpu	/^        ,orig_filespec$/;"	v
orig_filespec	vms/cvthelp.tpu	/^  orig_filespec := get_info(command_line, "file_name");$/;"	v
original	win32/crc_lcc.asm	/^; For more information (and a revision log), look into the original$/;"	v
os2dll	api.h	/^    _zip_version_type os2dll;$/;"	m	struct:_ZpVer	access:public
os2dll	windll/windll.txt	/^    _zip_version_type os2dll;$/;"	m	struct:_ZpVer	file:	access:public
os_error	acorn/riscos.h	/^} os_error;$/;"	t	typeref:struct:__anon7
other	amiga/match_68.a	/^; the other, or to do a platform-specific test at runtime.  The symbols that$/;"	v
other	win32/gvmat64.asm	/^;;; strings match each other, and they can be safely passed over before$/;"	v
ots$cvt_tu_l	vms/cmdline.c	103;"	d	file:
ots$cvt_tu_l	zip.h	365;"	d
ouname	zip.h	/^  char *ouname;                 \/* Display version of zuname *\/$/;"	m	struct:zlist	access:public
ound	bzip2/install.txt	/^  include and library paths and, if found, link in the system bzip2$/;"	v
out_buf	trees.c	/^char *out_buf;$/;"	v
out_buf	trees.c	/^local char *out_buf;$/;"	v
out_offset	trees.c	/^local unsigned out_offset;$/;"	v
out_offset	trees.c	/^unsigned out_offset;$/;"	v
out_path	globals.c	/^char *out_path = NULL;        \/* base name of output file, usually same as zipfile *\/$/;"	v
out_size	trees.c	/^local unsigned out_size;$/;"	v
out_size	trees.c	/^unsigned out_size;$/;"	v
output	amiga/deflate.a	/^;   DEBUG      activates some tracing output, as in the C source.$/;"	v
output	human68k/deflate.s	/^;   DEBUG      activates some tracing output, as in the C source.$/;"	v
output_seekable	globals.c	/^int output_seekable = 1;      \/* 1 = output seekable 3\/13\/05 EG *\/$/;"	v
ov	tandem/tandem.h	/^  struct nsk_stat_overlay  ov;$/;"	m	union:__anon35	typeref:struct:__anon35::nsk_stat_overlay	access:public
owner	tandem/tandem.h	/^  struct nsk_owner owner;   \/* 16 *\/$/;"	m	struct:nsk_file_attrs_def	typeref:struct:nsk_file_attrs_def::nsk_owner	access:public
p	ttyio.c	/^    char *p;                    \/* return value: line input *\/$/;"	v
pExtra	zipfile.c	/^  char *pExtra;         \/* pointer to extra field in memory *\/$/;"	v
pPtr	zipfile.c	/^  char **pPtr;            \/* start of block *\/$/;"	v
pPtr	zipfile.c	/^  char **pPtr;$/;"	v
pPtr	zipfile.c	/^  char *pPtr;$/;"	v
package	unix/Packaging/README	/^installable package files for the package, IZzip.$/;"	v
parms	cmsmvs/zipvmc.exec	/^parms = '(long def(VM_CMS)'$/;"	v
parsename	tandem/tandem.c	/^short parsename(srce, fname, ext)$/;"	f
part	msdos/crc_i86.asm	/^;   all bytes can be accessed by manipulating the offset part, only.$/;"	v
pascal	macos/source/macstuff.c	1614;"	d	file:
pascal	macos/source/macstuff.c	1641;"	d	file:
passwd	crypt.c	/^    ZCONST char *passwd;        \/* password string with which to modify keys *\/$/;"	v
password	api.h	/^  DLLPASSWORD *password;$/;"	m	struct:__anon32	access:public
password	windll/windll.txt	/^DLLPASSWORD *password;$/;"	m	struct:__anon20	file:	access:public
passwrd	crypt.c	/^    ZCONST char *passwrd;$/;"	v
patchlevel	api.h	/^    uch patchlevel;         \/* e.g., 0 *\/$/;"	m	struct:_zip_ver	access:public
path	os2/os2acl.c	/^static char *path, *data;$/;"	v	file:
path	zipsplit.c	/^local char *path = NULL;        \/* space for full name *\/$/;"	v
pathput	globals.c	/^int pathput = 1;        \/* 1=store path with name *\/$/;"	v
paths	WHATSNEW	/^  Zip on WIN32 now stores OEM paths, which should be more compatible$/;"	v
paths	zip.txt	/^              and OS paths, and is preferred.$/;"	v
pattern	zip.c	/^    char *pattern;$/;"	m	struct:filterlist_struct	file:	access:public
patterns	globals.c	/^struct plist *patterns = NULL;  \/* List of patterns to be matched *\/$/;"	v	typeref:struct:plist
pc	acorn/sendbits.s	/^        MOVS    pc,lr$/;"	v
pc	acorn/swiven.s	/^        MOVS    pc, ip$/;"	v
pclose	win32/osdep.h	80;"	d
pcount	globals.c	/^unsigned pcount = 0;            \/* number of patterns *\/$/;"	v
peekucb	theos/_stat.c	26;"	d	file:
per	msdos/match.asm	/^; Turbo C 2.0 does not support static allocation of more than 64K bytes per$/;"	v	file:
percent	zipup.c	/^int percent(n, m)$/;"	f
perror	windll/windll.c	/^void __far __cdecl perror(const char *parm1)$/;"	f	signature:(const char *parm1)
pipe1	cmsmvs/mc.exec	/^pipe1=,$/;"	v
pipe2	cmsmvs/mc.exec	/^pipe2= '?',$/;"	v
plist	zip.h	/^struct plist {$/;"	s
plist::select	zip.h	/^  int select;                   \/* Selection flag ('i' or 'x') *\/$/;"	m	struct:plist	access:public
plist::zname	zip.h	/^  char *zname;                  \/* External version of internal name *\/$/;"	m	struct:plist	access:public
plist_items	tandem/tandem.c	203;"	d	file:
plist_size	tandem/tandem.c	204;"	d	file:
plit	zip.txt	/^       reads  archive  inarchive.zip,  even if split, adds the files foo.c and$/;"	v
point	msdos/match.asm	/^; at this point, di == scan+2, si = cur_match,$/;"	v
point	msdos/match.asm	/^; at this point, ds:di == scan+2, ds:si == cur_match$/;"	v
point	os2/match32.asm	/^; at this point, edi == scan+2, esi == cur_match$/;"	v
point	os2/match32.asm	/^; at this point, edi == scan+2, esi == cur_match,$/;"	v
point	win32/match32.asm	/^; at this point, edi == scan+2, esi == cur_match$/;"	v
point	win32/match32.asm	/^; at this point, edi == scan+2, esi == cur_match,$/;"	v
pointers	msdos/crc_i86.asm	/^;   + no huge pointers$/;"	v
popen	win32/osdep.h	79;"	d
ports	README	/^ports, large file and Zip64 support is automatically checked for and$/;"	v
ports	WHATSNEW	/^  all ports, that can result in a 10 times increase in speed in some cases$/;"	v
pqdownheap	trees.c	/^local void pqdownheap(tree, k)$/;"	f
pqremove	trees.c	582;"	d	file:
precision	proginfo/txtvsbin.txt	/^accuracy and precision, and a near-100% recall.  This scheme is designed$/;"	v
precision	proginfo/txtvsbin.txt	/^however, incurs a reduced precision, since false positives are also more$/;"	v
prefetcht1	win32/gvmat64.asm	/^        prefetcht1 [rdi+rdx]$/;"	v
prev	deflate.c	/^  Pos    prev[WSIZE];$/;"	v
prev	deflate.c	/^  Pos far * near prev   = NULL;$/;"	v
prev	msdos/match.asm	/^        mov     si,prev[si]             ; cur_match = prev[cur_match]$/;"	v
prev	msdos/match.asm	/^;       prev         equ ds:prev$/;"	v
prev	os2/match32.asm	/^        mov     si,prev[esi]            ; cur_match = prev[cur_match]$/;"	v
prev	win32/gvmat64.asm	/^;;; Posf *prev = s->prev;$/;"	v
prev_ad	win32/gvmat64.asm	/^        mov rdi, prev_ad$/;"	v
prev_length	amiga/deflate.a	/^        move.w  PrevL,prev_length       ; longest_match reads these variables$/;"	v
prev_length	deflate.c	/^unsigned int near prev_length;$/;"	v
prev_length	human68k/deflate.s	/^        move.w  PrevL,prev_length       ; longest_match reads these variables$/;"	v
prev_length	msdos/match.asm	/^;   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1$/;"	v
prev_length	os2/match32.asm	/^;   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1$/;"	v
prev_length	win32/match32.asm	/^;   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1$/;"	v
prev_match	amiga/deflate.a	/^PrevM   equr    a5              ; local variable prev_match, int in an A-reg$/;"	v
prev_match	human68k/deflate.s	/^PrevM   reg     a5              ; local variable prev_match, int in an A-reg$/;"	v
prev_ptr	msdos/match.asm	/^        mov     cs:prev_ptr,ax          ; ugly write to code, crash on OS\/2$/;"	v
prev_seg	msdos/match.asm	/^        mov     ds,prev_seg             ; (does not destroy the flags)$/;"	v
prevents	win32/crc_i386.asm	/^;   Recognize additional conditional flag CRC_TABLE_ONLY that prevents$/;"	v
priext	tandem/tandem.h	/^  unsigned short priext;    \/* 16 *\/$/;"	m	struct:nsk_file_attrs_def	access:public
primpart	tandem/tandem.h	/^  unsigned primpart    : 1;$/;"	m	struct:nsk_file_flags	access:public
print	api.h	/^  DLLPRNT *print;$/;"	m	struct:__anon32	access:public
print	windll/windll.txt	/^DLLPRNT *print;$/;"	m	struct:__anon20	file:	access:public
print_extra_info	macos/source/extrafld.c	/^static void print_extra_info(void)$/;"	f	file:	signature:(void)
print_period	human68k/human68k.c	/^void print_period(void)$/;"	f	signature:(void)
printerr	macos/source/helpers.c	/^OSErr printerr(const char *msg, int cond, int err, int line, char *file,$/;"	f	signature:(const char *msg, int cond, int err, int line, char *file, const char *msg2)
printf	windll/windll.c	/^int __far __cdecl printf(const char *format, ...)$/;"	f	signature:(const char *format, ...)
printing	windll/contents	/^  windll.c       Contains the entry point for the DLL, "fake" printing,$/;"	v
printnames	util.c	/^int printnames()$/;"	f
problems	macos/HISTORY.TXT	/^         caused problems; the default setting of the extra field$/;"	v
proc_archive_name	fileio.c	/^int proc_archive_name(n, caseflag)$/;"	f
procedures	WHATSNEW	/^release information, INSTALL for installation procedures, and the manual$/;"	v
process	INSTALL	/^     To initiate the actual compiling process, you have to specify$/;"	v
processed	zip.txt	/^       progress  dots  every  2  seconds  or  every so many entries processed,$/;"	v
procname	acorn/acornzip.c	/^int procname(n, caseflag)$/;"	f
procname	amiga/amigazip.c	/^int procname(n, caseflag)$/;"	f
procname	aosvs/aosvs.c	/^int procname(n, caseflag)$/;"	f
procname	atari/atari.c	/^int procname(n, caseflag)$/;"	f
procname	atheos/atheos.c	/^int procname(n, caseflag)$/;"	f
procname	beos/beos.c	/^int procname(n, caseflag)$/;"	f
procname	cmsmvs/cms.c	/^int procname(n, caseflag)$/;"	f
procname	cmsmvs/mvs.c	/^int procname(n, caseflag)$/;"	f
procname	human68k/human68k.c	/^int procname(n, caseflag)$/;"	f
procname	macos/source/macos.c	/^int procname(char *filename,         \/* name to process *\/$/;"	f	signature:(char *filename, int caseflag)
procname	msdos/msdos.c	/^int procname(n, caseflag)$/;"	f
procname	novell/Netware.c	/^int procname(n)$/;"	f
procname	os2/os2.c	/^int procname(n, caseflag)$/;"	f
procname	qdos/qfileio.c	/^int procname(n, caseflag)$/;"	f
procname	tandem/tanzip.c	/^  int procname(n, caseflag)$/;"	f
procname	theos/theos.c	/^int procname(n, caseflag)$/;"	f
procname	tops20/tops20.c	/^int procname(n, caseflag)$/;"	f
procname	unix/unix.c	/^int procname(n, caseflag)$/;"	f
procname	vms/vmszip.c	/^int procname( char *n, int caseflag)$/;"	f	signature:( char *n, int caseflag)
procname	win32/win32zip.c	/^int procname(n, caseflag)$/;"	f
procname_dos	msdos/msdos.c	/^local int procname_dos(n, caseflag, attribs)$/;"	f
procname_win32	win32/win32zip.c	/^local int procname_win32(n, caseflag, attribs)$/;"	f
procname_win32w	win32/win32zip.c	/^local int procname_win32w(nw, caseflag, attribs)$/;"	f
procnamehho	novell/Netware.c	/^int procnamehho (char *n)$/;"	f	signature:(char *n)
procnamew	win32/win32zip.c	/^int procnamew(nw, caseflag)$/;"	f
progid	tandem/tandem.h	/^  unsigned progid    : 1;$/;"	m	struct:nsk_file_attrs_def	access:public
prompt	win32/readme.a64	/^to compile it, start the C++ AMD64 build environnement prompt,$/;"	v
properties	windll/Vb/readmeVB.txt	/^looking at properties, selecting the Version tab, and verifying the$/;"	v
ptr	msdos/match.asm	/^        cur_match    equ word ptr [bp+4] ; [bp+4] for compact model$/;"	v
ptr	msdos/match.asm	/^        cur_match    equ word ptr [bp+6] ; [bp+6] for large model$/;"	v
ptr	win32/crc_i386.asm	/^                xor     al, byte ptr [esi+ofs] ; c ^= *(buf+ofs)$/;"	v
ptr	win32/crc_i386.asm	/^                xor     al, byte ptr [esi]     ; c ^= *buf$/;"	v
ptr	win32/crc_i386.asm	/^                xor     eax, dword ptr [esi+12] ; c ^= *((ulg *)buf]+3$/;"	v
ptr	win32/crc_i386.asm	/^                xor     eax, dword ptr [esi+4]  ; c ^= *((ulg *)buf+1)$/;"	v
ptr	win32/crc_i386.asm	/^                xor     eax, dword ptr [esi+8]  ; c ^= *((ulg *)buf+2)$/;"	v
ptr	win32/crc_i386.asm	/^                xor     eax, dword ptr [esi]    ; c ^= *(ulg *)buf$/;"	v
ptr	win32/crc_i386.asm	/^                xor     eax, dword ptr [esi]   ; c ^= *(ulg *)buf$/;"	v
ptr_table	msdos/msdos.c	/^} ptr_table;$/;"	t	typeref:struct:ptr_table_s	file:
ptr_table_s	msdos/msdos.c	/^typedef struct ptr_table_s {$/;"	s	file:
ptr_table_s::new_ptr	msdos/msdos.c	/^    zvoid far *new_ptr;$/;"	m	struct:ptr_table_s	file:	access:public
ptr_table_s::org_ptr	msdos/msdos.c	/^    zvoid far *org_ptr;$/;"	m	struct:ptr_table_s	file:	access:public
public	zipcloak.c	/^static ZCONST char *public[] = {$/;"	v	file:
putc	macos/ZipLib.h	35;"	d
putc	tandem/tandem.c	165;"	d	file:
putc	tandem/tandem.c	177;"	d	file:
putc	tandem/tandem.h	67;"	d
putcentral	zipfile.c	/^int putcentral(z)$/;"	f
putchar	macos/ZipLib.h	34;"	d
putchar	macos/ZipSx.h	34;"	d
putchar	macos/osdep.h	76;"	d
putclean	zipnote.c	/^local void putclean(s, n)$/;"	f
putextended	zipfile.c	/^int putextended(z)$/;"	f
putlocal	zipfile.c	/^int putlocal(z, rewrite)$/;"	f
qdirect	qdos/qdos.c	/^struct qdirect  {$/;"	s	file:
qdirect::d_access	qdos/qdos.c	/^    unsigned char   d_access __attribute__ ((packed));  \/* file access type *\/$/;"	m	struct:qdirect	file:	access:public
qdirect::d_backup	qdos/qdos.c	/^    long            d_backup __attribute__ ((packed));   \/* EOD *\/$/;"	m	struct:qdirect	file:	access:public
qdirect::d_datalen	qdos/qdos.c	/^    long            d_datalen __attribute__ ((packed)); \/* data length *\/$/;"	m	struct:qdirect	file:	access:public
qdirect::d_length	qdos/qdos.c	/^    long            d_length __attribute__ ((packed));  \/* file length *\/$/;"	m	struct:qdirect	file:	access:public
qdirect::d_name	qdos/qdos.c	/^    char            d_name[QDOS_FLMAX] __attribute__ ((packed));\/* name area *\/$/;"	m	struct:qdirect	file:	access:public
qdirect::d_refdate	qdos/qdos.c	/^    long            d_refdate __attribute__ ((packed));$/;"	m	struct:qdirect	file:	access:public
qdirect::d_reserved	qdos/qdos.c	/^    long            d_reserved __attribute__ ((packed));\/* Unused *\/$/;"	m	struct:qdirect	file:	access:public
qdirect::d_szname	qdos/qdos.c	/^    short           d_szname __attribute__ ((packed));  \/* size of name *\/$/;"	m	struct:qdirect	file:	access:public
qdirect::d_type	qdos/qdos.c	/^    unsigned char   d_type __attribute__ ((packed));    \/* file type *\/$/;"	m	struct:qdirect	file:	access:public
qdirect::d_update	qdos/qdos.c	/^    long            d_update __attribute__ ((packed));  \/* last update *\/$/;"	m	struct:qdirect	file:	access:public
qdosextra	qdos/qdos.c	/^} qdosextra;$/;"	t	typeref:struct:__anon33	file:
ql2Unix	qdos/qdos.c	/^char * ql2Unix (char *qlname)$/;"	f	signature:(char *qlname)
qlflag	qdos/qdos.c	/^short qlflag = 0;$/;"	v
qlstat	qdos/qdos.c	/^int qlstat(char *name, struct qdirect *qs, char *flag)$/;"	f	signature:(char *name, struct qdirect *qs, char *flag)
qlwild	qdos/qdos.c	/^int qlwild (char *dnam, short dorecurse, short l)$/;"	f	signature:(char *dnam, short dorecurse, short l)
quality	win32/gvmat64.asm	/^;;; Test the strings for equality, 8 bytes at a time. At the end,$/;"	v
quitFlag	macos/source/recurse.c	/^    Boolean                 quitFlag;       \/* set to true if filter wants to$/;"	m	struct:RecurseGlobals	file:	access:public
r	acorn/srcrename	/^p/;"	v
r0	acorn/sendbits.s	/^        CMP     r2,r0           ; if out_offset >= out_size-1$/;"	v
r0	acorn/sendbits.s	/^        LDR     r0,=out_buf$/;"	v
r0	acorn/sendbits.s	/^        LDR     r0,=out_size$/;"	v
r0	acorn/sendbits.s	/^        MOV     r0,r2$/;"	v
r0	acorn/sendbits.s	/^        ORR     r4,r4,r0,LSL r2 ; |= value<<bi_valid$/;"	v
r0	acorn/sendbits.s	/^        SUB     r0,r0,#1$/;"	v
r0	acorn/sendbits.s	/^loop    MOVS    r0,r0,LSR #1$/;"	v
r0	acorn/swiven.s	/^        MOV     r0, #0$/;"	v
r0	acorn/swiven.s	/^        MOV     r0, #1$/;"	v
r0	acorn/swiven.s	/^        MOV     r0, #26$/;"	v
r0	acorn/swiven.s	/^        MOV     r0, #27$/;"	v
r0	acorn/swiven.s	/^        MOV     r0, #37$/;"	v
r0	acorn/swiven.s	/^        MOV     r0, #5$/;"	v
r0	acorn/swiven.s	/^        MOV     r0, #54$/;"	v
r0	acorn/swiven.s	/^        MOV     r0, #6$/;"	v
r0	acorn/swiven.s	/^        MOV     r0, #7$/;"	v
r0	acorn/swiven.s	/^        MOV     r0, #9$/;"	v
r0	acorn/swiven.s	/^        MOVVC   r0, #0$/;"	v
r0	acorn/swiven.s	/^        MOVVC   r0, r1$/;"	v
r0	acorn/swiven.s	/^        MOVVS   r0, #0$/;"	v
r0	acorn/swiven.s	/^        STRNE   r0, [lr]$/;"	v
r1	acorn/match.s	/^        LDR     r1, [pc, #|__max_chain_length|-.-8]$/;"	v
r1	acorn/match.s	/^        LDR     r1, [r1]$/;"	v
r1	acorn/match.s	/^        MOVCS   r1, r1, LSR #2$/;"	v
r1	acorn/sendbits.s	/^        SUBS    r1,r1,#1$/;"	v
r1	acorn/swiven.s	/^        MOV     r1, r0$/;"	v
r10	win32/gvmat64.asm	/^        mov r10, window_ad$/;"	v
r10	win32/gvmat64.asm	/^;   rax, rcx, rdx, r8, r9, r10, and r11, which are scratch.$/;"	v
r10	win32/gvmat64.asm	/^; register used : rax,rbx,rcx,rdx,rsi,rdi,r8,r9,r10,r11,r12$/;"	v
r10	win32/gvmat64.asm	/^;window          equ  rsp + xx - LocalVarsSize   ; local copy of s->window ; stored in r10$/;"	v
r10d	win32/gvmat64.asm	/^        cmovnl r10d, eax$/;"	v
r10d	win32/gvmat64.asm	/^        cmp r10d, eax$/;"	v
r10d	win32/gvmat64.asm	/^        mov r10d, Lookahead$/;"	v
r11	win32/gvmat64.asm	/^;   rax, rcx, rdx, r8, r9, r10, and r11, which are scratch.$/;"	v
r11	win32/gvmat64.asm	/^; register used : rax,rbx,rcx,rdx,rsi,rdi,r8,r9,r10,r11,r12$/;"	v
r11	win32/gvmat64.asm	/^;windowbestlen   equ  rsp + xx - LocalVarsSize   ; s->window + bestlen , use r10+r11$/;"	v
r11d	win32/gvmat64.asm	/^        mov r11d, eax$/;"	v
r11d	win32/gvmat64.asm	/^        mov r11d, prev_length$/;"	v
r12	win32/gvmat64.asm	/^; register used : rax,rbx,rcx,rdx,rsi,rdi,r8,r9,r10,r11,r12$/;"	v
r12d	win32/gvmat64.asm	/^        movzx r12d,word ptr [r9]$/;"	v
r12w	win32/gvmat64.asm	/^        cmp     r12w, word ptr [r10 + r8]$/;"	v
r12w	win32/gvmat64.asm	/^;scanstart       equ  rsp + xx - LocalVarsSize   ; first two bytes of string ; stored in r12w$/;"	v
r13	win32/gvmat64.asm	/^         and r13,3$/;"	v
r13	win32/gvmat64.asm	/^        lea r13, [r10 + rbp]$/;"	v
r13	win32/gvmat64.asm	/^        mov [save_r13],r13$/;"	v
r14	win32/gvmat64.asm	/^; free register :  r14,r15$/;"	v
r15	win32/gvmat64.asm	/^;        mov r15,[save_r15]$/;"	v
r15	win32/gvmat64.asm	/^; free register :  r14,r15$/;"	v
r2	acorn/match.s	/^        ADD     r2, lr, ip$/;"	v
r2	acorn/match.s	/^        ADD     r2, r2, #2$/;"	v
r2	acorn/match.s	/^        CMP     r2, r7$/;"	v
r2	acorn/match.s	/^        SUB     r2, r2, r4               ; scan = strend - MAX_MATCH$/;"	v
r2	acorn/match.s	/^        SUB     r4, r2, r7               ; len = MAX_MATCH - (int)(strend - scan);$/;"	v
r2	acorn/sendbits.s	/^        ADCS    r2,r2,r2$/;"	v
r2	acorn/sendbits.s	/^        ADD     r2,r2,#2$/;"	v
r2	acorn/sendbits.s	/^        CMP     r2,r0           ; if out_offset >= out_size-1$/;"	v
r2	acorn/sendbits.s	/^        LDR     r2,[r1]$/;"	v
r2	acorn/sendbits.s	/^        LDR     r2,[r3]$/;"	v
r2	acorn/sendbits.s	/^        MOV     r2,#0$/;"	v
r2	acorn/sendbits.s	/^        ORR     r4,r4,r0,LSL r2 ; |= value<<bi_valid$/;"	v
r2	acorn/sendbits.s	/^        STR     r2,[r1]$/;"	v
r2	acorn/sendbits.s	/^        STR     r2,[r3]         ;  in R4 for later storage)$/;"	v
r2	acorn/sendbits.s	/^        STRLE   r2,[r3]         ; short? store & return$/;"	v
r2	acorn/swiven.s	/^        MOV     r2, r1$/;"	v
r2	acorn/swiven.s	/^        STRNE   r2, [ip]$/;"	v
r2	acorn/swiven.s	/^        STRNE   r2, [lr]$/;"	v
r3	acorn/match.s	/^        ADD     r3, lr, r0$/;"	v
r3	acorn/match.s	/^        ADD     r3, r3, #2$/;"	v
r3	acorn/swiven.s	/^        LDR     r3, [r2]$/;"	v
r3	acorn/swiven.s	/^        MOV     r3, #0$/;"	v
r3	acorn/swiven.s	/^        MOV     r3, r1$/;"	v
r3	acorn/swiven.s	/^        MOV     r3, r2$/;"	v
r3	acorn/swiven.s	/^        STR     r3, [r5]$/;"	v
r3	acorn/swiven.s	/^        STRNE   r3, [lr]$/;"	v
r4	acorn/match.s	/^        ADD     r4, r4, #256$/;"	v
r4	acorn/match.s	/^        ADD     r4, r4, #MAX_MATCH-256$/;"	v
r4	acorn/match.s	/^        LDRB    r4, [r2, #1]$/;"	v
r4	acorn/match.s	/^        LDRB    r4, [r3, #1]!$/;"	v
r4	acorn/match.s	/^        LDRB    r4, [r3]$/;"	v
r4	acorn/match.s	/^        SUB     r2, r2, r4               ; scan = strend - MAX_MATCH$/;"	v
r4	acorn/match.s	/^        SUB     r4, r2, r7               ; len = MAX_MATCH - (int)(strend - scan);$/;"	v
r4	acorn/sendbits.s	/^        MOV     r5,r4,LSR #8$/;"	v
r4	acorn/sendbits.s	/^        ORR     r4,r4,r0,LSL r2 ; |= value<<bi_valid$/;"	v
r4	acorn/sendbits.s	/^        STRB    r4,[r0,r2]!     ; store 'old' bi_buf$/;"	v
r4	acorn/swiven.s	/^        LDR     r4, [r3]$/;"	v
r4	acorn/swiven.s	/^        MOV     r4, #0$/;"	v
r4	acorn/swiven.s	/^        STR     r4, [r6]$/;"	v
r4	acorn/swiven.s	/^        STRNE   r4, [lr]$/;"	v
r5	acorn/match.s	/^        CMP     r5, ip$/;"	v
r5	acorn/match.s	/^        LDR     r5, [pc, #|__prev_length|-.-8]$/;"	v
r5	acorn/match.s	/^        LDR     r5, [r5]$/;"	v
r5	acorn/match.s	/^        SUB     ip, r5, #1$/;"	v
r5	acorn/sendbits.s	/^        LDR     r5,=bi_buf$/;"	v
r5	acorn/sendbits.s	/^        MOV     r5,r4,LSR #8$/;"	v
r5	acorn/sendbits.s	/^        STRB    r5,[r0,#1]$/;"	v
r5	acorn/swiven.s	/^        LDR     r5, [r2]$/;"	v
r5	acorn/swiven.s	/^        LDR     r5, [r3]$/;"	v
r5	acorn/swiven.s	/^        MOV     r5, r3$/;"	v
r5	acorn/swiven.s	/^        STR     r5, [r2]$/;"	v
r5	acorn/swiven.s	/^        STR     r5, [r3]$/;"	v
r5	acorn/swiven.s	/^        STRNE   r5, [lr]$/;"	v
r6	acorn/match.s	/^        SUBCSS  r6, ip, #250                ; r6 = r6 - MAXDIST$/;"	v
r7	acorn/match.s	/^        ADD     r7, r7, #256                ; r7 = r2 + MAX_MATCH (=258);$/;"	v
r7	acorn/match.s	/^        SUB     r4, r2, r7               ; len = MAX_MATCH - (int)(strend - scan);$/;"	v
r8	acorn/match.s	/^        LDRB    r8, [r2, ip]$/;"	v
r8	win32/gvmat64.asm	/^;   rax, rcx, rdx, r8, r9, r10, and r11, which are scratch.$/;"	v
r8	win32/gvmat64.asm	/^; register used : rax,rbx,rcx,rdx,rsi,rdi,r8,r9,r10,r11,r12$/;"	v
r8	win32/gvmat64.asm	/^; this clear high 32 bits of r8, which can be garbage in both r8 and rdx$/;"	v
r8d	win32/gvmat64.asm	/^        and r8d, edx$/;"	v
r8d	win32/gvmat64.asm	/^        cmp r8d, ebp$/;"	v
r8d	win32/gvmat64.asm	/^        mov match_start, r8d$/;"	v
r8d	win32/gvmat64.asm	/^        mov r8d,ecx$/;"	v
r8d	win32/gvmat64.asm	/^        mov r8d,edx$/;"	v
r8d	win32/gvmat64.asm	/^        movzx   r8d, word ptr [rdi + r8*2]$/;"	v
r9	acorn/match.s	/^        LDRB    r9, [r2, r5]$/;"	v
r9	win32/gvmat64.asm	/^;   rax, rcx, rdx, r8, r9, r10, and r11, which are scratch.$/;"	v
r9	win32/gvmat64.asm	/^; register used : rax,rbx,rcx,rdx,rsi,rdi,r8,r9,r10,r11,r12$/;"	v
r_day	timezone.h	/^    int             r_day;      \/* day number of rule *\/$/;"	m	struct:rule	access:public
r_mon	timezone.h	/^    int             r_mon;      \/* month number of rule *\/$/;"	m	struct:rule	access:public
r_time	timezone.h	/^    long            r_time;     \/* transition time of rule *\/$/;"	m	struct:rule	access:public
r_type	timezone.h	/^    int             r_type;     \/* type of rule--JULIAN_DAY etc *\/$/;"	m	struct:rule	access:public
r_week	timezone.h	/^    int             r_week;     \/* week number of rule *\/$/;"	m	struct:rule	access:public
ra	vms/vms.h	/^    ush tag_ra; ush len_ra;     byte ra[ATR$S_RECATTR];$/;"	m	struct:__anon23	access:public
ra	vms/vms.h	/^    ush tag_ra; ush len_ra;     byte ra[ATR$S_RECATTR];$/;"	m	struct:__anon24	access:public
rab	vms/vms_im.c	/^    struct RAB *rab;$/;"	m	struct:user_context	typeref:struct:user_context::RAB	file:	access:public
range	proginfo/txtvsbin.txt	/^of the bytes are within the range [7..127], the file is labeled as plain$/;"	v
range	proginfo/txtvsbin.txt	/^the range [128..255], and texts using these alphabets are most often$/;"	v
rather	win32/crc_i386.asm	/^;   avoid using loop, and j[e]cxz where possible.  Use mov + inc, rather$/;"	v
rax	win32/gvmat64.asm	/^        mov rax, [rsi + rdx + 8+8]$/;"	v
rax	win32/gvmat64.asm	/^        mov rax, [rsi + rdx + 8]$/;"	v
rax	win32/gvmat64.asm	/^        shr rax,32$/;"	v
rax	win32/gvmat64.asm	/^        sub rax, r9$/;"	v
rax	win32/gvmat64.asm	/^        xor rax, [rdi + rdx + 8+8]$/;"	v
rax	win32/gvmat64.asm	/^        xor rax, [rdi + rdx + 8]$/;"	v
rax	win32/gvmat64.asm	/^        xor rax, [rdi + rdx]$/;"	v
rax	win32/gvmat64.asm	/^;   rax, rcx, rdx, r8, r9, r10, and r11, which are scratch.$/;"	v
rax	win32/gvmat64.asm	/^; register used : rax,rbx,rcx,rdx,rsi,rdi,r8,r9,r10,r11,r12$/;"	v
rbx	win32/gvmat64.asm	/^; register used : rax,rbx,rcx,rdx,rsi,rdi,r8,r9,r10,r11,r12$/;"	v
rcsid	os2/os2acl.c	/^   static char *rcsid =$/;"	v	file:
rcsrev	os2/os2acl.c	/^   static char *rcsrev = "$Revision: 1.3 $";$/;"	v	file:
rcx	win32/gvmat64.asm	/^;   rax, rcx, rdx, r8, r9, r10, and r11, which are scratch.$/;"	v
rcx	win32/gvmat64.asm	/^; register used : rax,rbx,rcx,rdx,rsi,rdi,r8,r9,r10,r11,r12$/;"	v
rd	vms/vms.h	/^    ush tag_rd; ush len_rd;     byte rd[ATR$S_REVDATE];$/;"	m	struct:__anon23	access:public
rd	vms/vms.h	/^    ush tag_rd; ush len_rd;     byte rd[ATR$S_REVDATE];$/;"	m	struct:__anon24	access:public
rdi	win32/gvmat64.asm	/^        lea rdi, [r9 + r13 + 0108h] ;MAX_MATCH_8]$/;"	v
rdi	win32/gvmat64.asm	/^        mov rdi, prev_ad$/;"	v
rdi	win32/gvmat64.asm	/^; register used : rax,rbx,rcx,rdx,rsi,rdi,r8,r9,r10,r11,r12$/;"	v
rdirstat	theos/_stat.c	/^static int rdirstat(const char* fn, struct stat *st)$/;"	f	file:	signature:(const char* fn, struct stat *st)
rdsymlnk	zip.h	698;"	d
rdsymlnk	zip.h	701;"	d
rdx	win32/gvmat64.asm	/^        adc rdx, 0$/;"	v
rdx	win32/gvmat64.asm	/^        add rdx,2$/;"	v
rdx	win32/gvmat64.asm	/^        add rdx,4$/;"	v
rdx	win32/gvmat64.asm	/^        add rdx,8+8+8$/;"	v
rdx	win32/gvmat64.asm	/^        mov rdx, 0fffffffffffffef8h; -(MAX_MATCH_8)$/;"	v
rdx	win32/gvmat64.asm	/^;   rax, rcx, rdx, r8, r9, r10, and r11, which are scratch.$/;"	v
rdx	win32/gvmat64.asm	/^; register used : rax,rbx,rcx,rdx,rsi,rdi,r8,r9,r10,r11,r12$/;"	v
rdx	win32/gvmat64.asm	/^LeaveLoopCmps16: add rdx,8$/;"	v
rdx	win32/gvmat64.asm	/^LeaveLoopCmps8: add rdx,8$/;"	v
read	acorn/riscos.h	/^  int read;$/;"	m	struct:__anon8	access:public
read	tandem/tandem.h	/^  unsigned read      : 3;$/;"	m	struct:nsk_file_attrs_def	access:public
read	vms/zip_msg.msg	/^BIG     \/ERROR        <Entry too big to split, read, or write>$/;"	v
read	win32/crc_i386.asm	/^; registers read:$/;"	v
read	zip30f.ann	/^  so many bytes read, settable from KB to TB, allowing progress to be$/;"	v
read_Unicode_Path_entry	zipfile.c	/^local void read_Unicode_Path_entry(pZipListEntry)$/;"	f
read_Unicode_Path_local_entry	zipfile.c	/^local void read_Unicode_Path_local_entry(pZipListEntry)$/;"	f
read_buf	amiga/deflate.a	/^        xref    _read_buf       ; int (*read_buf)(char *, unsigned int)$/;"	v
read_buf	human68k/deflate.s	/^        xref    _read_buf       ; int (*read_buf)(char *, unsigned int)$/;"	v
read_buf	zipup.c	/^  unsigned (*read_buf) OF((char *buf, unsigned size)) = file_read;$/;"	v
read_split_archive	globals.c	/^int read_split_archive = 0;       \/* 1=scanzipf_reg detected spanning signature *\/$/;"	v
readd	acorn/acornzip.c	/^char *readd(DIR *d)$/;"	f	signature:(DIR *d)
readd	amiga/amigazip.c	/^local char *readd(d)$/;"	f
readd	aosvs/aosvs.c	/^char *readd(d)$/;"	f
readd	atari/atari.c	/^local char *readd(d)$/;"	f
readd	atheos/atheos.c	/^local char *readd(d)$/;"	f
readd	beos/beos.c	/^local char *readd(d)$/;"	f
readd	cmsmvs/mvs.c	/^local char *readd(d)$/;"	f
readd	human68k/human68k.c	/^local char *readd(DIR* d)$/;"	f	signature:(DIR* d)
readd	novell/Netware.c	/^local char *readd(d)$/;"	f
readd	os2/os2.c	/^local char *readd(d)$/;"	f
readd	tandem/tanzip.c	/^  local char *readd(d)$/;"	f
readd	theos/theos.c	/^local char *readd(d)$/;"	f
readd	tops20/tops20.c	/^local char *readd(d)$/;"	f
readd	unix/unix.c	/^local char *readd(d)$/;"	f
readd	vms/vmszip.c	/^local char *readd( zDIR *d)$/;"	f	signature:( zDIR *d)
readd	win32/win32zip.c	/^local char *readd(d)$/;"	f
readdir	acorn/riscos.c	/^struct dirent *readdir(DIR *d)$/;"	f	signature:(DIR *d)
readdir	amiga/stat.c	/^struct dirent *readdir(DIR *dd)$/;"	f	signature:(DIR *dd)
readdir	beos/beos.c	/^struct dirent *readdir(dirp)$/;"	f
readdir	cmsmvs/mvs.c	/^struct dirent *readdir(DIR *dirp)$/;"	f	signature:(DIR *dirp)
readdir	os2/os2zip.c	/^struct dirent *readdir(DIR * dirp)$/;"	f	signature:(DIR * dirp)
readdir	tandem/tandem.c	/^struct dirent *readdir(DIR *dirp)$/;"	f	signature:(DIR *dirp)
readdir	unix/unix.c	/^struct dirent *readdir(dirp)$/;"	f
readdw	win32/win32zip.c	/^local wchar_t *readdw(dw)$/;"	f
readlocal	zipfile.c	/^int readlocal(localz, z)$/;"	f
readzipfile	zipfile.c	/^int readzipfile()$/;"	f
real_timezone_is_set	timezone.c	/^int real_timezone_is_set = FALSE;       \/* set by tzset() *\/$/;"	v
reason	acorn/match.s	/^; If, for some reason, both of these files are missing, the Info-ZIP license$/;"	v
reason	acorn/sendbits.s	/^; If, for some reason, both of these files are missing, the Info-ZIP license$/;"	v
reason	acorn/swiven.s	/^; If, for some reason, both of these files are missing, the Info-ZIP license$/;"	v
reason	amiga/crc_68.a	/^; If, for some reason, all these files are missing, the Info-ZIP license$/;"	v
reason	amiga/deflate.a	/^; If, for some reason, both of these files are missing, the Info-ZIP license$/;"	v
reason	amiga/match.a	/^; If, for some reason, both of these files are missing, the Info-ZIP license$/;"	v
reason	amiga/match_68.a	/^; If, for some reason, both of these files are missing, the Info-ZIP license$/;"	v
reason	human68k/crc_68.s	/^; If, for some reason, all these files are missing, the Info-ZIP license$/;"	v
reason	human68k/deflate.s	/^; If, for some reason, both of these files are missing, the Info-ZIP license$/;"	v
reason	human68k/match.s	/^* If, for some reason, both of these files are missing, the Info-ZIP license$/;"	v
reason	msdos/crc_i86.asm	/^; If, for some reason, all these files are missing, the Info-ZIP license$/;"	v
reason	msdos/match.asm	/^; If, for some reason, all these files are missing, the Info-ZIP license$/;"	v
reason	os2/match32.asm	/^; If, for some reason, all these files are missing, the Info-ZIP license$/;"	v
reason	qdos/config.s	/^; If, for some reason, both of these files are missing, the Info-ZIP license$/;"	v
reason	qdos/crc68.s	/^; If, for some reason, all these files are missing, the Info-ZIP license$/;"	v
reason	qdos/match.s	/^; If, for some reason, both of these files are missing, the Info-ZIP license$/;"	v
reason	win32/crc_i386.asm	/^; If, for some reason, all these files are missing, the Info-ZIP license$/;"	v
reason	win32/crc_lcc.asm	/^; If, for some reason, all these files are missing, the Info-ZIP license$/;"	v
reason	win32/lm32_lcc.asm	/^; If, for some reason, both of these files are missing, the Info-ZIP license$/;"	v
reason	win32/match32.asm	/^; If, for some reason, all these files are missing, the Info-ZIP license$/;"	v
recfm	proginfo/fileinfo.cms	/^     fixed blocked CMS file, you can open the file with recfm=fb and$/;"	v
reclen	tandem/tandem.h	/^  unsigned reclen    : 12;$/;"	m	struct:nsk_file_attrs_def	access:public
recmatch	util.c	/^local int recmatch(p, s, cs)$/;"	f
recmatchw	util.c	/^local long recmatchw(pw, sw, cs)$/;"	f
record	msdos/README.DOS	/^   the structure of the "end-of-central-directory" record, where the these$/;"	v
record	proginfo/fileinfo.cms	/^     a maximum of n bytes per record, you must specify a minimum LRECL$/;"	v
record	proginfo/fileinfo.cms	/^     less than a complete record, the requested bytes are copied to your$/;"	v
record	proginfo/fileinfo.cms	/^     maximum expected length of the record, fread() returns the length,$/;"	v
record	proginfo/fileinfo.cms	/^     try to write a short record, C\/370 pads the record with nulls out$/;"	v
record	proginfo/ziplimit.txt	/^   the structure of the "end-of-central-directory" record, where the these$/;"	v
recurse	globals.c	/^int recurse = 0;        \/* 1=recurse into directories encountered *\/$/;"	v
refresheof	tandem/tandem.h	/^  unsigned refresheof  : 1;$/;"	m	struct:nsk_file_flags	access:public
regerror	atari/atari.c	/^void regerror( char ZCONST *msg ) {$/;"	f	signature:( char ZCONST *msg )
registers	win32/crc_i386.asm	/^; scratch registers:$/;"	v
regptr	atari/atari.c	/^static regexp *regptr;$/;"	v	file:
relative_dir_s	vms/vmszip.c	/^local int relative_dir_s = 0;   \/* Relative directory spec. *\/$/;"	v
releases	Betas_Readme.txt	/^All code, including releases, are released under the Info-ZIP license.$/;"	v
remain	zipup.c	/^  local ulg remain;$/;"	v
remove_central_extra_field	zipfile.c	/^local int remove_central_extra_field(pZEntry, tag)$/;"	f
remove_local_extra_field	zipfile.c	/^local int remove_local_extra_field(pZEntry, tag)$/;"	f
remove_prefix	acorn/riscos.c	/^void remove_prefix(void)$/;"	f	signature:(void)
rename	fileio.c	/^int rename(from, to)$/;"	f
rename	theos/osdep.h	44;"	d
rename_split	zipcloak.c	/^int rename_split(temp_name, out_path)$/;"	f
rename_split	zipnote.c	/^int rename_split(temp_name, out_path)$/;"	f
rename_split	zipsplit.c	/^int rename_split(temp_name, out_path)$/;"	f
repe	match.S	/^        repe;   cmpsw                   \/* loop until mismatch *\/$/;"	v
repe	win32/lm32_lcc.asm	/^        repe;   cmpsw$/;"	v
replace	fileio.c	/^int replace(d, s)$/;"	f
replace	macos/source/macopen.c	/^int replace(char *new_f, char *temp_f)  \/* destination and source file names *\/$/;"	f	signature:(char *new_f, char *temp_f)
represent	win32/gvmat64.asm	/^;;; It should be confessed that this loop usually does not represent$/;"	v
required	man/zip.1	/^archive is named \\fBarchive\\fP and three splits are required, the resulting$/;"	v
reserved	tandem/tandem.h	/^  struct nsk_stat_reserved reserved;$/;"	m	union:__anon35	typeref:struct:__anon35::nsk_stat_reserved	access:public
reserved	vms/vms.h	/^    ulg reserved;$/;"	m	struct:IZ_block	access:public
rest	cmsmvs/mvs.h	/^   char rest[RECLEN];$/;"	m	struct:__anon21	access:public
rest	vms/vms_im.c	/^    uzoff_t rest;$/;"	m	struct:user_context	file:	access:public
rest	vms/vms_pk.c	/^    uzoff_t             rest;$/;"	m	struct:__anon22	file:	access:public
restore	proginfo/ntsd.txt	/^restore, translates to the correct group name regardless of locale.$/;"	v
result	macos/source/recurse.c	/^    OSErr                   result;         \/* temporary holder of results -$/;"	m	struct:RecurseGlobals	file:	access:public
resulting$	tags	/^required	man\/zip.1	\/^archive is named \\\\fBarchive\\\\fP and three splits are required, the resulting$\/;"	v$/;"	v
results	win32/crc_i386.asm	/^        ; Actually, this option is set as default, because it results$/;"	v
ret	atari/atari.c	/^static int    ret;$/;"	v	file:
ret	win32/gvmat64.asm	/^        ret 0$/;"	v
ret_len	vms/vms.c	/^    int *ret_len;$/;"	m	struct:__anon25	file:	access:public
retry	zipsplit.c	/^local int retry()$/;"	f
rev_long	qdos/qdos.c	/^long rev_long (ulg l)$/;"	f	signature:(ulg l)
rev_long	qdos/qdos.c	124;"	d	file:
rev_short	qdos/qdos.c	/^short rev_short (ush s)$/;"	f	signature:(ush s)
rev_short	qdos/qdos.c	123;"	d	file:
rewinddir	cmsmvs/mvs.c	/^void rewinddir(DIR *dirp)$/;"	f	signature:(DIR *dirp)
rewinddir	os2/os2zip.h	67;"	d
rewinddir	tandem/tandem.c	/^void rewinddir(DIR *dirp)$/;"	f	signature:(DIR *dirp)
rightStatusString	macos/source/helpers.c	/^void rightStatusString(char *status)$/;"	f	signature:(char *status)
riscos_direntry	acorn/riscos.h	/^} riscos_direntry;$/;"	t	typeref:struct:__anon9
riscos_fseek	acorn/riscos.c	/^int riscos_fseek(FILE *fd, long offset, int whence)$/;"	f	signature:(FILE *fd, long offset, int whence)
riscos_gmtime	acorn/riscos.c	/^struct tm *riscos_gmtime(const time_t *timer)$/;"	f	signature:(const time_t *timer)
riscos_localtime	acorn/riscos.c	/^struct tm *riscos_localtime(const time_t *timer)$/;"	f	signature:(const time_t *timer)
rmdir	amiga/stat.c	/^int rmdir(const char *path)$/;"	f	signature:(const char *path)
rms_defaults_known	vms/vms.c	/^static int rms_defaults_known = 0;$/;"	v	file:
rms_ext	vms/vms.c	/^static unsigned short rms_ext;$/;"	v	file:
rms_ext_active	vms/vms.c	/^unsigned short rms_ext_active;$/;"	v
rms_ext_itm	vms/vms.c	/^    jpi_item_t rms_ext_itm;$/;"	m	struct:__anon26	file:	access:public
rms_ext_len	vms/vms.c	/^static int rms_ext_len;         \/* Should come back 2. *\/$/;"	v	file:
rms_mbc	vms/vms.c	/^static char rms_mbc;$/;"	v	file:
rms_mbc_active	vms/vms.c	/^char rms_mbc_active;$/;"	v
rms_mbc_itm	vms/vms.c	/^    jpi_item_t rms_mbc_itm;$/;"	m	struct:__anon26	file:	access:public
rms_mbc_len	vms/vms.c	/^static int rms_mbc_len;         \/* Should come back 1. *\/$/;"	v	file:
rms_mbf	vms/vms.c	/^static unsigned char rms_mbf;$/;"	v	file:
rms_mbf_active	vms/vms.c	/^unsigned char rms_mbf_active;$/;"	v
rms_mbf_itm	vms/vms.c	/^    jpi_item_t rms_mbf_itm;$/;"	m	struct:__anon26	file:	access:public
rms_mbf_len	vms/vms.c	/^static int rms_mbf_len;         \/* Should come back 1. *\/$/;"	v	file:
rn	vms/vms.h	/^    ush tag_rn; ush len_rn;     ush  rn;$/;"	m	struct:__anon23	access:public
rn	vms/vms.h	/^    ush tag_rn; ush len_rn;     ush  rn;$/;"	m	struct:__anon24	access:public
rollforward	tandem/tandem.h	/^  unsigned rollforward : 1;$/;"	m	struct:nsk_file_flags	access:public
routine	msdos/crc_i86.asm	/^;   for this routine, the char buffer size is limited to less than 64 kByte,$/;"	v
rp	vms/vms.h	/^    ush tag_rp; ush len_rp;     byte rp[ATR$S_RPRO];$/;"	m	struct:__anon23	access:public
rp	vms/vms.h	/^    ush tag_rp; ush len_rp;     byte rp[ATR$S_RPRO];$/;"	m	struct:__anon24	access:public
rqcmp	zipfile.c	/^local int rqcmp(a, b)$/;"	f
rsi	win32/gvmat64.asm	/^        lea rsi,[r10+rax]$/;"	v
rsi	win32/gvmat64.asm	/^; register used : rax,rbx,rcx,rdx,rsi,rdi,r8,r9,r10,r11,r12$/;"	v
rts	amiga/deflate.a	/^        rts     ; match_init consists only of rts if CPUTEST unset$/;"	v
rts	amiga/match_68.a	/^        rts                ; match_init consists only of rts if CPUTEST unset$/;"	v
rts	human68k/deflate.s	/^        rts     ; match_init consists only of rts if CPUTEST unset$/;"	v
rule	timezone.h	/^struct rule {$/;"	s
rule::r_day	timezone.h	/^    int             r_day;      \/* day number of rule *\/$/;"	m	struct:rule	access:public
rule::r_mon	timezone.h	/^    int             r_mon;      \/* month number of rule *\/$/;"	m	struct:rule	access:public
rule::r_time	timezone.h	/^    long            r_time;     \/* transition time of rule *\/$/;"	m	struct:rule	access:public
rule::r_type	timezone.h	/^    int             r_type;     \/* type of rule--JULIAN_DAY etc *\/$/;"	m	struct:rule	access:public
rule::r_week	timezone.h	/^    int             r_week;     \/* week number of rule *\/$/;"	m	struct:rule	access:public
rules	TODO	/^- zip and unzip should use the same pattern matching rules, particularly$/;"	v
s	win32/gvmat64.asm	/^;    deflate_state *s;$/;"	v
s	zipfile.c	/^  uzoff_t s;                \/* size of central directory *\/$/;"	v
sBit2Str	macos/source/helpers.c	/^char *sBit2Str(unsigned short value)$/;"	f	signature:(unsigned short value)
safe	amiga/deflate.a	/^DEFREGS reg     d0-d7\/a0\/a2\/a3\/a5       ; play it safe, preserve all regs$/;"	v
safer	zip.txt	/^              a  new  archive name is safer, avoids mismatches between archive$/;"	v
save_pos	vms/cvthelp.tpu	/^  position(save_pos);$/;"	v
save_pos	vms/cvthelp.tpu	/^  save_pos := mark(none);$/;"	v
say	acorn/ReadMe	/^means that if you have, say, SparkFS loaded, zipping a Spark archive will$/;"	v
scan	msdos/match.asm	/^; at this point, di == scan+2, si = cur_match,$/;"	v
scan	msdos/match.asm	/^; at this point, ds:di == scan+2, ds:si == cur_match$/;"	v
scan	os2/match32.asm	/^; at this point, edi == scan+2, esi == cur_match$/;"	v
scan	os2/match32.asm	/^; at this point, edi == scan+2, esi == cur_match,$/;"	v
scan	win32/gvmat64.asm	/^;;; register Bytef *scan = s->window + s->strstart;$/;"	v
scan	win32/match32.asm	/^; at this point, edi == scan+2, esi == cur_match$/;"	v
scan	win32/match32.asm	/^; at this point, edi == scan+2, esi == cur_match,$/;"	v
scan_count	globals.c	/^uzoff_t scan_count = 0; \/* Used for Scanning files ... message *\/$/;"	v
scan_delay	globals.c	/^time_t scan_delay = 5;  \/* seconds before display Scanning files message *\/$/;"	v
scan_dot_time	globals.c	/^time_t scan_dot_time = 2; \/* time in seconds between Scanning files dots *\/$/;"	v
scan_end	win32/gvmat64.asm	/^;;; register ush scan_end   = *(ushf*)(scan+best_len-1);$/;"	v
scan_last	globals.c	/^time_t scan_last = 0;   \/* time of last message *\/$/;"	v
scan_start	globals.c	/^time_t scan_start = 0;  \/* start of scan *\/$/;"	v
scan_start	win32/gvmat64.asm	/^;;; register ush scan_start = *(ushf*)scan;$/;"	v
scan_started	globals.c	/^int scan_started = 0;   \/* scan has started *\/$/;"	v
scan_tree	trees.c	/^local void scan_tree (tree, max_code)$/;"	f
scanimage	globals.c	/^int scanimage = 1;      \/* 1=scan through image files *\/$/;"	v
scanzipf_fix	zipfile.c	/^local int scanzipf_fix(f)$/;"	f
scanzipf_fixnew	zipfile.c	/^local int scanzipf_fixnew()$/;"	f
scanzipf_reg	zipfile.c	/^local int scanzipf_reg(f)$/;"	f
scanzipf_regnew	zipfile.c	/^local int scanzipf_regnew()$/;"	f
sco_x286	INSTALL	/^     att6300, coherent, cray_v3, minix, sco_x286, xenix, zilog.$/;"	v
screensize	ttyio.c	/^int screensize(tt_rows, tt_cols)$/;"	f
scrutiny	win32/gvmat64.asm	/^;;; Point edi to the string under scrutiny, and esi to the string we$/;"	v
sdos	CHANGES	/^ 3. use #elif constructions for msdos,os2 and win32 compiler detection (Onno)$/;"	v
search	util.c	/^zvoid far **search(b, a, n, cmp)$/;"	f
secext	tandem/tandem.h	/^  unsigned short secext;    \/* 16 *\/$/;"	m	struct:nsk_file_attrs_def	access:public
seconds	zip.txt	/^       process  (if  needed).  If this scan takes longer than about 5 seconds,$/;"	v
secpart	tandem/tandem.h	/^  unsigned secpart     : 1;$/;"	m	struct:nsk_file_flags	access:public
seekable	zipup.c	/^int seekable()$/;"	f
seekdir	os2/os2zip.c	/^void seekdir(DIR * dirp, long off)$/;"	f	signature:(DIR * dirp, long off)
segments	msdos/match.asm	/^;   SS_NEQ_DS  : relaxes assumption that stack and default data segments$/;"	v
select	zip.h	/^  int select;                   \/* Selection flag ('i' or 'x') *\/$/;"	m	struct:plist	access:public
send_all_trees	trees.c	/^local void send_all_trees(lcodes, dcodes, blcodes)$/;"	f
send_bits	trees.c	/^local void send_bits(value, length)$/;"	f
send_code	trees.c	448;"	d	file:
send_code	trees.c	452;"	d	file:
send_tree	trees.c	/^local void send_tree (tree, max_code)$/;"	f
sendpkt	amiga/filedate.c	/^LONG sendpkt(pid,action,args,nargs)$/;"	f
serial	tandem/tandem.h	/^  unsigned serial      : 1;$/;"	m	struct:nsk_file_flags	access:public
set	zip30f.ann	/^  Windows in the local OEM character set, as some other zips do$/;"	v
set_TZ	amiga/filedate.c	/^void set_TZ(long time_zone, int day_light)$/;"	f	signature:(long time_zone, int day_light)
set_extra_field	acorn/acornzip.c	/^int set_extra_field(z, z_utim)$/;"	f
set_extra_field	amiga/amigazip.c	/^int set_extra_field(z, z_utim)$/;"	f
set_extra_field	aosvs/aosvs.c	/^int set_extra_field(z, z_utim)$/;"	f
set_extra_field	atari/atari.c	/^int set_extra_field(z, z_utim)$/;"	f
set_extra_field	atheos/atheos.c	/^int set_extra_field(z, z_utim)$/;"	f
set_extra_field	beos/beos.c	/^int set_extra_field(z, z_utim)$/;"	f
set_extra_field	cmsmvs/cmsmvs.c	/^int set_extra_field(z, z_utim)$/;"	f
set_extra_field	human68k/human68k.c	/^int set_extra_field(z, z_utim)$/;"	f
set_extra_field	macos/source/extrafld.c	/^int set_extra_field(struct zlist far *z, iztimes *z_utim)$/;"	f	signature:(struct zlist far *z, iztimes *z_utim)
set_extra_field	msdos/msdos.c	/^int set_extra_field(z, z_utim)$/;"	f
set_extra_field	novell/Netware.c	/^int set_extra_field(z, z_utim)$/;"	f
set_extra_field	os2/os2zip.c	/^int set_extra_field(struct zlist far *z, iztimes *z_utim)$/;"	f	signature:(struct zlist far *z, iztimes *z_utim)
set_extra_field	qdos/qdos.c	/^int set_extra_field (struct zlist *z, iztimes *z_utim )$/;"	f	signature:(struct zlist *z, iztimes *z_utim )
set_extra_field	tandem/tanzip.c	/^  int set_extra_field(z, z_utim)$/;"	f
set_extra_field	theos/theos.c	/^int set_extra_field(z, z_utim)$/;"	f
set_extra_field	tops20/tops20.c	/^int set_extra_field(z, z_utim)$/;"	f
set_extra_field	unix/unix.c	/^int set_extra_field(z, z_utim)$/;"	f
set_extra_field	vms/vms_im.c	/^int set_extra_field(z, z_utim)$/;"	f
set_extra_field	win32/win32zip.c	/^int set_extra_field(z, z_utim)$/;"	f
set_file_type	trees.c	/^local void set_file_type()$/;"	f
set_filetype	zipcloak.c	/^int set_filetype(out_path)$/;"	f
set_filetype	zipnote.c	/^int set_filetype(out_path)$/;"	f
set_filetype	zipsplit.c	/^int set_filetype(out_path)$/;"	f
set_new_unix_extra_field	unix/unix.c	/^int set_new_unix_extra_field(z, s)$/;"	f
set_prefix	acorn/riscos.c	/^void set_prefix(void)$/;"	f	signature:(void)
setenv	amiga/amiga.c	82;"	d	file:
setenv	amiga/amiga.c	84;"	d	file:
setenv	amiga/filedate.c	/^int setenv(const char *var, const char *value, int overwrite)$/;"	f	signature:(const char *var, const char *value, int overwrite)
setfileattr	fileio.c	/^int setfileattr(f, a)$/;"	f
setfiletype	acorn/riscos.c	/^void setfiletype(char *fname,int ftype)$/;"	f	signature:(char *fname,int ftype)
setfiletype	atheos/atheos.c	/^void setfiletype(const char *file, const char *type)$/;"	f	signature:(const char *file, const char *type)
setfiletype	beos/beos.c	/^void setfiletype( const char *file, const char *type )$/;"	f	signature:( const char *file, const char *type )
setfiletype	macos/source/macos.c	/^void setfiletype(char *new_f, unsigned long Creator, unsigned long Type)$/;"	f	signature:(char *new_f, unsigned long Creator, unsigned long Type)
severity	ziperr.h	/^    int severity;$/;"	m	struct:__anon1	access:public
severity	ziperr.h	/^    int severity;$/;"	m	struct:__anon2	access:public
sg_flags	ttyio.c	128;"	d	file:
sg_flags	ttyio.c	144;"	d	file:
sgttyb	ttyio.c	127;"	d	file:
sgttyb	ttyio.c	143;"	d	file:
sh_op_not_sup_err	fileio.c	/^static ZCONST char Far sh_op_not_sup_err[] = "short option '%c' not supported";$/;"	v	file:
shared	LICENSE	/^       modified or added functionality, and dynamic, shared, or static library$/;"	v
shared	tags	/^functionality	LICENSE	\/^       modified or added functionality, and dynamic, shared, or static library$\/;"	v$/;"	v
shared	tags	/^shared	LICENSE	\/^       modified or added functionality, and dynamic, shared, or static library$\/;"	v$/;"	v
shell	TODO	/^- on NT with C shell, zip should not do file name expansion again.$/;"	v
shmatch	util.c	/^int shmatch(p, s, cs)$/;"	f
short_loop	msdos/match.asm	/^short_loop:$/;"	v
short_loop	win32/lm32_lcc.asm	/^short_loop:$/;"	v
shortid	qdos/qdos.c	/^    unsigned short shortid __attribute__ ((packed));$/;"	m	struct:__anon33	file:	access:public
shortopt	zip.h	/^  char *shortopt;           \/* char * to sequence of char that is short option *\/$/;"	m	struct:option_struct	access:public
show_VMSCLI_help	vms/cmdline.c	/^static int show_VMSCLI_help;$/;"	v	file:
show_files	globals.c	/^int show_files = 0;           \/* show files to operate on and exit (=2 log only) *\/$/;"	v
si	msdos/crc_i86.asm	/^        mov     si,ax                           ;crc_table$/;"	v
si	msdos/match.asm	/^        add     si,2+window_off         ; si = match$/;"	v
si	msdos/match.asm	/^        mov     si,cur_match            ; use bp before it is destroyed$/;"	v
si	msdos/match.asm	/^;       match        equ es:si$/;"	v
si	msdos/match.asm	/^; at this point, di == scan+2, si = cur_match,$/;"	v
si	os2/match32.asm	/^        mov     si,prev[esi]            ; cur_match = prev[cur_match]$/;"	v
sig	vms/vms.h	/^    ush sig;$/;"	m	struct:IZ_block	access:public
sig	vms/vms_im.c	/^    ulg sig;$/;"	m	struct:user_context	file:	access:public
sigbuf	zipfile.c	/^local char sigbuf[4];   \/* signature found *\/$/;"	v
signal	amiga/stat.c	/^__signal_return_type signal()  { return SIG_ERR; }$/;"	f
similarly	proginfo/ZipPorts	/^      clude files), using braces and comments similarly, NO TABS (see rule$/;"	v
simple	zipsplit.c	/^local extent simple(a, n, c, d)$/;"	f
siz	zip.h	/^  uzoff_t siz, len;             \/* zip64 support 08\/29\/2003 R.Nausedat *\/$/;"	m	struct:zlist	access:public
size	acorn/riscos.h	/^  int size;$/;"	m	struct:__anon8	access:public
size	acorn/riscos.h	/^  short         size;$/;"	m	struct:__anon10	access:public
size	man/zip.1	/^archive reaches the specified split size, that split is closed and the next split$/;"	v
size	vms/vms.h	/^    ush         size;$/;"	m	struct:PK_field	access:public
size	vms/vms.h	/^    ush size;$/;"	m	struct:EB_header	access:public
size	vms/vms.h	/^    ush size;$/;"	m	struct:IZ_block	access:public
size	vms/vms.h	/^    ush size;$/;"	m	struct:PK_header	access:public
size	vms/vms_im.c	/^    uzoff_t size;$/;"	m	struct:user_context	file:	access:public
size	vms/vms_pk.c	/^    uzoff_t             size;$/;"	m	struct:__anon22	file:	access:public
size_t	msdos/msdos.c	50;"	d	file:
size_t	msdos/msdos.c	54;"	d	file:
size_t	tailor.h	/^   typedef unsigned int size_t;$/;"	t
skip_comments	macos/source/getenv.c	/^void skip_comments(FILE *file)$/;"	f	signature:(FILE *file)
skip_current_disk	globals.c	/^ulg     skip_current_disk = 0;  \/* if != 0 and fix then skip entries on this disk *\/$/;"	v
skip_this_disk	globals.c	/^ulg skip_this_disk = 0;$/;"	v
skipspace	novell/Netware.c	23;"	d	file:
sliding	amiga/deflate.a	/^; void fill_window(void) calls the input function to refill the sliding$/;"	v
sliding	deflate.c	/^local int sliding;$/;"	v
sliding	human68k/deflate.s	/^; void fill_window(void) calls the input function to refill the sliding$/;"	v
slist_items	tandem/tandem.c	514;"	d	file:
slow	amiga/deflate.a	/^                dc.w    32,258,258,4096 ; level 9: maximum compression, slow$/;"	v
slow	human68k/deflate.s	/^                dc.w    32,258,258,4096 ; level 9: maximum compression, slow$/;"	v
smaller	trees.c	593;"	d	file:
some	msdos/match.asm	/^; When SS_NEQ_DS is defined, the code segment is used to store some$/;"	v
sortcmp	theos/_setargv.c	/^static int sortcmp(char **p, char **q)$/;"	f	file:	signature:(char **p, char **q)
source	amiga/deflate.a	/^;   DYN_ALLOC  should be defined here if it is defined for C source; tells us$/;"	v
source	amiga/deflate.a	/^;   SMALL_MEM  define this if it is defined in the C source; otherwise it uses$/;"	v
source	human68k/deflate.s	/^;   DYN_ALLOC  should be defined here if it is defined for C source; tells us$/;"	v
source	human68k/deflate.s	/^;   SMALL_MEM  define this if it is defined in the C source; otherwise it uses$/;"	v
sp	acorn/match.s	/^        STMFD   sp!, {r4-r9,fp,lr}$/;"	v
sp	acorn/sendbits.s	/^        STMDB   sp!,{r4,r5,fp,ip,lr,pc}$/;"	v
sp	acorn/swiven.s	/^        LDMFD   sp!, {r1-r5,pc}^$/;"	v
sp	acorn/swiven.s	/^        LDMFD   sp!, {r2-r6,pc}^$/;"	v
sp	acorn/swiven.s	/^        LDMFD   sp!, {r2}$/;"	v
sp	acorn/swiven.s	/^        LDMFD   sp!, {r3-r5,pc}^$/;"	v
sp	acorn/swiven.s	/^        LDMFD   sp!, {r3}$/;"	v
sp	acorn/swiven.s	/^        LDMFD   sp!, {r4,pc}^$/;"	v
sp	acorn/swiven.s	/^        LDMFD   sp!, {r4-r5,pc}^$/;"	v
sp	acorn/swiven.s	/^        LDMFD   sp!, {r4-r6,pc}^$/;"	v
sp	acorn/swiven.s	/^        LDMFD   sp!, {r5,pc}^$/;"	v
sp	acorn/swiven.s	/^        LDMFD   sp, {r5,r6}$/;"	v
sp	acorn/swiven.s	/^        LDMVSFD sp!, {r1-r5,pc}^$/;"	v
sp	acorn/swiven.s	/^        LDMVSFD sp!, {r2,r3-r5,pc}^$/;"	v
sp	acorn/swiven.s	/^        LDMVSFD sp!, {r2-r6,pc}^$/;"	v
sp	acorn/swiven.s	/^        LDMVSFD sp!, {r3-r6,pc}^$/;"	v
sp	acorn/swiven.s	/^        LDMVSFD sp!, {r4,pc}^$/;"	v
sp	acorn/swiven.s	/^        STMFD   sp!, {r1-r5,lr}$/;"	v
sp	acorn/swiven.s	/^        STMFD   sp!, {r2,r3-r5,lr}$/;"	v
sp	acorn/swiven.s	/^        STMFD   sp!, {r2-r6,lr}$/;"	v
sp	acorn/swiven.s	/^        STMFD   sp!, {r3-r6,lr}$/;"	v
sp	acorn/swiven.s	/^        STMFD   sp!, {r4,lr}$/;"	v
sp	acorn/swiven.s	/^        STMFD   sp!, {r4-r5,lr}$/;"	v
sp	acorn/swiven.s	/^        STMFD   sp!, {r5,lr}$/;"	v
sp	amiga/deflate.a	/^        move.l  _head,(sp)              ; reuse the same stack arg slot$/;"	v
sp	msdos/crc_i86.asm	/^        mov     sp,bp$/;"	v
sparc	unix/Packaging/README	/^   Where:  $(arch) := system architecture, currently i386, sparc, or ppc.$/;"	v
spare	tandem/tandem.h	/^  int64_t spare[3];$/;"	m	struct:nsk_stat_reserved	access:public
spare	vms/vms.c	/^const int spare[ 8] = { 0 };$/;"	v
spec	vms/vms.h	/^    ulg spec;$/;"	m	struct:iosb	access:public
special	globals.c	/^char *special = " Z: zip: zoo: arc: lzh: arj"; \/* List of special suffixes *\/$/;"	v
special	globals.c	/^char *special = ".Z:.zip:.zoo:.arc:.lzh:.arj"; \/* List of special suffixes *\/$/;"	v
special	globals.c	/^char *special = "DDC:D96:68E";$/;"	v
special	globals.c	/^char *special = "_Z:_zip:_zoo:_arc:_lzh:_arj"; \/* List of special suffixes *\/$/;"	v
speed	amiga/match.a	/^; For maximum speed, UNALIGNED_OK can be defined in Makefile.sasc.$/;"	v
speed	qdos/match.s	/^; For maximum speed, UNALIGNED_OK can be defined in Makefile.sasc.$/;"	v
split	api.h	/^  DLLSPLIT *split;      \/* This MUST be set to NULL unless you want to be queried$/;"	m	struct:__anon32	access:public
split	windll/windll.txt	/^DLLSPLIT *split;		\/* This MUST be set to NULL unless you want to be queried$/;"	m	struct:__anon20	file:	access:public
split_bell	globals.c	/^int split_bell = 0;               \/* when pause for next split ring bell *\/$/;"	v
split_method	globals.c	/^int split_method = 0;             \/* 0=no splits, 1=seekable, 2=data desc, -1=no *\/$/;"	v
split_size	globals.c	/^uzoff_t split_size = 0;           \/* how big each split should be *\/$/;"	v
splits	proginfo/infozip.who	/^                                                        large files, splits, DLLs$/;"	v
sstrcat	macos/source/helpers.c	/^char *sstrcat(char *to,const char *from)$/;"	f	signature:(char *to,const char *from)
sstrcpy	macos/source/helpers.c	/^char *sstrcpy(char *to,const char *from)$/;"	f	signature:(char *to,const char *from)
st_atime	acorn/riscos.h	/^  time_t st_atime;$/;"	m	struct:stat	access:public
st_atime	amiga/z-stat.h	/^    time_t st_ctime, st_atime, st_mtime;$/;"	m	struct:stat	access:public
st_atime	cmsmvs/cstat.h	/^    long  st_atime;    \/* Most recent access                   *\/$/;"	m	struct:stat	access:public
st_atime	theos/stat.h	/^    unsigned long   st_atime;       \/* not used *\/$/;"	m	struct:stat	access:public
st_attr	amiga/z-stat.h	/^    short st_attr, st_dev, st_nlink, st_uid, st_gid, st_rdev;$/;"	m	struct:stat	access:public
st_blksize	acorn/riscos.h	/^  unsigned int st_blksize;$/;"	m	struct:stat	access:public
st_blksize	theos/stat.h	/^    unsigned long   st_blksize;     \/* buffer size *\/$/;"	m	struct:stat	access:public
st_blocks	amiga/z-stat.h	/^    long st_blocks;$/;"	m	struct:stat	access:public
st_ctime	acorn/riscos.h	/^  time_t st_ctime;$/;"	m	struct:stat	access:public
st_ctime	amiga/z-stat.h	/^    time_t st_ctime, st_atime, st_mtime;$/;"	m	struct:stat	access:public
st_ctime	cmsmvs/cstat.h	/^    long  st_ctime;    \/* Same as st_atime                     *\/$/;"	m	struct:stat	access:public
st_ctime	theos/stat.h	/^    unsigned long   st_ctime;       \/* not used *\/$/;"	m	struct:stat	access:public
st_dev	acorn/riscos.h	/^  unsigned int st_dev;$/;"	m	struct:stat	access:public
st_dev	amiga/z-stat.h	/^    short st_attr, st_dev, st_nlink, st_uid, st_gid, st_rdev;$/;"	m	struct:stat	access:public
st_dev	cmsmvs/cstat.h	/^    short st_dev;      \/* Drive number of disk containing the  *\/$/;"	m	struct:stat	access:public
st_dev	theos/stat.h	/^    short           st_dev;         \/* not used *\/$/;"	m	struct:stat	access:public
st_gid	acorn/riscos.h	/^  unsigned short st_gid;$/;"	m	struct:stat	access:public
st_gid	amiga/z-stat.h	/^    short st_attr, st_dev, st_nlink, st_uid, st_gid, st_rdev;$/;"	m	struct:stat	access:public
st_gid	cmsmvs/cstat.h	/^    int   st_gid;      \/* Not meaningfull for VM\/CMS           *\/$/;"	m	struct:stat	access:public
st_gid	theos/stat.h	/^    short           st_gid;         \/* not used *\/$/;"	m	struct:stat	access:public
st_grow	theos/stat.h	/^    char            st_grow;        \/* growing factor *\/$/;"	m	struct:stat	access:public
st_ino	acorn/riscos.h	/^  int st_ino;$/;"	m	struct:stat	access:public
st_ino	amiga/z-stat.h	/^    long st_ino;$/;"	m	struct:stat	access:public
st_ino	cmsmvs/cstat.h	/^    short st_ino;      \/* Not meaningfull for VM\/CMS           *\/$/;"	m	struct:stat	access:public
st_ino	theos/stat.h	/^    short           st_ino;         \/* not used *\/$/;"	m	struct:stat	access:public
st_klen	theos/stat.h	/^    unsigned short  st_klen;        \/* key size *\/$/;"	m	struct:stat	access:public
st_mode	acorn/riscos.h	/^  unsigned int st_mode;$/;"	m	struct:stat	access:public
st_mode	amiga/z-stat.h	/^    unsigned short st_mode;$/;"	m	struct:stat	access:public
st_mode	cmsmvs/cstat.h	/^    short st_mode;     \/* Bit mask giving information about    *\/$/;"	m	struct:stat	access:public
st_mode	theos/stat.h	/^    unsigned short  st_mode;        \/* file attributes *\/$/;"	m	struct:stat	access:public
st_mtime	acorn/riscos.h	/^  time_t st_mtime;$/;"	m	struct:stat	access:public
st_mtime	amiga/z-stat.h	/^    time_t st_ctime, st_atime, st_mtime;$/;"	m	struct:stat	access:public
st_mtime	cmsmvs/cstat.h	/^    long  st_mtime;    \/* Same as st_atime                     *\/$/;"	m	struct:stat	access:public
st_mtime	theos/stat.h	/^    unsigned long   st_mtime;       \/* date & time last modified *\/$/;"	m	struct:stat	access:public
st_nlink	acorn/riscos.h	/^  int st_nlink;$/;"	m	struct:stat	access:public
st_nlink	amiga/z-stat.h	/^    short st_attr, st_dev, st_nlink, st_uid, st_gid, st_rdev;$/;"	m	struct:stat	access:public
st_nlink	cmsmvs/cstat.h	/^    short st_nlink;    \/* Set to the integer constant 1        *\/$/;"	m	struct:stat	access:public
st_nlink	theos/stat.h	/^    short           st_nlink;       \/* not used *\/$/;"	m	struct:stat	access:public
st_org	theos/stat.h	/^    unsigned short  st_org;         \/* organization *\/$/;"	m	struct:stat	access:public
st_protect	theos/stat.h	/^    char            st_protect;     \/* native protections *\/$/;"	m	struct:stat	access:public
st_rdev	acorn/riscos.h	/^  unsigned int st_rdev;$/;"	m	struct:stat	access:public
st_rdev	amiga/z-stat.h	/^    short st_attr, st_dev, st_nlink, st_uid, st_gid, st_rdev;$/;"	m	struct:stat	access:public
st_rdev	cmsmvs/cstat.h	/^    short st_rdev;     \/* Same as st_dev                       *\/$/;"	m	struct:stat	access:public
st_rdev	theos/stat.h	/^    short           st_rdev;        \/* not used *\/$/;"	m	struct:stat	access:public
st_rlen	theos/stat.h	/^    unsigned short  st_rlen;        \/* record size *\/$/;"	m	struct:stat	access:public
st_size	acorn/riscos.h	/^  unsigned int st_size;$/;"	m	struct:stat	access:public
st_size	amiga/z-stat.h	/^    long st_size;$/;"	m	struct:stat	access:public
st_size	cmsmvs/cstat.h	/^    long  st_size;     \/* Size of the file in bytes            *\/$/;"	m	struct:stat	access:public
st_size	theos/stat.h	/^    unsigned long   st_size;        \/* size of file *\/$/;"	m	struct:stat	access:public
st_uid	acorn/riscos.h	/^  unsigned short st_uid;$/;"	m	struct:stat	access:public
st_uid	amiga/z-stat.h	/^    short st_attr, st_dev, st_nlink, st_uid, st_gid, st_rdev;$/;"	m	struct:stat	access:public
st_uid	cmsmvs/cstat.h	/^    int   st_uid;      \/* Not meaningfull for VM\/CMS           *\/$/;"	m	struct:stat	access:public
st_uid	theos/stat.h	/^    short           st_uid;         \/* owner id *\/$/;"	m	struct:stat	access:public
stack	os2/match32.asm	/^; argument for longest_match in the EAX register, not on the stack, with$/;"	v
stamp	acorn/acornzip.c	/^void stamp(f, d)$/;"	f
stamp	amiga/amigazip.c	/^void stamp(f, d)$/;"	f
stamp	aosvs/aosvs.c	/^void stamp(f, d)$/;"	f
stamp	atari/atari.c	/^void stamp(f, d)$/;"	f
stamp	atheos/atheos.c	/^void stamp(f, d)$/;"	f
stamp	beos/beos.c	/^void stamp(f, d)$/;"	f
stamp	cmsmvs/cmsmvs.c	/^void stamp(f, d)$/;"	f
stamp	human68k/human68k.c	/^void stamp(f, d)$/;"	f
stamp	macos/source/macos.c	/^void stamp(char *f, ulg d)$/;"	f	signature:(char *f, ulg d)
stamp	msdos/msdos.c	/^void stamp(f, d)$/;"	f
stamp	novell/Netware.c	/^void stamp(f, d)$/;"	f
stamp	os2/os2.c	/^void stamp(f, d)$/;"	f
stamp	qdos/qfileio.c	/^void stamp(f, d)$/;"	f
stamp	tandem/tanzip.c	/^  void stamp(f, d)$/;"	f
stamp	theos/theos.c	/^void stamp(f, d)$/;"	f
stamp	tops20/tops20.c	/^void stamp(f, d)$/;"	f
stamp	unix/unix.c	/^void stamp(f, d)$/;"	f
stamp	vms/vmszip.c	/^void stamp( char *f, ulg d)$/;"	f	signature:( char *f, ulg d)
stamp	win32/win32zip.c	/^void stamp(f, d)$/;"	f
standard	msdos/crc_i86.asm	/^;  When used with compilers that conform to the Microsoft\/Borland standard$/;"	v
standard	win32/crc_i386.asm	/^        ; Use a `standard' stack frame setup on routine entry and exit.$/;"	v
stat	acorn/riscos.c	/^int stat(char *filename,struct stat *res)$/;"	f	signature:(char *filename,struct stat *res)
stat	acorn/riscos.h	/^struct stat {$/;"	s
stat	amiga/stat.c	/^stat(file,buf)$/;"	f
stat	amiga/z-stat.h	/^struct stat {$/;"	s
stat	cmsmvs/cmsmvs.c	/^int stat(const char *path, struct stat *buf)$/;"	f	signature:(const char *path, struct stat *buf)
stat	cmsmvs/cstat.h	/^struct  stat$/;"	s
stat	macos/ZipLib.h	62;"	d
stat	macos/ZipSx.h	61;"	d
stat	tandem/tandem.c	/^int stat(n, s)$/;"	f
stat	theos/stat.h	/^struct stat {$/;"	s
stat	theos/stat.h	95;"	d
stat::fname	cmsmvs/cstat.h	/^    char  fname[FILENAME_MAX];$/;"	m	struct:stat	access:public
stat::fp	cmsmvs/cstat.h	/^    FILE  *fp;$/;"	m	struct:stat	access:public
stat::st_atime	acorn/riscos.h	/^  time_t st_atime;$/;"	m	struct:stat	access:public
stat::st_atime	amiga/z-stat.h	/^    time_t st_ctime, st_atime, st_mtime;$/;"	m	struct:stat	access:public
stat::st_atime	cmsmvs/cstat.h	/^    long  st_atime;    \/* Most recent access                   *\/$/;"	m	struct:stat	access:public
stat::st_atime	theos/stat.h	/^    unsigned long   st_atime;       \/* not used *\/$/;"	m	struct:stat	access:public
stat::st_attr	amiga/z-stat.h	/^    short st_attr, st_dev, st_nlink, st_uid, st_gid, st_rdev;$/;"	m	struct:stat	access:public
stat::st_blksize	acorn/riscos.h	/^  unsigned int st_blksize;$/;"	m	struct:stat	access:public
stat::st_blksize	theos/stat.h	/^    unsigned long   st_blksize;     \/* buffer size *\/$/;"	m	struct:stat	access:public
stat::st_blocks	amiga/z-stat.h	/^    long st_blocks;$/;"	m	struct:stat	access:public
stat::st_ctime	acorn/riscos.h	/^  time_t st_ctime;$/;"	m	struct:stat	access:public
stat::st_ctime	amiga/z-stat.h	/^    time_t st_ctime, st_atime, st_mtime;$/;"	m	struct:stat	access:public
stat::st_ctime	cmsmvs/cstat.h	/^    long  st_ctime;    \/* Same as st_atime                     *\/$/;"	m	struct:stat	access:public
stat::st_ctime	theos/stat.h	/^    unsigned long   st_ctime;       \/* not used *\/$/;"	m	struct:stat	access:public
stat::st_dev	acorn/riscos.h	/^  unsigned int st_dev;$/;"	m	struct:stat	access:public
stat::st_dev	amiga/z-stat.h	/^    short st_attr, st_dev, st_nlink, st_uid, st_gid, st_rdev;$/;"	m	struct:stat	access:public
stat::st_dev	cmsmvs/cstat.h	/^    short st_dev;      \/* Drive number of disk containing the  *\/$/;"	m	struct:stat	access:public
stat::st_dev	theos/stat.h	/^    short           st_dev;         \/* not used *\/$/;"	m	struct:stat	access:public
stat::st_gid	acorn/riscos.h	/^  unsigned short st_gid;$/;"	m	struct:stat	access:public
stat::st_gid	amiga/z-stat.h	/^    short st_attr, st_dev, st_nlink, st_uid, st_gid, st_rdev;$/;"	m	struct:stat	access:public
stat::st_gid	cmsmvs/cstat.h	/^    int   st_gid;      \/* Not meaningfull for VM\/CMS           *\/$/;"	m	struct:stat	access:public
stat::st_gid	theos/stat.h	/^    short           st_gid;         \/* not used *\/$/;"	m	struct:stat	access:public
stat::st_grow	theos/stat.h	/^    char            st_grow;        \/* growing factor *\/$/;"	m	struct:stat	access:public
stat::st_ino	acorn/riscos.h	/^  int st_ino;$/;"	m	struct:stat	access:public
stat::st_ino	amiga/z-stat.h	/^    long st_ino;$/;"	m	struct:stat	access:public
stat::st_ino	cmsmvs/cstat.h	/^    short st_ino;      \/* Not meaningfull for VM\/CMS           *\/$/;"	m	struct:stat	access:public
stat::st_ino	theos/stat.h	/^    short           st_ino;         \/* not used *\/$/;"	m	struct:stat	access:public
stat::st_klen	theos/stat.h	/^    unsigned short  st_klen;        \/* key size *\/$/;"	m	struct:stat	access:public
stat::st_mode	acorn/riscos.h	/^  unsigned int st_mode;$/;"	m	struct:stat	access:public
stat::st_mode	amiga/z-stat.h	/^    unsigned short st_mode;$/;"	m	struct:stat	access:public
stat::st_mode	cmsmvs/cstat.h	/^    short st_mode;     \/* Bit mask giving information about    *\/$/;"	m	struct:stat	access:public
stat::st_mode	theos/stat.h	/^    unsigned short  st_mode;        \/* file attributes *\/$/;"	m	struct:stat	access:public
stat::st_mtime	acorn/riscos.h	/^  time_t st_mtime;$/;"	m	struct:stat	access:public
stat::st_mtime	amiga/z-stat.h	/^    time_t st_ctime, st_atime, st_mtime;$/;"	m	struct:stat	access:public
stat::st_mtime	cmsmvs/cstat.h	/^    long  st_mtime;    \/* Same as st_atime                     *\/$/;"	m	struct:stat	access:public
stat::st_mtime	theos/stat.h	/^    unsigned long   st_mtime;       \/* date & time last modified *\/$/;"	m	struct:stat	access:public
stat::st_nlink	acorn/riscos.h	/^  int st_nlink;$/;"	m	struct:stat	access:public
stat::st_nlink	amiga/z-stat.h	/^    short st_attr, st_dev, st_nlink, st_uid, st_gid, st_rdev;$/;"	m	struct:stat	access:public
stat::st_nlink	cmsmvs/cstat.h	/^    short st_nlink;    \/* Set to the integer constant 1        *\/$/;"	m	struct:stat	access:public
stat::st_nlink	theos/stat.h	/^    short           st_nlink;       \/* not used *\/$/;"	m	struct:stat	access:public
stat::st_org	theos/stat.h	/^    unsigned short  st_org;         \/* organization *\/$/;"	m	struct:stat	access:public
stat::st_protect	theos/stat.h	/^    char            st_protect;     \/* native protections *\/$/;"	m	struct:stat	access:public
stat::st_rdev	acorn/riscos.h	/^  unsigned int st_rdev;$/;"	m	struct:stat	access:public
stat::st_rdev	amiga/z-stat.h	/^    short st_attr, st_dev, st_nlink, st_uid, st_gid, st_rdev;$/;"	m	struct:stat	access:public
stat::st_rdev	cmsmvs/cstat.h	/^    short st_rdev;     \/* Same as st_dev                       *\/$/;"	m	struct:stat	access:public
stat::st_rdev	theos/stat.h	/^    short           st_rdev;        \/* not used *\/$/;"	m	struct:stat	access:public
stat::st_rlen	theos/stat.h	/^    unsigned short  st_rlen;        \/* record size *\/$/;"	m	struct:stat	access:public
stat::st_size	acorn/riscos.h	/^  unsigned int st_size;$/;"	m	struct:stat	access:public
stat::st_size	amiga/z-stat.h	/^    long st_size;$/;"	m	struct:stat	access:public
stat::st_size	cmsmvs/cstat.h	/^    long  st_size;     \/* Size of the file in bytes            *\/$/;"	m	struct:stat	access:public
stat::st_size	theos/stat.h	/^    unsigned long   st_size;        \/* size of file *\/$/;"	m	struct:stat	access:public
stat::st_uid	acorn/riscos.h	/^  unsigned short st_uid;$/;"	m	struct:stat	access:public
stat::st_uid	amiga/z-stat.h	/^    short st_attr, st_dev, st_nlink, st_uid, st_gid, st_rdev;$/;"	m	struct:stat	access:public
stat::st_uid	cmsmvs/cstat.h	/^    int   st_uid;      \/* Not meaningfull for VM\/CMS           *\/$/;"	m	struct:stat	access:public
stat::st_uid	theos/stat.h	/^    short           st_uid;         \/* owner id *\/$/;"	m	struct:stat	access:public
stat_bandaid	msdos/msdos.c	/^int stat_bandaid(const char *path, struct stat *buf)$/;"	f	signature:(const char *path, struct stat *buf)
stat_bandaid	novell/Netware.c	/^int stat_bandaid(const char *path, struct stat *buf)$/;"	f	signature:(const char *path, struct stat *buf)
stat_t	vms/unixlib_gcc.h	/^typedef struct stat stat_t;$/;"	t	typeref:struct:stat
state	timezone.h	/^struct state {$/;"	s
state::ats	timezone.h	/^    time_t          ats[TZ_MAX_TIMES];$/;"	m	struct:state	access:public
state::charcnt	timezone.h	/^    int             charcnt;$/;"	m	struct:state	access:public
state::chars	timezone.h	/^    char            chars[TZ_MAX_CHARS];$/;"	m	struct:state	access:public
state::timecnt	timezone.h	/^    int             timecnt;$/;"	m	struct:state	access:public
state::ttis	timezone.h	/^    struct ttinfo   ttis[TZ_MAX_TYPES];$/;"	m	struct:state	typeref:struct:state::ttinfo	access:public
state::typecnt	timezone.h	/^    int             typecnt;$/;"	m	struct:state	access:public
state::types	timezone.h	/^    unsigned char   types[TZ_MAX_TIMES];$/;"	m	struct:state	access:public
static_dtree	trees.c	/^local ct_data near static_dtree[D_CODES];$/;"	v
static_len	trees.c	/^local ulg static_len;     \/* bit length of current block with static trees *\/$/;"	v
static_ltree	trees.c	/^local ct_data near static_ltree[L_CODES+2];$/;"	v
static_tree	trees.c	/^    ct_data near *static_tree;   \/* corresponding static tree or NULL *\/$/;"	m	struct:tree_desc	file:	access:public
statime	qdos/qfileio.c	/^typedef time_t statime;$/;"	t	file:
statism	timezone.c	/^static struct state statism;$/;"	v	typeref:struct:state	file:
status	vms/vms.h	/^    ush status;$/;"	m	struct:iosb	access:public
status	vms/vms_im.c	/^    int status;$/;"	m	struct:user_context	file:	access:public
status	vms/vms_pk.c	/^    int                 status;$/;"	m	struct:__anon22	file:	access:public
stderr	zip.h	561;"	d
stderr	zip.h	562;"	d
stores	zip.txt	/^       port wide characters, zip now stores, in addition to the standard local$/;"	v
stpcpy	qdos/qdos.c	/^char * stpcpy (char *d, ZCONST char *s)$/;"	f	signature:(char *d, ZCONST char *s)
str$concat	vms/cmdline.c	104;"	d	file:
str$concat	zip.h	366;"	d
str$find_first_substring	vms/cmdline.c	105;"	d	file:
str$find_first_substring	zip.h	367;"	d
str$free1_dx	vms/cmdline.c	106;"	d	file:
str$free1_dx	zip.h	368;"	d
str_iso_to_oem	util.c	/^char *str_iso_to_oem(dst, src)$/;"	f
str_oem_to_iso	util.c	/^char *str_oem_to_iso(dst, src)$/;"	f
strcasecmp	vms/vmszip.c	213;"	d	file:
strchr	tailor.h	259;"	d
streams	proginfo/fileinfo.cms	/^  C\/370 supports three types of input and output: text streams, binary$/;"	v
streams	proginfo/fileinfo.cms	/^  streams, and record I\/O.  Text and binary streams are both ANSI$/;"	v
strerror	unix/unix.c	/^char *strerror( err)$/;"	f
stricmp	macos/source/helpers.c	/^int stricmp(const char *p1, const char *p2)$/;"	f	signature:(const char *p1, const char *p2)
string	proginfo/fileinfo.cms	/^  and you overwrite it with the string "1234", the record will look$/;"	v
string	vms/build_zip.com	/^$!       string, \/NOTRACEBACK will not be included unless specified by$/;"	v
string	win32/gvmat64.asm	/^;;; Accept the current string, with the maximum possible length.$/;"	v
string	win32/gvmat64.asm	/^;scanstart       equ  rsp + xx - LocalVarsSize   ; first two bytes of string ; stored in r12w$/;"	v
string	ziperr.h	/^    char *string;$/;"	m	struct:__anon1	access:public
string	ziperr.h	/^    char *string;$/;"	m	struct:__anon2	access:public
strings	amiga/deflate.a	/^; long match strings, and costs in the most common case of three-byte matches.$/;"	v
strings	human68k/deflate.s	/^; long match strings, and costs in the most common case of three-byte matches.$/;"	v
strlower	aosvs/aosvs.c	/^char *strlower(s)$/;"	f
strlower	tops20/tops20.c	/^strlower(s)     \/* Returns s in lowercase. *\/$/;"	f	file:
strlower	vms/vmszip.c	/^local char *strlower( char *s)$/;"	f	signature:( char *s)
strncasecmp	vms/vmszip.c	/^int strncasecmp( char *s1, char *s2, size_t n)$/;"	f	signature:( char *s1, char *s2, size_t n)
strrchr	tailor.h	255;"	d
strstart	deflate.c	/^      unsigned near strstart;      \/* start of string to insert *\/$/;"	v
strtoasc	util.c	/^char *strtoasc(char *str1, ZCONST char *str2)$/;"	f	signature:(char *str1, ZCONST char *str2)
strtoebc	util.c	/^char *strtoebc(char *str1, ZCONST char *str2)$/;"	f	signature:(char *str1, ZCONST char *str2)
structlen	api.h	/^    ulg structlen;          \/* length of the struct being passed *\/$/;"	m	struct:_ZpVer	access:public
structlen	windll/windll.txt	/^    ulg structlen;          \/* length of the struct being passed *\/$/;"	m	struct:_ZpVer	file:	access:public
strupper	aosvs/aosvs.c	/^char *strupper(s)$/;"	f
strupper	tops20/tops20.c	/^strupper(s)     \/* Returns s in uppercase *\/$/;"	f	file:
strupper	vms/vmszip.c	/^local char *strupper( char *s)$/;"	f	signature:( char *s)
subq	amiga/deflate.a	/^        subq    #4,Match$/;"	v
subq	human68k/deflate.s	/^        subq    #4,Match$/;"	v
successfully	proginfo/fileinfo.cms	/^     fread() returns the number of items read successfully, so if you$/;"	v
suffixes	acorn/ReadMe	/^of suffixes, this list of suffixes is actually considered as a list of$/;"	v
suffixes	zipup.c	/^local int suffixes(a, s)$/;"	f
support	WHERE	/^     Zip 2.31 release, all official binaries include encryption support; the$/;"	v
support	acorn/ReadMe	/^Timestamp Field support, zipfiles created by zip are identical to the$/;"	v
swapext	acorn/riscos.c	/^int swapext(char *name, char *exptr)$/;"	f	signature:(char *name, char *exptr)
swlicense	revision.h	/^ZCONST char * far swlicense[] = {$/;"	v
symbols	msdos/crc_i86.asm	/^; against redefinition of @CodeSize and @DataSize symbols, to work around a$/;"	v
sys$asctim	vms/vmsmunch.c	128;"	d	file:
sys$asctim	zip.h	369;"	d
sys$assign	vms/vmsmunch.c	129;"	d	file:
sys$assign	zip.h	370;"	d
sys$bintim	vms/cmdline.c	279;"	d	file:
sys$bintim	vms/vmsmunch.c	130;"	d	file:
sys$bintim	zip.h	371;"	d
sys$close	zip.h	372;"	d
sys$connect	zip.h	373;"	d
sys$dassgn	vms/vmsmunch.c	131;"	d	file:
sys$dassgn	zip.h	374;"	d
sys$display	zip.h	375;"	d
sys$getjpiw	zip.h	376;"	d
sys$numtim	vms/cmdline.c	282;"	d	file:
sys$open	zip.h	377;"	d
sys$parse	vms/vmsmunch.c	132;"	d	file:
sys$parse	zip.h	378;"	d
sys$qiow	vms/vmsmunch.c	133;"	d	file:
sys$qiow	zip.h	379;"	d
sys$read	zip.h	380;"	d
sys$search	vms/vmsmunch.c	134;"	d	file:
sys$search	zip.h	381;"	d
system	WHATSNEW	/^  system, adding updating, and deleting entries as needed.  This$/;"	v
systems	LICENSE	/^       systems, existing ports with new graphical interfaces, versions with$/;"	v
systems	proginfo/ziplimit.txt	/^   Note: On some systems, UnZip may support archive sizes up to 4 GByte.$/;"	v
systems	tags	/^systems	LICENSE	\/^       systems, existing ports with new graphical interfaces, versions with$\/;"	v$/;"	v
szCommentBuf	windll/windll.c	/^LPSTR szCommentBuf;$/;"	v
szExcludeList	api.c	/^char szRootDir[PATH_MAX], szExcludeList[PATH_MAX], szIncludeList[PATH_MAX], szTempDir[PATH_MAX];$/;"	v
szExcludeList	api.h	/^LPSTR szExcludeList;    \/* Pointer to exclude file list (for VB) *\/$/;"	m	struct:__anon30	access:public
szExcludeList	windll/windll.txt	/^LPSTR szExcludeList;    \/* Pointer to exclude file list (for VB) *\/$/;"	m	struct:__anon18	file:	access:public
szIncludeList	api.c	/^char szRootDir[PATH_MAX], szExcludeList[PATH_MAX], szIncludeList[PATH_MAX], szTempDir[PATH_MAX];$/;"	v
szIncludeList	api.h	/^LPSTR szIncludeList;    \/* Pointer to include file list string (for VB) *\/$/;"	m	struct:__anon30	access:public
szIncludeList	windll/windll.txt	/^LPSTR szIncludeList;    \/* Pointer to include file list string (for VB) *\/$/;"	m	struct:__anon18	file:	access:public
szName	os2/os2zip.c	/^  BYTE szName[10];            \/* ".LONGNAME" *\/$/;"	m	struct:__anon11	file:	access:public
szName	os2/os2zip.c	/^  BYTE szName[10];            \/* ".LONGNAME" *\/$/;"	m	struct:__anon12	file:	access:public
szName	os2/os2zip.c	/^  CHAR szName[1];$/;"	m	struct:__anon14	file:	access:public
szOrigDir	api.c	/^char szOrigDir[PATH_MAX];$/;"	v
szRelativ	novell/Netware.c	/^char szRelativ[512];$/;"	v
szRelativParameter	novell/Netware.c	/^char *szRelativParameter;$/;"	v
szRootDir	api.c	/^char szRootDir[PATH_MAX], szExcludeList[PATH_MAX], szIncludeList[PATH_MAX], szTempDir[PATH_MAX];$/;"	v
szRootDir	api.h	/^LPSTR szRootDir;        \/* Directory to use as base for zipping *\/$/;"	m	struct:__anon30	access:public
szRootDir	windll/Vb/readmeVB.txt	/^This dll includes a fix for the VB dll bug where Date, szRootDir, and$/;"	v
szRootDir	windll/windll.txt	/^LPSTR szRootDir;        \/* Directory to use as base for zipping *\/$/;"	m	struct:__anon18	file:	access:public
szSplitSize	api.h	/^LPSTR szSplitSize;      \/* This string contains the size that you want to$/;"	m	struct:__anon30	access:public
szSplitSize	windll/windll.txt	/^LPSTR szSplitSize;		\/* This string contains the size that you want to $/;"	m	struct:__anon18	file:	access:public
szTempDir	api.c	/^char szRootDir[PATH_MAX], szExcludeList[PATH_MAX], szIncludeList[PATH_MAX], szTempDir[PATH_MAX];$/;"	v
szTempDir	api.h	/^LPSTR szTempDir;        \/* Temporary directory used during zipping *\/$/;"	m	struct:__anon30	access:public
szTempDir	windll/windll.txt	/^LPSTR szTempDir;        \/* Temporary directory used during zipping *\/$/;"	m	struct:__anon18	file:	access:public
szValue	os2/os2zip.c	/^  BYTE szValue[CCHMAXPATH];$/;"	m	struct:__anon11	file:	access:public
tab	windll/Vb/readmeVB.txt	/^looking at properties, selecting the Version tab, and verifying the$/;"	v
table	msdos/msdos.c	/^local ptr_table table[MAX_PTR];$/;"	v
tag	vms/vms.h	/^    ush         tag;$/;"	m	struct:PK_field	access:public
tag	vms/vms.h	/^    ush tag;$/;"	m	struct:PK_header	access:public
tag	vms/vms.h	/^{   ush tag;$/;"	m	struct:EB_header	access:public
tag_bd	vms/vms.h	/^    ush tag_bd; ush len_bd;     byte bd[ATR$S_BAKDATE];$/;"	m	struct:__anon23	access:public
tag_bd	vms/vms.h	/^    ush tag_bd; ush len_bd;     byte bd[ATR$S_BAKDATE];$/;"	m	struct:__anon24	access:public
tag_cd	vms/vms.h	/^    ush tag_cd; ush len_cd;     byte cd[ATR$S_CREDATE];$/;"	m	struct:__anon23	access:public
tag_cd	vms/vms.h	/^    ush tag_cd; ush len_cd;     byte cd[ATR$S_CREDATE];$/;"	m	struct:__anon24	access:public
tag_ed	vms/vms.h	/^    ush tag_ed; ush len_ed;     byte ed[ATR$S_EXPDATE];$/;"	m	struct:__anon23	access:public
tag_ed	vms/vms.h	/^    ush tag_ed; ush len_ed;     byte ed[ATR$S_EXPDATE];$/;"	m	struct:__anon24	access:public
tag_fp	vms/vms.h	/^    ush tag_fp; ush len_fp;     byte fp[ATR$S_FPRO];$/;"	m	struct:__anon23	access:public
tag_fp	vms/vms.h	/^    ush tag_fp; ush len_fp;     byte fp[ATR$S_FPRO];$/;"	m	struct:__anon24	access:public
tag_jr	vms/vms.h	/^    ush tag_jr; ush len_jr;     byte jr[ATR$S_JOURNAL];$/;"	m	struct:__anon23	access:public
tag_jr	vms/vms.h	/^    ush tag_jr; ush len_jr;     byte jr[ATR$S_JOURNAL];$/;"	m	struct:__anon24	access:public
tag_ra	vms/vms.h	/^    ush tag_ra; ush len_ra;     byte ra[ATR$S_RECATTR];$/;"	m	struct:__anon23	access:public
tag_ra	vms/vms.h	/^    ush tag_ra; ush len_ra;     byte ra[ATR$S_RECATTR];$/;"	m	struct:__anon24	access:public
tag_rd	vms/vms.h	/^    ush tag_rd; ush len_rd;     byte rd[ATR$S_REVDATE];$/;"	m	struct:__anon23	access:public
tag_rd	vms/vms.h	/^    ush tag_rd; ush len_rd;     byte rd[ATR$S_REVDATE];$/;"	m	struct:__anon24	access:public
tag_rn	vms/vms.h	/^    ush tag_rn; ush len_rn;     ush  rn;$/;"	m	struct:__anon23	access:public
tag_rn	vms/vms.h	/^    ush tag_rn; ush len_rn;     ush  rn;$/;"	m	struct:__anon24	access:public
tag_rp	vms/vms.h	/^    ush tag_rp; ush len_rp;     byte rp[ATR$S_RPRO];$/;"	m	struct:__anon23	access:public
tag_rp	vms/vms.h	/^    ush tag_rp; ush len_rp;     byte rp[ATR$S_RPRO];$/;"	m	struct:__anon24	access:public
tag_uc	vms/vms.h	/^    ush tag_uc; ush len_uc;     byte uc[ATR$S_UCHAR];$/;"	m	struct:__anon23	access:public
tag_uc	vms/vms.h	/^    ush tag_uc; ush len_uc;     byte uc[ATR$S_UCHAR];$/;"	m	struct:__anon24	access:public
tag_ui	vms/vms.h	/^    ush tag_ui; ush len_ui;     byte ui[ATR$S_UIC];$/;"	m	struct:__anon23	access:public
tag_ui	vms/vms.h	/^    ush tag_ui; ush len_ui;     byte ui[ATR$S_UIC];$/;"	m	struct:__anon24	access:public
talln	zipsplit.c	/^int talln = 0;          \/* number of entries in talls[] *\/$/;"	v
talloc	zipsplit.c	/^local zvoid *talloc(s)$/;"	f
talls	zipsplit.c	/^zvoid *talls[TMAX];     \/* malloc'ed pointers to track *\/$/;"	v
target	bzip2/install.txt	/^  "generic" target, that is, using a command like$/;"	v
telldir	os2/os2zip.c	/^long telldir(DIR * dirp)$/;"	f	signature:(DIR * dirp)
temp	vms/cvthelp.tpu	/^Local   temp$/;"	v
tempath	globals.c	/^char *tempath = NULL;   \/* Path for temporary files *\/$/;"	v
tempdir	zip.c	/^local int tempdir = 0;  \/* 1=use temp directory (-b) *\/$/;"	v
template	zipsplit.c	/^local char template[TEMPL_SIZ]; \/* name template for output files *\/$/;"	v
tempname	fileio.c	/^char *tempname(zip)$/;"	f
tempname	vms/vms.c	/^char *tempname( char *zip)$/;"	f	signature:( char *zip)
tempzf	zipcloak.c	/^local FILE *tempzf;$/;"	v
tempzf	zipnote.c	/^local FILE *tempzf;$/;"	v
tempzip	globals.c	/^char *tempzip = NULL;         \/* name of temp file *\/$/;"	v
tempzn	globals.c	/^uzoff_t tempzn;               \/* Count of bytes written to output zip files *\/$/;"	v
term	vms/vms.c	/^    int term;$/;"	m	struct:__anon26	file:	access:public
test	zip.c	/^local int test = 0;     \/* 1=test zip file with unzip -t *\/$/;"	v
tested	proginfo/3rdparty.bug	/^   the -ex option; when tested, the files fail the CRC check, and comparison$/;"	v
testers	README	/^UnZip utility) development, join the ranks of BETA testers, add your own$/;"	v
text	proginfo/txtvsbin.txt	/^text, otherwise it is labeled as binary.  A prominent limitation of this$/;"	v
texts	proginfo/txtvsbin.txt	/^including plain old texts, system logs, source code, formatted office$/;"	v
textual	proginfo/txtvsbin.txt	/^labeled as textual, because the files that are genuinely binary tend to$/;"	v
textual	proginfo/txtvsbin.txt	/^other hand, the upper range needs to be labeled as textual,  because it$/;"	v
tfree	zipsplit.c	/^local void tfree(p)$/;"	f
tfreeall	zipsplit.c	/^local void tfreeall()$/;"	f
the	msdos/crc_i86.asm	/^; on Pentium MMX). For the 286, the penalty of "dec cx; jnz" is one clock$/;"	v
the	win32/gvmat64.asm	/^;;; We already know at this point that the first three bytes of the$/;"	v
theGlobals	macos/source/recurse.c	/^static RecurseGlobals theGlobals;$/;"	v	file:
then	INSTALL	/^     the sources.  First step, then, is to unpack Zip.  The following$/;"	v
these	proginfo/ZipPorts	/^      (a few more or less depending on how one counts), and each of these,$/;"	v
this	amiga/deflate.a	/^; for 386 by Jean-loup Gailly and Kai Uwe Rommel.  Mostly, however, this$/;"	v
this	amiga/match_68.a	/^; longest_match().  It is written for any 680x0 based computer, but at this$/;"	v
ths2iso	theos/charconv.h	/^ZCONST uch Far ths2iso[] = {$/;"	v
ths2oem	theos/charconv.h	/^ZCONST uch Far ths2oem[] = {$/;"	v
tim	zip.h	/^  ulg tim, crc;$/;"	m	struct:zlist	access:public
time	Betas_Readme.txt	/^We take suggestions, bug fixes, and patches at any time, so send them in.$/;"	v
time	amiga/deflate.a	/^;               loop code for 68020 operations, comparing bytes four at a time$/;"	v
time	amiga/filedate.c	/^time_t time(time_t *tp)$/;"	f	signature:(time_t *tp)
time	human68k/deflate.s	/^;               loop code for 68020 operations, comparing bytes four at a time$/;"	v
time2tm	macos/source/mactime.c	/^static struct tm *time2tm(const time_t *timer)$/;"	f	file:	signature:(const time_t *timer)
time_t	tailor.h	/^   typedef long time_t;$/;"	t
timecnt	timezone.h	/^    int             timecnt;$/;"	m	struct:state	access:public
timezone	os2/osdep.h	171;"	d
timezone	timezone.c	/^long timezone = 0;$/;"	v
timezone	win32/osdep.h	487;"	d
tm	msdos/msdos.c	52;"	d	file:
tm	msdos/msdos.c	56;"	d	file:
tm2time	macos/source/mactime.c	/^static time_t tm2time(struct tm *tp)$/;"	f	file:	signature:(struct tm *tp)
to	LICENSE	/^       limited to, labeling of the altered versions with the names "Info-ZIP"$/;"	v	file:
to	LICENSE	/^    3. Altered versions--including, but not limited to, ports to new operating$/;"	v
to	msdos/crc_i86.asm	/^;  But Watcom C is different and does not allow one to assume DS pointing to$/;"	v
to	proginfo/fileinfo.cms	/^     equal to 1, fread() returns either 0 or 1, indicating whether a$/;"	v
to	tags	/^to	LICENSE	\/^       limited to, labeling of the altered versions with the names "Info-ZIP"$\/;"	v	file:$/;"	v
to	win32/crc_i386.asm	/^;   Enlarged unrolling loops to "do 16 bytes per turn"; optimized access to$/;"	v
to	win32/crc_lcc.asm	/^; only the assembler syntax and metacommands have been adapted to$/;"	v
to	win32/gvmat64.asm	/^;;; Save registers that the compiler may be using, and adjust esp to$/;"	v
to	win32/lm32_lcc.asm	/^; only the assembler syntax and metacommands have been adapted to$/;"	v
to_up	tailor.h	212;"	d
to_up	tailor.h	215;"	d
too	amiga/match.a	/^; This code will run with registerized parameters too, unless SAS$/;"	v
too	qdos/match.s	/^; This code will run with registerized parameters too, unless SAS$/;"	v
total_cd_entries	globals.c	/^uzoff_t total_cd_entries = 0;     \/* total cd entries in new\/updated archive *\/$/;"	v
total_disks	globals.c	/^ulg     total_disks = 0;        \/* total disks in archive *\/$/;"	v
tpu$init_procedure	vms/cvthelp.tpu	/^tpu$init_procedure;$/;"	v
translate_eol	globals.c	/^int translate_eol = 0;  \/* Translate end-of-line LF -> CR LF *\/$/;"	v
transtime	timezone.c	/^static time_t transtime(janfirst, year, rulep, offset)$/;"	f	file:
trash	zip.h	/^  int trash;                    \/* Marker for files to delete *\/$/;"	m	struct:zlist	access:public
trash	zipfile.c	/^int trash()$/;"	f
treat	amiga/crc_68.a	/^; If using this source on a non-Amiga 680x0 system, note that we treat$/;"	v
treat	human68k/crc_68.s	/^; If using this source on a non-Amiga 680x0 system, note that we treat$/;"	v
tree_desc	trees.c	/^typedef struct tree_desc {$/;"	s	file:
tree_desc	trees.c	/^} tree_desc;$/;"	t	typeref:struct:tree_desc	file:
tree_desc::dyn_tree	trees.c	/^    ct_data near *dyn_tree;      \/* the dynamic tree *\/$/;"	m	struct:tree_desc	file:	access:public
tree_desc::elems	trees.c	/^    int     elems;               \/* max number of elements in the tree *\/$/;"	m	struct:tree_desc	file:	access:public
tree_desc::extra_base	trees.c	/^    int     extra_base;          \/* base index for extra_bits *\/$/;"	m	struct:tree_desc	file:	access:public
tree_desc::extra_bits	trees.c	/^    int     near *extra_bits;    \/* extra bits for each code or NULL *\/$/;"	m	struct:tree_desc	file:	access:public
tree_desc::max_code	trees.c	/^    int     max_code;            \/* largest code with non zero frequency *\/$/;"	m	struct:tree_desc	file:	access:public
tree_desc::max_length	trees.c	/^    int     max_length;          \/* max bit length for the codes *\/$/;"	m	struct:tree_desc	file:	access:public
tree_desc::static_tree	trees.c	/^    ct_data near *static_tree;   \/* corresponding static tree or NULL *\/$/;"	m	struct:tree_desc	file:	access:public
tt_abbrind	timezone.h	/^    int             tt_abbrind; \/* abbreviation list index *\/$/;"	m	struct:ttinfo	access:public
tt_getch	ttyio.c	/^int tt_getch()$/;"	f
tt_gmtoff	timezone.h	/^    long            tt_gmtoff;  \/* UTC offset in seconds *\/$/;"	m	struct:ttinfo	access:public
tt_isdst	timezone.h	/^    int             tt_isdst;   \/* used to set tm_isdst *\/$/;"	m	struct:ttinfo	access:public
ttinfo	timezone.h	/^struct ttinfo {$/;"	s
ttinfo::tt_abbrind	timezone.h	/^    int             tt_abbrind; \/* abbreviation list index *\/$/;"	m	struct:ttinfo	access:public
ttinfo::tt_gmtoff	timezone.h	/^    long            tt_gmtoff;  \/* UTC offset in seconds *\/$/;"	m	struct:ttinfo	access:public
ttinfo::tt_isdst	timezone.h	/^    int             tt_isdst;   \/* used to set tm_isdst *\/$/;"	m	struct:ttinfo	access:public
ttis	timezone.h	/^    struct ttinfo   ttis[TZ_MAX_TYPES];$/;"	m	struct:state	typeref:struct:state::ttinfo	access:public
two	amiga/deflate.a	/^;               source, and must be a power of two <= 32768.  As elsewhere,$/;"	v
two	human68k/deflate.s	/^;               source, and must be a power of two <= 32768.  As elsewhere,$/;"	v
type	proginfo/fileinfo.cms	/^     files is type =record. This opens a file for record I\/O.$/;"	v
typecnt	timezone.h	/^    int             typecnt;$/;"	m	struct:state	access:public
types	timezone.h	/^    unsigned char   types[TZ_MAX_TIMES];$/;"	m	struct:state	access:public
typically	bzip2/install.txt	/^file, "bzlib.h", and the object library, typically "libbz2.a", except$/;"	v
tzname	timezone.c	/^char *tzname[2];$/;"	v
tzname	win32/osdep.h	480;"	d
tzname	win32/osdep.h	493;"	d
tzset	os2/osdep.h	172;"	d
tzset	timezone.c	/^void tzset()$/;"	f
tzset	win32/osdep.h	463;"	d
tzset	win32/osdep.h	472;"	d
tzset	win32/osdep.h	476;"	d
tzset	win32/osdep.h	484;"	d
ubValue	zipfile.c	/^  unsigned char ubValue;  \/* byte to append *\/$/;"	v
uc	vms/vms.h	/^    ush tag_uc; ush len_uc;     byte uc[ATR$S_UCHAR];$/;"	m	struct:__anon23	access:public
uc	vms/vms.h	/^    ush tag_uc; ush len_uc;     byte uc[ATR$S_UCHAR];$/;"	m	struct:__anon24	access:public
uch	zip.h	/^typedef unsigned char uch;      \/* unsigned 8-bit value *\/$/;"	t
ucs4_char_from_utf8	fileio.c	/^long ucs4_char_from_utf8(utf8)$/;"	f
ucs4_string_to_utf8	fileio.c	/^local int ucs4_string_to_utf8(ucs4, utf8buf, buflen)$/;"	f
ui	vms/vms.h	/^    ush tag_ui; ush len_ui;     byte ui[ATR$S_UIC];$/;"	m	struct:__anon23	access:public
ui	vms/vms.h	/^    ush tag_ui; ush len_ui;     byte ui[ATR$S_UIC];$/;"	m	struct:__anon24	access:public
ulg	zip.h	/^typedef unsigned long ulg;      \/* unsigned 32-bit value *\/$/;"	t
ulist_items	tandem/tandem.c	515;"	d	file:
umask	amiga/stat.c	/^int umask(void)  { return 0; }$/;"	f	signature:(void)
unaligned	amiga/match.a	/^; The major change in this code consists of removing all unaligned$/;"	v
unaligned	qdos/match.s	/^; The major change in this code consists of removing all unaligned$/;"	v
unalloc	os2/os2zip.c	618;"	d	file:
unalloc	os2/os2zip.c	621;"	d	file:
uname	zip.h	/^  char *uname;                  \/* UTF-8 name *\/$/;"	m	struct:flist	access:public
uname	zip.h	/^  char *uname;                  \/* UTF-8 version of iname *\/$/;"	m	struct:zlist	access:public
unget_char	macos/source/getenv.c	/^void unget_char(int ch, FILE *file)$/;"	f	signature:(int ch, FILE *file)
unicode_escape_all	globals.c	/^int unicode_escape_all = 0; \/* 1=escape all non-ASCII characters in paths *\/$/;"	v
unicode_mismatch	globals.c	/^int unicode_mismatch = 1; \/* unicode mismatch is 0=error, 1=warn, 2=ignore, 3=no *\/$/;"	v
unit_fstat_packet	aosvs/aosvs.c	/^     P_FSTAT_UNIT   unit_fstat_packet;      \/* unit (device) fstat packet *\/$/;"	m	union:zvsfstat_stru	file:	access:public
unix2dostime	fileio.c	/^ulg unix2dostime(t)$/;"	f
unlink	acorn/riscos.c	/^int unlink(f)$/;"	f
unlink	cmsmvs/cmsmvs.h	73;"	d
unlink	vms/osdep.h	134;"	d
unset	amiga/deflate.a	/^        rts     ; match_init consists only of rts if CPUTEST unset$/;"	v
unset	human68k/deflate.s	/^        rts     ; match_init consists only of rts if CPUTEST unset$/;"	v
unused	win32/gvmat64.asm	/^; MatchLen : unused$/;"	v
unzip	vms/zip_msg.msg	/^TEST    \/FATAL        <Zip file invalid, could not spawn unzip, or wrong unzip>$/;"	v
unzip_path	zip.c	/^local char *unzip_path = NULL; \/* where to find unzip *\/$/;"	v
up	amiga/deflate.a	/^; Here is longest_match(), the function that the rest of this was built up$/;"	v
up	human68k/deflate.s	/^; Here is longest_match(), the function that the rest of this was built up$/;"	v
updateTicks	macos/source/macos.c	/^long    updateTicks;$/;"	v
update_keys	crypt.h	110;"	d
updating	WHATSNEW	/^  system, adding updating, and deleting entries as needed.  This$/;"	v
updating	zip30f.ann	/^  files on the file system, adding, updating, and deleting entries as needed,$/;"	v
upper	util.c	/^uch upper[256], lower[256];$/;"	v
us	amiga/deflate.a	/^;   DYN_ALLOC  should be defined here if it is defined for C source; tells us$/;"	v
us	human68k/deflate.s	/^;   DYN_ALLOC  should be defined here if it is defined for C source; tells us$/;"	v
use	amiga/deflate.a	/^; ================== Here are the register vars we use, and deflate() itself:$/;"	v
use	amiga/deflate.a	/^; constants we use, many of them adjustable:$/;"	v
use	human68k/deflate.s	/^; ================== Here are the register vars we use, and deflate() itself:$/;"	v
use	human68k/deflate.s	/^; constants we use, many of them adjustable:$/;"	v
use_descriptors	globals.c	/^int use_descriptors = 0;      \/* 1=use data descriptors 12\/29\/04 *\/$/;"	v
use_longname_ea	globals.c	/^   int use_longname_ea = 0;  \/* 1=use the .LONGNAME EA as the file's name *\/$/;"	v
use_privileges	globals.c	/^  int use_privileges = 0;     \/* 1=use security privilege overrides *\/$/;"	v
use_wide_to_mb_default	globals.c	/^  int use_wide_to_mb_default = 0;$/;"	v
used	acorn/ReadMe	/^Timestamp Extra Field will be used, so the zipfiles will still be fully$/;"	v
used	msdos/crc_i86.asm	/^; Do NOT assemble this source if external crc32 routine from zlib gets used,$/;"	v
used	win32/crc_i386.asm	/^; Do NOT assemble this source if external crc32 routine from zlib gets used,$/;"	v
user	tandem/tandem.h	/^  unsigned user    : 8;$/;"	m	struct:nsk_owner	access:public
user_context	vms/vms_im.c	/^typedef struct user_context$/;"	s	file:
user_context::fab	vms/vms_im.c	/^    struct FAB *fab;$/;"	m	struct:user_context	typeref:struct:user_context::FAB	file:	access:public
user_context::nam	vms/vms_im.c	/^    struct NAM_STRUCT *nam;$/;"	m	struct:user_context	typeref:struct:user_context::NAM_STRUCT	file:	access:public
user_context::rab	vms/vms_im.c	/^    struct RAB *rab;$/;"	m	struct:user_context	typeref:struct:user_context::RAB	file:	access:public
user_context::rest	vms/vms_im.c	/^    uzoff_t rest;$/;"	m	struct:user_context	file:	access:public
user_context::sig	vms/vms_im.c	/^    ulg sig;$/;"	m	struct:user_context	file:	access:public
user_context::size	vms/vms_im.c	/^    uzoff_t size;$/;"	m	struct:user_context	file:	access:public
user_context::status	vms/vms_im.c	/^    int status;$/;"	m	struct:user_context	file:	access:public
uses	amiga/deflate.a	/^;   SMALL_MEM  define this if it is defined in the C source; otherwise it uses$/;"	v
uses	human68k/deflate.s	/^;   SMALL_MEM  define this if it is defined in the C source; otherwise it uses$/;"	v
ush	zip.h	/^typedef unsigned short ush;     \/* unsigned 16-bit value *\/$/;"	t
using	win32/gvmat64.asm	/^;;; Save registers that the compiler may be using, and adjust esp to$/;"	v
using_utf8	globals.c	/^   int using_utf8 = 0;       \/* 1 if current character set UTF-8 *\/$/;"	v
usize	zip.h	/^  uzoff_t usize;                \/* usize from initial scan *\/$/;"	m	struct:flist	access:public
utf8_char_bytes	fileio.c	/^local int utf8_char_bytes(utf8)$/;"	f
utf8_force	globals.c	/^ int utf8_force = 0;    \/* 1=force storing UTF-8 as standard per AppNote bit 11 *\/$/;"	v
utf8_from_ucs4_char	fileio.c	/^local int utf8_from_ucs4_char(utf8buf, ch)$/;"	f
utf8_to_escape_string	fileio.c	/^char *utf8_to_escape_string(utf8_string)$/;"	f
utf8_to_local_string	fileio.c	/^char *utf8_to_local_string(utf8_string)$/;"	f
utf8_to_ucs4_string	fileio.c	/^local int utf8_to_ucs4_string(utf8, ucs4buf, buflen)$/;"	f
utf8_to_wchar_string	win32/win32zip.c	/^wchar_t *utf8_to_wchar_string(utf8_string)$/;"	f
utf8_to_wide_string	fileio.c	/^zwchar *utf8_to_wide_string(utf8_string)$/;"	f
utime	amiga/amigazip.c	14;"	d	file:
utime	cmsmvs/cmsmvs.h	75;"	d
utime	tandem/tandem.c	/^int utime(file, time)$/;"	f
utime	win32/osdep.h	466;"	d
uxnamebuf	aosvs/aosvs.c	/^static char     uxnamebuf[FNMAX];$/;"	v	file:
uxtime2acornftime	acorn/acornzip.c	/^local int uxtime2acornftime(unsigned *pexadr, unsigned *pldadr, time_t ut)$/;"	f	signature:(unsigned *pexadr, unsigned *pldadr, time_t ut)
uzoff_t	tailor.h	/^    typedef unsigned long long uzoff_t;  \/* unsigned zoff_t (12\/29\/04 EG) *\/$/;"	t
uzoff_t	tailor.h	/^    typedef unsigned long uzoff_t;$/;"	t
uzoff_t	unix/osdep.h	/^  typedef unsigned long long uzoff_t;$/;"	t
uzoff_t	unix/osdep.h	/^  typedef unsigned long uzoff_t;$/;"	t
uzoff_t	vms/osdep.h	/^   typedef unsigned long long uzoff_t;$/;"	t
uzoff_t	vms/osdep.h	/^   typedef unsigned long uzoff_t;$/;"	t
uzoff_t	win32/osdep.h	/^    typedef unsigned __int64    uzoff_t;$/;"	t
uzoff_t	win32/osdep.h	/^    typedef unsigned long long  uzoff_t;$/;"	t
uzoff_t	win32/osdep.h	/^  typedef unsigned long uzoff_t;$/;"	t
vRefNum	macos/source/recurse.c	/^    short                   vRefNum;$/;"	m	struct:RecurseGlobals	file:	access:public
val	qdos/crc68.s	/^.globl  _crc32          ; (ulg val, uch *buf, extent bufsize)$/;"	v
valloc	zipup.c	51;"	d	file:
value	amiga/crc_68.a	/^; Return an updated 32 bit CRC value, given the old value and a block of data.$/;"	v
value	human68k/crc_68.s	/^; Return an updated 32 bit CRC value, given the old value and a block of data.$/;"	v
value	macos/source/getenv.c	/^    char *value;$/;"	m	struct:_EnviromentPair	file:	access:public
value	vms/vms.c	/^   int value;$/;"	m	struct:__anon27	file:	access:public
value	vms/vms.h	/^    byte        value[1];$/;"	m	struct:PK_field	access:public
value	win32/crc_i386.asm	/^;   eax  : crc value "c"$/;"	v
value_type	zip.h	/^  int  value_type;          \/* from above *\/$/;"	m	struct:option_struct	access:public
values	proginfo/txtvsbin.txt	/^presence or the absence of some byte values, the algorithm produces$/;"	v
variant_union	vms/vms.h	57;"	d
variant_union	vms/vms.h	69;"	d
vbOKOnly	windll/Vb/VBZipBas.bas	/^                "or on the command path?", vbOKOnly, "VB Zip"$/;"	v
vbn	vms/vms_pk.c	/^    long                vbn;$/;"	m	struct:__anon22	file:	access:public
vem	zip.h	/^  ush vem, ver, flg, how;$/;"	m	struct:zlist	access:public
ver	zip.h	/^  ush vem, ver, flg, how;$/;"	m	struct:zlist	access:public
verbose	globals.c	/^int verbose = 0;        \/* 1=report oddities in zip file structure *\/$/;"	v
verbose_command	vms/cmdline.c	/^static int verbose_command = 0;$/;"	v	file:
verified	tandem/tandem.h	/^  unsigned verified    : 1;$/;"	m	struct:nsk_file_flags	access:public
versinfolines	revision.h	/^ZCONST char * far versinfolines[] = {$/;"	v
version_id	amiga/amiga.c	/^const char version_id[] = "\\0$VER: Zip 2.3 ("$/;"	v
version_info	zip.c	/^local void version_info()$/;"	f
version_info	zipcloak.c	/^local void version_info()$/;"	f
version_info	zipnote.c	/^local void version_info()$/;"	f
version_info	zipsplit.c	/^local void version_info()$/;"	f
version_local	acorn/acornzip.c	/^void version_local()$/;"	f
version_local	amiga/amigazip.c	/^void version_local()$/;"	f
version_local	aosvs/aosvs.c	/^void version_local()$/;"	f
version_local	atari/atari.c	/^void version_local()$/;"	f
version_local	atheos/atheos.c	/^void version_local()$/;"	f
version_local	beos/beos.c	/^void version_local()$/;"	f
version_local	cmsmvs/cmsmvs.c	/^void version_local()$/;"	f
version_local	human68k/human68k.c	/^void version_local()$/;"	f
version_local	macos/source/macos.c	/^void version_local()$/;"	f
version_local	msdos/msdos.c	/^void version_local()$/;"	f
version_local	novell/Netware.c	/^void version_local()$/;"	f
version_local	os2/os2zip.c	/^void version_local()$/;"	f
version_local	qdos/qfileio.c	/^void version_local()$/;"	f
version_local	tandem/tanzip.c	/^void version_local()$/;"	f
version_local	theos/theos.c	/^void version_local()$/;"	f
version_local	tops20/tops20.c	/^void version_local()$/;"	f
version_local	unix/unix.c	/^void version_local()$/;"	f
version_local	vms/vms.c	/^void version_local()$/;"	f
version_local	win32/win32.c	/^void version_local()$/;"	f
versions	vms/NOTES.TXT	/^both ODS2 and ODS5 disks, and old and new Zip and UnZip versions, it's$/;"	v
violated	msdos/crc_i86.asm	/^; restrictions are not violated:$/;"	v
vlist_bytes	tandem/tanzip.c	69;"	d	file:
vms_case_2	globals.c	/^   int vms_case_2 = 0;  \/* ODS2 file name case in VMS.  -1: down. *\/$/;"	v
vms_case_5	globals.c	/^   int vms_case_5 = 0;  \/* ODS5 file name case in VMS.  +1: preserve. *\/$/;"	v
vms_close	vms/vms_im.c	/^int vms_close(rab)$/;"	f
vms_close	vms/vms_pk.c	/^int vms_close(ctx)$/;"	f
vms_error	vms/vms_im.c	/^int vms_error(rab)$/;"	f
vms_error	vms/vms_pk.c	/^int vms_error(ctx)$/;"	f
vms_exit	vms/vms.c	/^void vms_exit(e)$/;"	f
vms_file_version	vms/vms.c	/^char *vms_file_version( char *s)$/;"	f	signature:( char *s)
vms_get_attributes	vms/vms_pk.c	/^int vms_get_attributes(ctx, z, z_utim)$/;"	f
vms_native	globals.c	/^   int vms_native = 0;  \/* 1=store in VMS format *\/$/;"	v
vms_open	vms/vms_im.c	/^struct RAB *vms_open(name)$/;"	f
vms_open	vms/vms_pk.c	/^ioctx_t *vms_open(file)$/;"	f
vms_read	vms/vms_im.c	/^size_t vms_read(rab, buf, size)$/;"	f
vms_read	vms/vms_pk.c	/^size_t vms_read( ctx, buf, size)$/;"	f
vms_rewind	vms/vms_im.c	/^int vms_rewind(rab)$/;"	f
vms_rewind	vms/vms_pk.c	/^int vms_rewind(ctx)$/;"	f
vms_stat	vms/vms.c	/^int vms_stat( char *file, stat_t *s)$/;"	f	signature:( char *file, stat_t *s)
vms_wild	vms/vmszip.c	/^local void vms_wild( char *p, zDIR *d)$/;"	f	signature:( char *p, zDIR *d)
vms_zip_cmdline	vms/cmdline.c	/^vms_zip_cmdline (int *argc_p, char ***argv_p)$/;"	f	signature:(int *argc_p, char ***argv_p)
vmsver	globals.c	/^   int vmsver = 0;      \/* 1=append VMS version number to file names *\/$/;"	v
void	tailor.h	244;"	d
volume_label	globals.c	/^int volume_label = 0;         \/* add volume label *\/$/;"	v
vsfstatbuf	aosvs/aosvs.c	/^static P_FSTAT  vsfstatbuf;$/;"	v	file:
vsnamebuf	aosvs/aosvs.c	/^static char     vsnamebuf[$MXPL];$/;"	v	file:
wchar_t	msdos/msdos.c	51;"	d	file:
wchar_t	msdos/msdos.c	55;"	d	file:
wchar_to_local_string	fileio.c	/^char *wchar_to_local_string(wstring)$/;"	f
wchar_to_utf8_string	win32/win32zip.c	/^char *wchar_to_utf8_string(wstring)$/;"	f
wchar_to_wide_string	fileio.c	/^zwchar *wchar_to_wide_string(wchar_string)$/;"	f
we	win32/gvmat64.asm	/^;;; If the length of the match is not longer than the best match we$/;"	v
we	win32/gvmat64.asm	/^;;; Point edi to the string under scrutiny, and esi to the string we$/;"	v
wfjfn	tops20/tops20.c	/^   int  wfjfn;$/;"	m	struct:__anon3	file:	access:public
wfname	tops20/tops20.c	/^wfname(jfn)$/;"	f	file:
wfnext	tops20/tops20.c	/^wfnext(jfn)$/;"	f	file:
wfopen	tops20/tops20.c	/^wfopen(name)$/;"	f	file:
whim	amiga/crc_68.a	/^; int can be short or long at whim, but size_t is long.$/;"	v
whim	human68k/crc_68.s	/^; int can be short or long at whim, but size_t is long.$/;"	v
wide_char_to_escape_string	fileio.c	/^char *wide_char_to_escape_string(wide_char)$/;"	f
wide_to_escape_string	fileio.c	/^char *wide_to_escape_string(wide_string)$/;"	f
wide_to_local_string	fileio.c	/^char *wide_to_local_string(wide_string)$/;"	f
wide_to_local_string	win32/win32.c	/^char *wide_to_local_string(wide_string)$/;"	f
wide_to_mb_default_string	zip.h	919;"	d
wide_to_utf8_string	fileio.c	/^char *wide_to_utf8_string(wide_string)$/;"	f
wild	acorn/acornzip.c	/^int wild(p)$/;"	f
wild	amiga/amigazip.c	/^int wild(p) char *p;$/;"	f
wild	atari/atari.c	/^int wild( char *p )$/;"	f	signature:( char *p )
wild	human68k/human68k.c	/^int wild(char* w)$/;"	f	signature:(char* w)
wild	macos/source/macos.c	/^int wild(char *Pathpat)$/;"	f	signature:(char *Pathpat)
wild	msdos/msdos.c	/^int wild(w)$/;"	f
wild	novell/Netware.c	/^int wild(w)$/;"	f
wild	os2/os2.c	/^int wild(w)$/;"	f
wild	qdos/qdos.c	/^int wild(char *p)$/;"	f	signature:(char *p)
wild	vms/vmszip.c	/^int wild( char *p)$/;"	f	signature:( char *p)
wild	win32/win32zip.c	/^int wild(w)$/;"	f
wild2	atari/atari.c	/^int wild2(w)$/;"	f
wild_match_all	msdos/msdos.c	/^local ZCONST char wild_match_all[] = "*.*";$/;"	v
wild_match_all	win32/win32zip.c	/^local ZCONST char wild_match_all[] = "*.*";$/;"	v
wild_recurse	acorn/acornzip.c	/^local int wild_recurse(whole, wildtail) char *whole; char *wildtail;$/;"	f
wild_recurse	amiga/amigazip.c	/^local int wild_recurse(whole, wildtail) char *whole; char *wildtail;$/;"	f
wild_recurse	msdos/msdos.c	/^local int wild_recurse(whole, wildtail)$/;"	f
wild_recurse	win32/win32zip.c	/^local int wild_recurse(whole, wildtail)$/;"	f
wild_recursew	win32/win32zip.c	/^local int wild_recursew(whole, wildtail)$/;"	f
wild_stop_at_dir	globals.c	/^   int wild_stop_at_dir = 0; \/* default wildcards do include \/ in matches *\/$/;"	v
wild_stop_at_dir	globals.c	/^   int wild_stop_at_dir = 1; \/* default wildcards do not include \/ in matches *\/$/;"	v
wild_version_part	vms/vmszip.c	/^static char wild_version_part[10]="\\0";$/;"	v	file:
will	win32/gvmat64.asm	/^;;; majority of its time in this loop, and majority of that time will$/;"	v
win32	CHANGES	/^ 3. Fix NTSD_EAS link time failures with win32 (Paul)$/;"	f
windll	api.h	/^    _zip_version_type windll;$/;"	m	struct:_ZpVer	access:public
windll	windll/windll.txt	/^    _zip_version_type windll;$/;"	m	struct:_ZpVer	file:	access:public
window	cmsmvs/README.CMS	/^      Example, from a DOS or OS\/2 window, type this:$/;"	v
window	deflate.c	/^  uch    window[2L*WSIZE];$/;"	v
window	deflate.c	/^  uch far * near window = NULL;$/;"	v
window	msdos/match.asm	/^        cmp     ax,word ptr es:window[bx+si-1] ; check match at best_len-1$/;"	v
window	msdos/match.asm	/^        cmp     cx,word ptr es:window[si]      ; check min_match_length match$/;"	v
window	os2/match32.asm	/^        cmp     ax,word ptr window[ebx+esi-1]   ; check match at best_len-1$/;"	v
window	os2/match32.asm	/^        cmp     cx,word ptr window[esi]         ; check min_match_length match$/;"	v
window	zipup.c	/^    local uch *window = NULL;   \/* Used to read all input file at once *\/$/;"	v
window_off	msdos/match.asm	/^        add     si,2+window_off         ; si = match$/;"	v
window_off	os2/match32.asm	/^        add     esi,window_off          ; esi = match$/;"	v
window_size	deflate.c	/^ulg window_size;$/;"	v
window_size	tops20/osdep.h	19;"	d
window_size	zipup.c	/^    local ulg window_size;      \/* size of said window *\/$/;"	v
with	amiga/match_68.a	/^;   ATSIGN     define entry symbols in @foo form as well as _foo, with$/;"	v
with	os2/match32.asm	/^; argument for longest_match in the EAX register, not on the stack, with$/;"	v
with	zip.txt	/^       can have a value (option argument) specified by preceeding  it  with  =$/;"	v
with$	tags	/^systems	LICENSE	\/^       systems, existing ports with new graphical interfaces, versions with$\/;"	v$/;"	v
wmask	win32/gvmat64.asm	/^;;; It is then shifted into the high word, to make room for the wmask$/;"	v
wmask	win32/gvmat64.asm	/^;;; edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)$/;"	v
wmask	win32/gvmat64.asm	/^;;; uInt wmask = s->w_mask;$/;"	v
word	win32/gvmat64.asm	/^;;; It is then shifted into the high word, to make room for the wmask$/;"	v
words	proginfo/ZipPorts	/^      In other words, try to fit into the local style of programming--no$/;"	v
words	proginfo/txtvsbin.txt	/^mis-identified by this scheme; in other words, the rate of false$/;"	v
work	bzip2/install.txt	/^standard bzip2 object library will work, though any errors that bzip2$/;"	v
workdir	vms/build_zip.com	/^$ workdir = f$environment( "default")$/;"	v
write	tandem/tandem.h	/^  unsigned write     : 3;$/;"	m	struct:nsk_file_attrs_def	access:public
write_int64_to_mem	zipfile.c	/^local void write_int64_to_mem(l64Value,pPtr)$/;"	f
write_string_to_mem	zipfile.c	/^local void write_string_to_mem(strValue, pPtr)$/;"	f
write_ulong_to_mem	zipfile.c	/^local void write_ulong_to_mem(uValue, pPtr)$/;"	f
written	win32/gvmat64.asm	/^;        from Brian Raiter, written 1998$/;"	v
wuname	zip.h	/^  char *wuname;                 \/* Converted back ouname for Win32 *\/$/;"	m	struct:zlist	access:public
x	macos/README.TXT	/^VMS, MSDOS, OS\/2, Windows 9x, Windows NT, Atari, Macintosh,$/;"	v
x	vms/cvthelp.tpu	/^        ,x$/;"	v
x	vms/cvthelp.tpu	/^        exitif x = 0;$/;"	v
x	vms/cvthelp.tpu	/^        position (x);$/;"	v
x	vms/cvthelp.tpu	/^        x := search(target, forward);$/;"	v
x409	win32/zip.rc	/^        VALUE "Translation", 0x409, 1200$/;"	v
x409	windll/windll.rc	/^        VALUE "Translation", 0x409, 1200$/;"	v
x_decc_init	vms/vms.c	/^void (*const x_decc_init)() = decc_init;$/;"	v
xab$b_bln	vms/vms.h	/^    unsigned char xab$b_bln;$/;"	m	struct:XAB	access:public
xab$b_cod	vms/vms.h	/^    unsigned char xab$b_cod;$/;"	m	struct:XAB	access:public
xab$l_nxt	vms/vms.h	/^    char *xab$l_nxt;$/;"	m	struct:XAB	access:public
xabdef$$_fill_1	vms/vms.h	/^    short int xabdef$$_fill_1;$/;"	m	struct:XAB	access:public
xabptr	vms/vms_im.c	/^typedef struct XAB *xabptr;$/;"	t	typeref:struct:XAB	file:
xample	WHATSNEW	/^  for example, and this approach creates archives that should be$/;"	v
xample	bzip2/install.txt	/^the bzip2 code and algorithms or bzip2 licensing, for example, should be$/;"	v
xample	zip.txt	/^       Be aware that console windows on Win32 and Unix, for example, sometimes$/;"	v
xample	zip.txt	/^       between splits to allow changing removable media, for example, but read$/;"	v
xenix	INSTALL	/^     att6300, coherent, cray_v3, minix, sco_x286, xenix, zilog.$/;"	v
xit	msdos/msdos.c	/^void xit(void)$/;"	f	signature:(void)
xx	cmsmvs/zip.exec	/^  Do xx=1 to Words(loadlib)$/;"	v
xx	cmsmvs/zipcloak.exec	/^  Do xx=1 to Words(loadlib)$/;"	v
xx	cmsmvs/zipnote.exec	/^  Do xx=1 to Words(loadlib)$/;"	v
xx	cmsmvs/zipsplit.exec	/^  Do xx=1 to Words(loadlib)$/;"	v
y	globals.c	/^FILE *y = NULL;               \/* output file now global so can change in splits *\/$/;"	v
ydays	amiga/filedate.c	/^static const unsigned short ydays[] =$/;"	v	file:
ydays	api.h	172;"	d
year_lengths	timezone.c	/^static ZCONST int   year_lengths[2] = {$/;"	v	file:
yr_days	timezone.c	/^static ZCONST int    yr_days[2][MONSPERYEAR+1] = {$/;"	v	file:
z	zipfile.c	/^  char *z;                  \/* zip file comment if m != 0 *\/$/;"	v
zDIR	vms/vmszip.c	/^} zDIR;$/;"	t	typeref:struct:zdirent	file:
zDIRSCAN	win32/win32zip.c	/^} zDIRSCAN;$/;"	t	typeref:struct:zdirscan	file:
zDIRSCANW	win32/win32zip.c	/^} zDIRSCANW;$/;"	t	typeref:struct:zdirscanw	file:
zLib	win32/gvmat64.asm	/^; Be carrefull to adapt zlib1222add below to your version of zLib$/;"	v
z_stat	tailor.h	/^  typedef struct stat z_stat;$/;"	t	typeref:struct:stat
z_stat	unix/osdep.h	/^  typedef struct stat z_stat;$/;"	t	typeref:struct:stat
z_stat	vms/osdep.h	/^typedef struct stat z_stat;$/;"	t	typeref:struct:stat
z_stat	win32/osdep.h	/^     typedef struct stat z_stat;$/;"	t	typeref:struct:stat
z_stat	win32/osdep.h	/^    typedef struct _stati64 z_stat;$/;"	t	typeref:struct:_stati64
z_stat	win32/osdep.h	/^  typedef struct stat z_stat;$/;"	t	typeref:struct:stat
z_uint4	tailor.h	/^           typedef unsigned short   z_uint4;$/;"	t
z_uint4	tailor.h	/^         typedef unsigned long    z_uint4;$/;"	t
z_uint4	tailor.h	/^       typedef unsigned int     z_uint4;$/;"	t
z_uint4	tailor.h	/^  typedef ulg                z_uint4;$/;"	t
zbcmp	zipfile.c	/^local int zbcmp(n, z)$/;"	f
zcalloc	msdos/msdos.c	/^zvoid far *zcalloc (unsigned items, unsigned size)$/;"	f	signature:(unsigned items, unsigned size)
zcalloc	os2/os2.c	/^zvoid far *zcalloc (unsigned items, unsigned size)$/;"	f	signature:(unsigned items, unsigned size)
zcalloc	tailor.h	882;"	d
zcfree	msdos/msdos.c	/^zvoid zcfree (zvoid far *ptr)$/;"	f	signature:(zvoid far *ptr)
zcfree	os2/os2.c	/^zvoid zcfree (zvoid far *ptr)$/;"	f	signature:(zvoid far *ptr)
zcfree	tailor.h	884;"	d
zclose	acorn/zipup.h	14;"	d
zclose	amiga/zipup.h	20;"	d
zclose	atari/zipup.h	17;"	d
zclose	atheos/zipup.h	20;"	d
zclose	beos/zipup.h	17;"	d
zclose	cmsmvs/zipup.h	16;"	d
zclose	human68k/zipup.h	14;"	d
zclose	macos/zipup.h	21;"	d
zclose	msdos/zipup.h	14;"	d
zclose	novell/zipup.h	14;"	d
zclose	os2/zipup.h	14;"	d
zclose	qdos/zipup.h	17;"	d
zclose	tandem/tanzip.c	/^  int zclose (fnum)$/;"	f
zclose	theos/zipup.h	17;"	d
zclose	tops20/zipup.h	16;"	d
zclose	unix/zipup.h	22;"	d
zclose	vms/zipup.h	19;"	d
zclose	win32/zipup.h	46;"	d
zcomlen	globals.c	/^ush zcomlen;                      \/* Length of zip file comment *\/$/;"	v
zcomment	globals.c	/^char *zcomment = NULL;            \/* Zip file comment (not zero-terminated) *\/$/;"	v
zcount	globals.c	/^extent zcount;                    \/* Number of files in zip file *\/$/;"	v
zcr_dummy	crypt.c	/^int zcr_dummy;$/;"	v
zdecode	crypt.h	130;"	d
zdecode	crypt.h	164;"	d
zdirent	vms/vmszip.c	/^typedef struct zdirent {$/;"	s	file:
zdirent::d_name	vms/vmszip.c	/^  char d_name[ NAM_MAXRSS+ 1];$/;"	m	struct:zdirent	file:	access:public
zdirent::d_qualwildname	vms/vmszip.c	/^  char d_qualwildname[ NAM_MAXRSS+ 1];$/;"	m	struct:zdirent	file:	access:public
zdirent::d_wild	vms/vmszip.c	/^  int d_wild;                \/* flag for wildcard vs. non-wild *\/$/;"	m	struct:zdirent	file:	access:public
zdirent::fab	vms/vmszip.c	/^  struct FAB fab;$/;"	m	struct:zdirent	typeref:struct:zdirent::FAB	file:	access:public
zdirent::nam	vms/vmszip.c	/^  struct NAM_STRUCT nam;$/;"	m	struct:zdirent	typeref:struct:zdirent::NAM_STRUCT	file:	access:public
zdirscan	win32/win32zip.c	/^typedef struct zdirscan {$/;"	s	file:
zdirscan::d_fd	win32/win32zip.c	/^  WIN32_FIND_DATA d_fd;$/;"	m	struct:zdirscan	file:	access:public
zdirscan::d_first	win32/win32zip.c	/^  int    d_first;$/;"	m	struct:zdirscan	file:	access:public
zdirscan::d_hFindFile	win32/win32zip.c	/^  HANDLE d_hFindFile;$/;"	m	struct:zdirscan	file:	access:public
zdirscanw	win32/win32zip.c	/^typedef struct zdirscanw {$/;"	s	file:
zdirscanw::d_fdw	win32/win32zip.c	/^  WIN32_FIND_DATAW d_fdw;$/;"	m	struct:zdirscanw	file:	access:public
zdirscanw::d_first	win32/win32zip.c	/^  int    d_first;$/;"	m	struct:zdirscanw	file:	access:public
zdirscanw::d_hFindFile	win32/win32zip.c	/^  HANDLE d_hFindFile;$/;"	m	struct:zdirscanw	file:	access:public
zencode	crypt.h	127;"	d
zencode	crypt.h	163;"	d
zero	acorn/riscos.h	/^  int           zero;$/;"	m	struct:__anon10	access:public
zero	amiga/deflate.a	/^        and.l   #$0000FFFF,Cur_Match    ; upper half must be zero!$/;"	v
zero	human68k/deflate.s	/^        and.l   #$0000FFFF,Cur_Match    ; upper half must be zero!$/;"	v
zerr	acorn/zipup.h	15;"	d
zerr	amiga/zipup.h	21;"	d
zerr	atari/zipup.h	18;"	d
zerr	atheos/zipup.h	21;"	d
zerr	beos/zipup.h	18;"	d
zerr	cmsmvs/zipup.h	17;"	d
zerr	human68k/zipup.h	15;"	d
zerr	macos/zipup.h	22;"	d
zerr	msdos/zipup.h	15;"	d
zerr	novell/zipup.h	15;"	d
zerr	os2/zipup.h	15;"	d
zerr	qdos/zipup.h	18;"	d
zerr	tandem/zipup.h	24;"	d
zerr	theos/zipup.h	18;"	d
zerr	tops20/zipup.h	17;"	d
zerr	unix/zipup.h	23;"	d
zerr	vms/zipup.h	20;"	d
zerr	win32/zipup.h	47;"	d
zexit	tandem/tandem.c	/^void zexit(status)$/;"	f
zextrafld	aosvs/aosvs.c	/^typedef struct zextrafld$/;"	s	file:
zextrafld::aclbuf	aosvs/aosvs.c	/^     char           aclbuf[$MXACL];     \/* raw ACL, or link-resolution name *\/$/;"	m	struct:zextrafld	file:	access:public
zextrafld::extra_data_size	aosvs/aosvs.c	/^     char           extra_data_size[2]; \/* size of rest, in Intel little-endian order *\/$/;"	m	struct:zextrafld	file:	access:public
zextrafld::extra_header_id	aosvs/aosvs.c	/^     char           extra_header_id[2]; \/* set to VS - in theory, an int *\/$/;"	m	struct:zextrafld	file:	access:public
zextrafld::extra_rev	aosvs/aosvs.c	/^     unsigned char  extra_rev;          \/* set to 10 for rev 1.0 *\/$/;"	m	struct:zextrafld	file:	access:public
zextrafld::extra_sentinel	aosvs/aosvs.c	/^     char           extra_sentinel[4];  \/* set to FCI w\/ trailing null *\/$/;"	m	struct:zextrafld	file:	access:public
zextrafld::fstat_packet	aosvs/aosvs.c	/^     ZVSFSTAT_STRU  fstat_packet;       \/* the fstat packet *\/$/;"	m	struct:zextrafld	file:	access:public
zfdopen	tailor.h	557;"	d
zfdopen	tailor.h	577;"	d
zfdopen	tailor.h	607;"	d
zfdopen	tailor.h	627;"	d
zfdopen	tailor.h	654;"	d
zfdopen	tailor.h	681;"	d
zfdopen	tailor.h	713;"	d
zfiles	globals.c	/^struct zlist far *zfiles = NULL;  \/* Pointer to list of files in zip file *\/$/;"	v	typeref:struct:far
zfopen	tailor.h	556;"	d
zfopen	tailor.h	576;"	d
zfopen	tailor.h	606;"	d
zfopen	tailor.h	626;"	d
zfopen	tailor.h	653;"	d
zfopen	tailor.h	680;"	d
zfopen	tailor.h	712;"	d
zfseeko	tailor.h	542;"	d
zfseeko	tailor.h	549;"	d
zfseeko	tailor.h	570;"	d
zfseeko	tailor.h	620;"	d
zfseeko	tailor.h	710;"	d
zfseeko	win32/win32i64.c	/^int zfseeko(stream, offset, origin)$/;"	f
zfstat	tailor.h	537;"	d
zfstat	tailor.h	566;"	d
zfstat	tailor.h	594;"	d
zfstat	tailor.h	616;"	d
zfstat	tailor.h	641;"	d
zfstat	tailor.h	668;"	d
zfstat	tailor.h	708;"	d
zftello	tailor.h	545;"	d
zftello	tailor.h	552;"	d
zftello	tailor.h	573;"	d
zftello	tailor.h	623;"	d
zftello	tailor.h	711;"	d
zftello	win32/win32i64.c	/^zoff_t zftello(stream)$/;"	f
zfwrite	crypt.c	/^unsigned zfwrite(buf, item_size, nb)$/;"	f
zfwrite	crypt.h	166;"	d
zgetch	tandem/tandem.c	/^int zgetch(void)$/;"	f	signature:(void)
zgetline	zipnote.c	/^local char *zgetline(buf, size)$/;"	f
zgetpid	tandem/tanzip.c	/^  unsigned zgetpid (void)$/;"	f	signature:(void)
zip	acorn/makefile	/^clean:  ;remove zip; remove zipcloak;$/;"	v
zip	api.h	/^    _zip_version_type zip;$/;"	m	struct:_ZpVer	access:public
zip	unix/README.OS390	/^If GNU make is not available, the existing makefile can create zip, but will$/;"	v
zip	windll/windll.txt	/^    _zip_version_type zip;$/;"	m	struct:_ZpVer	file:	access:public
zip64_archive	globals.c	/^  int zip64_archive = 0;      \/* if 1 then at least 1 entry needs zip64 *\/$/;"	v
zip64_entry	globals.c	/^  int zip64_entry = 0;        \/* current entry needs Zip64 *\/$/;"	v
zip64_eocd_disk	globals.c	/^ulg     zip64_eocd_disk = 0;      \/* disk with Zip64 End Of Central Directory Record *\/$/;"	v
zip64_eocd_offset	globals.c	/^uzoff_t zip64_eocd_offset = 0;    \/* offset for Zip64 EOCD Record *\/$/;"	v
zip_attributes	globals.c	/^int zip_attributes = 0;$/;"	v
zip_clitable	vms/cmdline.c	/^globalref void *zip_clitable;$/;"	v
zip_clitable	vms/cmdline.c	267;"	d	file:
zip_fuzofft	util.c	/^char *zip_fuzofft( val, pre, post)$/;"	f
zip_fzofft	util.c	/^char *zip_fzofft( val, pre, post)$/;"	f
zip_to_stdout	globals.c	/^int zip_to_stdout = 0;        \/* output zipfile to stdout 12\/30\/04 *\/$/;"	v
zipbare	crypt.c	/^int zipbare(z, passwd)$/;"	f
zipbeg	globals.c	/^uzoff_t zipbeg;               \/* Starting offset of zip structures *\/$/;"	v
zipcloak	README	/^Utilities.  At this point zipsplit, zipcloak, and zipnote should work with$/;"	v
zipcloak	README	/^and install zip, zipsplit, zipcloak, and zipnote and please read the manual$/;"	v
zipcloak	acorn/makefile	/^clean:  ;remove zip; remove zipcloak;$/;"	v
zipcloak	crypt.c	/^int zipcloak(z, passwd)$/;"	f
zipcopy	zipfile.c	/^int zipcopy(z)$/;"	f
zipdll_error_return	zip.c	/^jmp_buf zipdll_error_return;$/;"	v
zipedit	zip.c	/^local int zipedit = 0;  \/* 1=edit zip comment and all file comments *\/$/;"	v
ziperr	vms/cmdline.c	/^void ziperr( int c, char *h)    \/* Error message display function. *\/$/;"	f	signature:( int c, char *h)
ziperr	zip.c	/^void ziperr(c, h)$/;"	f
ziperr	zipcloak.c	/^void ziperr(c, h)$/;"	f
ziperr	zipcloak.c	/^void ziperr(code, msg)$/;"	f
ziperr	zipnote.c	/^void ziperr(c, h)$/;"	f
ziperr	zipnote.c	61;"	d	file:
ziperr	zipsplit.c	/^void ziperr(c, h)$/;"	f
ziperr	zipsplit.c	58;"	d	file:
ziperrors	ziperr.h	/^} ziperrors[ZE_MAXERR + 1] = {$/;"	v	typeref:struct:__anon1
zipfile	acorn/ReadMe	/^When adding files to a zipfile; to maintain FileCore compliance, all$/;"	v
zipfile	globals.c	/^char *zipfile;          \/* New or existing zip archive (zip file) *\/$/;"	v
zipfile_exists	globals.c	/^int zipfile_exists = 0;           \/* 1 if zipfile exists *\/$/;"	v
zipmessage	zip.c	/^void zipmessage(a, b)$/;"	f
zipmessage	zipcloak.c	/^void zipmessage(a, b)$/;"	f
zipmessage	zipnote.c	/^void zipmessage(a, b)$/;"	f
zipmessage	zipsplit.c	/^void zipmessage(a, b)$/;"	f
zipmessage_nl	zip.c	/^void zipmessage_nl(a, nl)$/;"	f
zipmessage_nl	zipcloak.c	/^void zipmessage_nl(a, nl)$/;"	f
zipmessage_nl	zipnote.c	/^void zipmessage_nl(a, nl)$/;"	f
zipmessage_nl	zipsplit.c	/^void zipmessage_nl(a, nl)$/;"	f
zipnote	acorn/makefile	/^        remove zipsplit; remove zipnote;$/;"	v
zipoddities	zipfile.c	/^local void zipoddities(z)$/;"	f
zipsmade	zipsplit.c	/^local int zipsmade = 0;         \/* number of zip files made *\/$/;"	v
zipsplit	README	/^and install zip, zipsplit, zipcloak, and zipnote and please read the manual$/;"	v
zipsplit	acorn/makefile	/^        remove zipsplit; remove zipnote;$/;"	v
zipstatb	fileio.c	/^local z_stat zipstatb;             \/* now use z_stat globally - 7\/24\/04 EG *\/$/;"	v
zipstatbw	fileio.c	/^ local zw_stat zipstatbw;$/;"	v
zipstate	fileio.c	/^int zipstate;$/;"	v
zipstate	fileio.c	/^local int zipstate = -1;$/;"	v
zipstdout	zip.c	/^local void zipstdout()$/;"	f
ziptyp	vms/vms.c	/^char *ziptyp( char *s)$/;"	f	signature:( char *s)
ziptyp	zipfile.c	/^char *ziptyp(s)$/;"	f
zipup	zipup.c	/^int zipup(z)$/;"	f
zipwarn	zip.c	/^void zipwarn(a, b)$/;"	f
zipwarn	zipcloak.c	/^void zipwarn(msg1, msg2)$/;"	f
zipwarn	zipnote.c	/^void zipwarn(a, b)$/;"	f
zipwarn	zipnote.c	62;"	d	file:
zipwarn	zipsplit.c	/^void zipwarn(a, b)$/;"	f
zipwarn	zipsplit.c	59;"	d	file:
zl_deflate_free	zipup.c	/^void zl_deflate_free()$/;"	f
zl_deflate_init	zipup.c	/^local int zl_deflate_init(pack_level)$/;"	f
zlib_version	api.h	/^    char zlib_version[10];  \/* e.g., "0.95" or NULL *\/$/;"	m	struct:_ZpVer	access:public
zlib_version	windll/windll.txt	/^    char *zlib_version;     \/* e.g., "0.95" or NULL *\/$/;"	m	struct:_ZpVer	file:	access:public
zlinkres	aosvs/aosvs.c	/^local char        zlinkres[$MXPL];    \/* buf for link resolution contents *\/$/;"	v
zlist	zip.h	/^struct zlist {$/;"	s
zlist::att	zip.h	/^  ush att, lflg;                \/* offset of lflg must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
zlist::atx	zip.h	/^  ulg atx;$/;"	m	struct:zlist	access:public
zlist::cext	zip.h	/^  ush nam, ext, cext, com;      \/* offset of ext must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
zlist::cextra	zip.h	/^  char *cextra;                 \/* Extra in central (set only if cext != 0) *\/$/;"	m	struct:zlist	access:public
zlist::com	zip.h	/^  ush nam, ext, cext, com;      \/* offset of ext must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
zlist::comment	zip.h	/^  char *comment;                \/* Comment (set only if com != 0) *\/$/;"	m	struct:zlist	access:public
zlist::crc	zip.h	/^  ulg tim, crc;$/;"	m	struct:zlist	access:public
zlist::current	zip.h	/^  int current;                  \/* Marker for files that are current to what is on OS (filesync) *\/$/;"	m	struct:zlist	access:public
zlist::dosflag	zip.h	/^  int dosflag;                  \/* Set to force MSDOS file attributes *\/$/;"	m	struct:zlist	access:public
zlist::dsk	zip.h	/^  ulg dsk;                      \/* disk number was ush but now ulg *\/$/;"	m	struct:zlist	access:public
zlist::ext	zip.h	/^  ush nam, ext, cext, com;      \/* offset of ext must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
zlist::extra	zip.h	/^  char *extra;                  \/* Extra field (set only if ext != 0) *\/$/;"	m	struct:zlist	access:public
zlist::flg	zip.h	/^  ush vem, ver, flg, how;$/;"	m	struct:zlist	access:public
zlist::how	zip.h	/^  ush vem, ver, flg, how;$/;"	m	struct:zlist	access:public
zlist::iname	zip.h	/^  char *iname;                  \/* Internal file name after cleanup (stored in archive) *\/$/;"	m	struct:zlist	access:public
zlist::inamew	zip.h	/^  wchar_t *inamew;              \/* Windows wide character version of iname *\/$/;"	m	struct:zlist	access:public
zlist::len	zip.h	/^  uzoff_t siz, len;             \/* zip64 support 08\/29\/2003 R.Nausedat *\/$/;"	m	struct:zlist	access:public
zlist::lflg	zip.h	/^  ush att, lflg;                \/* offset of lflg must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
zlist::mark	zip.h	/^  int mark;                     \/* Marker for files to operate on *\/$/;"	m	struct:zlist	access:public
zlist::nam	zip.h	/^  ush nam, ext, cext, com;      \/* offset of ext must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
zlist::name	zip.h	/^  char *name;                   \/* File name in zip file *\/$/;"	m	struct:zlist	access:public
zlist::namew	zip.h	/^  wchar_t *namew;               \/* Windows wide character version of name *\/$/;"	m	struct:zlist	access:public
zlist::nxt	zip.h	/^  struct zlist far *nxt;        \/* Pointer to next header in list *\/$/;"	m	struct:zlist	typeref:struct:zlist::far	access:public
zlist::off	zip.h	/^  uzoff_t off;$/;"	m	struct:zlist	access:public
zlist::oname	zip.h	/^  char *oname;                  \/* Display version of name used in messages *\/$/;"	m	struct:zlist	access:public
zlist::ouname	zip.h	/^  char *ouname;                 \/* Display version of zuname *\/$/;"	m	struct:zlist	access:public
zlist::siz	zip.h	/^  uzoff_t siz, len;             \/* zip64 support 08\/29\/2003 R.Nausedat *\/$/;"	m	struct:zlist	access:public
zlist::tim	zip.h	/^  ulg tim, crc;$/;"	m	struct:zlist	access:public
zlist::trash	zip.h	/^  int trash;                    \/* Marker for files to delete *\/$/;"	m	struct:zlist	access:public
zlist::uname	zip.h	/^  char *uname;                  \/* UTF-8 version of iname *\/$/;"	m	struct:zlist	access:public
zlist::vem	zip.h	/^  ush vem, ver, flg, how;$/;"	m	struct:zlist	access:public
zlist::ver	zip.h	/^  ush vem, ver, flg, how;$/;"	m	struct:zlist	access:public
zlist::wuname	zip.h	/^  char *wuname;                 \/* Converted back ouname for Win32 *\/$/;"	m	struct:zlist	access:public
zlist::zname	zip.h	/^  char *zname;                  \/* External version of internal name *\/$/;"	m	struct:zlist	access:public
zlist::znamew	zip.h	/^  wchar_t *znamew;              \/* Windows wide character version of zname *\/$/;"	m	struct:zlist	access:public
zlist::zuname	zip.h	/^  char *zuname;                 \/* Escaped Unicode zname from uname *\/$/;"	m	struct:zlist	access:public
zlstat	tailor.h	538;"	d
zlstat	tailor.h	567;"	d
zlstat	tailor.h	595;"	d
zlstat	tailor.h	617;"	d
zlstat	tailor.h	642;"	d
zlstat	tailor.h	669;"	d
zlstat	tailor.h	709;"	d
zmbschr	util.c	/^unsigned char *zmbschr(str, c)$/;"	f
zmbsrchr	util.c	/^unsigned char *zmbsrchr(str, c)$/;"	f
zname	zip.h	/^  char *zname;                  \/* External version of internal name *\/$/;"	m	struct:flist	access:public
zname	zip.h	/^  char *zname;                  \/* External version of internal name *\/$/;"	m	struct:plist	access:public
zname	zip.h	/^  char *zname;                  \/* External version of internal name *\/$/;"	m	struct:zlist	access:public
znamebuf	aosvs/aosvs.c	/^local char        znamebuf[$MXPL];    \/* buf for AOS\/VS filename *\/$/;"	v
znamew	zip.h	/^  wchar_t *znamew;              \/* Windows wide character version of zname *\/$/;"	m	struct:flist	access:public
znamew	zip.h	/^  wchar_t *znamew;              \/* Windows wide character version of zname *\/$/;"	m	struct:zlist	access:public
znsk_attr	tandem/tanzip.c	/^  nsk_file_attrs *znsk_attr = (nsk_file_attrs *)$/;"	v
znsk_ov	tandem/tanzip.c	/^  nsk_stat_ov *znsk_ov = (nsk_stat_ov *)&znsk_stat.st_reserved[0];$/;"	v
znsk_stat	tandem/tanzip.c	/^  struct stat znsk_stat;$/;"	v	typeref:struct:stat
zoff_t	tailor.h	/^    typedef long zoff_t;$/;"	t
zoff_t	tailor.h	/^    typedef off_t zoff_t;$/;"	t
zoff_t	unix/osdep.h	/^  typedef long zoff_t;$/;"	t
zoff_t	unix/osdep.h	/^  typedef off_t zoff_t;$/;"	t
zoff_t	vms/osdep.h	/^   typedef long zoff_t;$/;"	t
zoff_t	vms/osdep.h	/^   typedef off_t zoff_t;$/;"	t
zoff_t	win32/osdep.h	/^    typedef __int64             zoff_t;$/;"	t
zoff_t	win32/osdep.h	/^    typedef long long           zoff_t;$/;"	t
zoff_t	win32/osdep.h	/^  typedef long zoff_t;$/;"	t
zopen	acorn/zipup.h	12;"	d
zopen	amiga/zipup.h	18;"	d
zopen	atari/zipup.h	15;"	d
zopen	atheos/zipup.h	18;"	d
zopen	beos/zipup.h	15;"	d
zopen	cmsmvs/zipup.h	14;"	d
zopen	human68k/zipup.h	12;"	d
zopen	macos/zipup.h	19;"	d
zopen	msdos/zipup.h	12;"	d
zopen	novell/zipup.h	12;"	d
zopen	os2/zipup.h	12;"	d
zopen	qdos/zipup.h	15;"	d
zopen	tandem/tanzip.c	/^  int zopen (filename, opt)$/;"	f
zopen	theos/zipup.h	15;"	d
zopen	tops20/zipup.h	14;"	d
zopen	unix/zipup.h	20;"	d
zopen	vms/zipup.h	17;"	d
zopen	win32/zipup.h	31;"	d
zopen	win32/zipup.h	33;"	d
zopen	win32/zipup.h	35;"	d
zopendir	vms/vmszip.c	/^local zDIR *zopendir( ZCONST char *n)$/;"	f	signature:( ZCONST char *n)
zp_tz_is_valid	globals.c	/^int zp_tz_is_valid;     \/* signals "timezone info is available" *\/$/;"	v
zputc	tandem/tandem.c	/^int zputc(ch, fptr)$/;"	f
zqcmp	zipfile.c	/^local int zqcmp(a, b)$/;"	f
zread	acorn/zipup.h	13;"	d
zread	amiga/zipup.h	19;"	d
zread	atari/zipup.h	16;"	d
zread	atheos/zipup.h	19;"	d
zread	beos/zipup.h	16;"	d
zread	cmsmvs/zipup.h	15;"	d
zread	human68k/zipup.h	13;"	d
zread	macos/zipup.h	20;"	d
zread	msdos/zipup.h	13;"	d
zread	novell/zipup.h	13;"	d
zread	os2/zipup.h	13;"	d
zread	qdos/zipup.h	16;"	d
zread	tandem/tanzip.c	/^  unsigned zread (fnum, buf, len)$/;"	f
zread	theos/zipup.h	16;"	d
zread	tops20/zipup.h	15;"	d
zread	unix/zipup.h	21;"	d
zread	vms/zipup.h	18;"	d
zread	win32/zipup.h	45;"	d
zread_ovlen	tandem/tanzip.c	/^  long zread_ovlen = 0;                \/* size of remaining left overs    *\/$/;"	v
zread_ovptr	tandem/tanzip.c	/^  char *zread_ovptr = NULL;            \/* pointer to left overs           *\/$/;"	v
zreadbuf	tandem/tanzip.c	/^  char zreadbuf[MAX_LARGE_READ];       \/* Buffer as large as biggest read *\/$/;"	v
zreadptr	tandem/tanzip.c	/^  char *zreadptr = (char *) zreadbuf;  \/* pointer to start of buffer      *\/$/;"	v
zsearch	zipfile.c	/^struct zlist far *zsearch(n)$/;"	f
zsort	globals.c	/^struct zlist far **zsort;         \/* List of files sorted by name *\/$/;"	v	typeref:struct:far
zstat	tailor.h	536;"	d
zstat	tailor.h	565;"	d
zstat	tailor.h	588;"	d
zstat	tailor.h	615;"	d
zstat	tailor.h	635;"	d
zstat	tailor.h	662;"	d
zstat	tailor.h	707;"	d
zstat_zipwin32	win32/win32.c	/^ int zstat_zipwin32(const char *path, struct stat *buf)$/;"	f	signature:(const char *path, struct stat *buf)
zstat_zipwin32w	win32/win32.c	/^int zstat_zipwin32w(const wchar_t *pathw, zw_stat *buf)$/;"	f	signature:(const wchar_t *pathw, zw_stat *buf)
zstdin	acorn/zipup.h	16;"	d
zstdin	amiga/zipup.h	22;"	d
zstdin	atari/zipup.h	19;"	d
zstdin	atheos/zipup.h	22;"	d
zstdin	beos/zipup.h	19;"	d
zstdin	cmsmvs/zipup.h	18;"	d
zstdin	human68k/zipup.h	16;"	d
zstdin	macos/zipup.h	23;"	d
zstdin	msdos/zipup.h	16;"	d
zstdin	novell/zipup.h	16;"	d
zstdin	os2/zipup.h	16;"	d
zstdin	qdos/zipup.h	19;"	d
zstdin	tandem/zipup.h	25;"	d
zstdin	theos/zipup.h	19;"	d
zstdin	tops20/zipup.h	18;"	d
zstdin	unix/zipup.h	24;"	d
zstdin	vms/zipup.h	21;"	d
zstdin	win32/zipup.h	48;"	d
zstrm	zipup.c	/^  local z_stream zstrm;         \/* zlib's data interface structure *\/$/;"	v
ztimbuf	tailor.h	/^typedef struct ztimbuf {$/;"	s
ztimbuf	tailor.h	/^} ztimbuf;$/;"	t	typeref:struct:ztimbuf
ztimbuf::actime	tailor.h	/^    time_t actime;              \/* new access time *\/$/;"	m	struct:ztimbuf	access:public
ztimbuf::modtime	tailor.h	/^    time_t modtime;             \/* new modification time *\/$/;"	m	struct:ztimbuf	access:public
zubcmp	zipfile.c	/^local int zubcmp(n, z)$/;"	f
zuebcmp	zipfile.c	/^local int zuebcmp(n, z)$/;"	f
zuname	zip.h	/^  char *zuname;                 \/* Escaped Unicode zname from uname *\/$/;"	m	struct:zlist	access:public
zuqcmp	zipfile.c	/^local int zuqcmp(a, b)$/;"	f
zusort	globals.c	/^  struct zlist far **zusort;      \/* List of files sorted by zuname *\/$/;"	v	typeref:struct:far
zvoid	tailor.h	/^   typedef char zvoid;$/;"	t
zvoid	tailor.h	/^   typedef void zvoid;$/;"	t
zvoid	tailor.h	248;"	d
zvs_lstat	aosvs/aosvs.c	/^int zvs_lstat(char *path, struct stat *buf)$/;"	f	signature:(char *path, struct stat *buf)
zvs_readlink	aosvs/aosvs.c	/^int zvs_readlink(char *path, char *buf, int nbytes)$/;"	f	signature:(char *path, char *buf, int nbytes)
zvsfstat_stru	aosvs/aosvs.c	/^typedef union zvsfstat_stru$/;"	u	file:
zvsfstat_stru::dir_fstat_packet	aosvs/aosvs.c	/^     P_FSTAT_DIR    dir_fstat_packet;       \/* DIR\/CPD fstat packet *\/$/;"	m	union:zvsfstat_stru	file:	access:public
zvsfstat_stru::ipc_fstat_packet	aosvs/aosvs.c	/^     P_FSTAT_IPC    ipc_fstat_packet;       \/* IPC file fstat packet *\/$/;"	m	union:zvsfstat_stru	file:	access:public
zvsfstat_stru::norm_fstat_packet	aosvs/aosvs.c	/^     P_FSTAT        norm_fstat_packet;      \/* normal fstat packet *\/$/;"	m	union:zvsfstat_stru	file:	access:public
zvsfstat_stru::unit_fstat_packet	aosvs/aosvs.c	/^     P_FSTAT_UNIT   unit_fstat_packet;      \/* unit (device) fstat packet *\/$/;"	m	union:zvsfstat_stru	file:	access:public
zw_stat	tailor.h	592;"	d
zw_stat	tailor.h	639;"	d
zw_stat	tailor.h	666;"	d
zw_stat	tailor.h	717;"	d
zwchar	zip.h	/^  typedef unsigned long zwchar;$/;"	t
zwchar_to_wchar_t_default_char	zip.h	916;"	d
zwfstat	tailor.h	590;"	d
zwfstat	tailor.h	637;"	d
zwfstat	tailor.h	664;"	d
zwfstat	tailor.h	715;"	d
zwopen	win32/zipup.h	39;"	d
zwopen	win32/zipup.h	41;"	d
zwstat	tailor.h	591;"	d
zwstat	tailor.h	638;"	d
zwstat	tailor.h	665;"	d
zwstat	tailor.h	716;"	d
zzextrafld	aosvs/aosvs.c	/^local ZEXTRAFLD   zzextrafld;         \/* buffer for extra field containing$/;"	v
