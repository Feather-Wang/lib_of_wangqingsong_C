!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.7	//
$	tags	/^to	LICENSE	\/^       limited to, labeling of the altered versions with the names "Info-ZIP"$\/;"	v	file:$/;"	v
$	zipnote	/^/;"	v
$0	match.S	/^        adc     $0,%eax             \/* eax = carry ? len+1 : len *\/$/;"	v
$1	match.S	/^        subb    $1,%cl              \/* set carry if cl == 0 (cannot use DEC) *\/$/;"	v
$15	crc_i386.S	/^                andl    $15, %ecx         \/* ecx = len % 16   *\/$/;"	v
$2	crc_i386.S	/^                shrl    $2,%ecx           \/* ecx = len \/ 4    *\/$/;"	v
$2	match.S	/^        shr     $2,%ebp                \/* chain_length >>= 2 *\/$/;"	v
$3	crc_i386.S	/^                andl    $3,%ecx          \/* ecx = len % 4 *\/$/;"	v
$4	crc_i386.S	/^                shrl    $4, %ecx             \/* ecx = len \/ 16   *\/$/;"	v
ADD	zip.c	35;"	d	file:
ADJUST_TM	timezone.c	724;"	d	file:
ALIGNMENT	crc_i386.S	65;"	d	file:
ALIGNMENT	match.S	47;"	d	file:
ARCHIVE	zip.c	38;"	d	file:
ARG_FILE_ERR	fileio.c	2582;"	d	file:
ASCII	zip.h	214;"	d
ASMV	tailor.h	169;"	d
ASM_CRC	tailor.h	165;"	d
ATH_BEO_UNX	ttyio.h	19;"	d
Amiga	INSTALL	/^     wide range of systems:  Unix, VMS, MSDOS, OS\/2, NT, Amiga, Atari,$/;"	v
April	README.CR	/^lic domain.  Zcrypt was originally written in Europe and, as of April 2000,$/;"	v
Assert	zip.h	565;"	d
Assert	zip.h	581;"	d
Atari	INSTALL	/^     wide range of systems:  Unix, VMS, MSDOS, OS\/2, NT, Amiga, Atari,$/;"	v
BEST	zip.h	328;"	d
BFWRITE_CENTRALHEADER	zip.h	983;"	d
BFWRITE_DATA	zip.h	981;"	d
BFWRITE_HEADER	zip.h	984;"	d
BFWRITE_LOCALHEADER	zip.h	982;"	d
BIG_MEM	tailor.h	500;"	d
BINARY	zip.h	213;"	d
BL_CODES	trees.c	154;"	d	file:
BZIP2	zip.h	331;"	d
BeOS	INSTALL	/^     BeOS, VM\/CMS, ...  You will need Unzip 5.0p1 or later (under any$/;"	v
Buf_size	trees.c	364;"	d	file:
C	INSTALL	/^     Supported compilers are Microsoft Visual C++, Borland C++, Watcom C\/C++,$/;"	v
C	INSTALL	/^     for Microsoft, Borland C++ and Turbo C, Watcom C\/C++ and the various$/;"	v
CBSZ	tailor.h	449;"	d
CBSZ	tailor.h	454;"	d
CBSZ	tailor.h	459;"	d
CC	unix/configure	/^CC=${1-cc}$/;"	v
CENATT	zipfile.c	85;"	d	file:
CENATX	zipfile.c	86;"	d	file:
CENCOM	zipfile.c	83;"	d	file:
CENCRC	zipfile.c	78;"	d	file:
CENDAT	zipfile.c	77;"	d	file:
CENDSK	zipfile.c	84;"	d	file:
CENEXT	zipfile.c	82;"	d	file:
CENFLG	zipfile.c	74;"	d	file:
CENHEAD	zip.h	141;"	d
CENHOW	zipfile.c	75;"	d	file:
CENLEN	zipfile.c	80;"	d	file:
CENNAM	zipfile.c	81;"	d	file:
CENOFF	zipfile.c	87;"	d	file:
CENSIG	zipfile.c	48;"	d	file:
CENSIZ	zipfile.c	79;"	d	file:
CENTIM	zipfile.c	76;"	d	file:
CENVEM	zipfile.c	72;"	d	file:
CENVER	zipfile.c	73;"	d	file:
CFLAGS	unix/configure	/^        CFLAGS="${CFLAGS} -DBZIP2_SUPPORT"$/;"	v
CFLAGS	unix/configure	/^      CFLAGS="${CFLAGS} -I${IZ_BZIP2} -DBZIP2_SUPPORT"$/;"	v
CFLAGS	unix/configure	/^    CFLAGS="${CFLAGS} -DASMV"$/;"	v
CFLAGS	unix/configure	/^    CFLAGS="${CFLAGS} -I${IZ_BZIP2} -DBZIP2_SUPPORT"$/;"	v
CFLAGS	unix/configure	/^    CFLAGS="${CFLAGS} -LARGE -Mel2 -DMEDIUM_MEM -DWSIZE=16384 -DNO_VOID"$/;"	v
CFLAGS	unix/configure	/^    CFLAGS="${CFLAGS} -posix"$/;"	v
CFLAGS	unix/configure	/^  CFLAGS="${CFLAGS} ${CFLAGS_OPT}"$/;"	v
CFLAGS_BZ	unix/configure	/^      CFLAGS_BZ="${CFLAGS_BZ} -DBZ_NO_STDIO"$/;"	v
CFLAGS_OPT	unix/configure	/^        CFLAGS_OPT="$CFLAGS_OPT_TRY"$/;"	v
CFLAGS_OPT	unix/configure	/^        CFLAGS_OPT='-O3'$/;"	v
CFLAGS_OPT	unix/configure	/^    CFLAGS_OPT='-O3'$/;"	v
CFLAGS_OPT	unix/configure	/^  CFLAGS_OPT='-xO3'$/;"	v
CFLAGS_OPT_TRY	unix/configure	/^      CFLAGS_OPT_TRY="+O3 +Onolimit"$/;"	v
CLEN	tailor.h	348;"	d
CLEN	tailor.h	358;"	d
CMS	INSTALL	/^     BeOS, VM\/CMS, ...  You will need Unzip 5.0p1 or later (under any$/;"	v
COMPILER_NAME	unix/unix.c	516;"	d	file:
COMPILE_DATE	unix/unix.c	522;"	d	file:
CR	zip.h	265;"	d
CRC32	crc32.h	27;"	d
CRC32UPD	crc32.h	26;"	d
CRCVAL_INITIAL	zip.h	288;"	d
CRC_32_TAB	crc32.h	24;"	d
CRC_TABLE_ONLY	zip.h	96;"	d
CRC_TBLS	crc32.c	28;"	d	file:
CRYPT	crypt.h	39;"	d
CRY_CRC_TAB	crypt.c	78;"	d	file:
CR_BETA_VER	crypt.h	43;"	d
CR_MAJORVER	crypt.h	41;"	d
CR_MINORVER	crypt.h	42;"	d
CR_RELEASE	crypt.h	45;"	d
CR_VERSION_DATE	crypt.h	44;"	d
CTRLZ	zip.h	266;"	d
Code	trees.c	231;"	d	file:
D	deflate.o	/^ELF/;"	v
DAYSPERLYEAR	timezone.c	65;"	d	file:
DAYSPERNYEAR	timezone.c	64;"	d	file:
DAYSPERWEEK	timezone.c	63;"	d	file:
DAY_OF_YEAR	timezone.h	31;"	d
DEFCPYRT	zip.c	18;"	d	file:
DEFCPYRT	zipcloak.c	25;"	d	file:
DEFCPYRT	zipnote.c	20;"	d	file:
DEFCPYRT	zipsplit.c	19;"	d	file:
DEFLATE	zip.h	330;"	d
DEFSIZ	zipsplit.c	23;"	d	file:
DELETE	zip.c	33;"	d	file:
DIRSEP_CHR	util.c	26;"	d	file:
DIST_BUFSIZE	trees.c	183;"	d	file:
DLL	INSTALL	/^  Windows DLL (WIN32):$/;"	f
DO1	crc32.c	121;"	d	file:
DO2	crc32.c	122;"	d	file:
DO4	crc32.c	123;"	d	file:
DO8	crc32.c	124;"	d	file:
DOSTIME_2038_01_18	zip.h	295;"	d
DOSTIME_MINIMUM	zip.h	294;"	d
DW_MAJORVER	revision.h	27;"	d
DW_MINORVER	revision.h	28;"	d
DW_PATCHLEVEL	revision.h	29;"	d
DYN_ALLOC	tailor.h	504;"	d
DYN_TREES	trees.c	169;"	d	file:
D_CODES	trees.c	151;"	d	file:
Dad	trees.c	232;"	d	file:
DisplayNumString	util.c	/^int DisplayNumString(file, i)$/;"	f
DisplayRunningStats	zip.c	/^local int DisplayRunningStats()$/;"	f
Do_CRC	crc_i386.S	120;"	d	file:
Do_CRC_4lword	crc_i386.S	186;"	d	file:
Do_CRC_byte	crc_i386.S	131;"	d	file:
Do_CRC_byteof	crc_i386.S	136;"	d	file:
Do_CRC_lword	crc_i386.S	183;"	d	file:
EB_C_UT_SIZE	unix/unix.c	457;"	d	file:
EB_DEFLAT_EXTRA	zip.h	240;"	d
EB_HEADSIZE	zip.h	236;"	d
EB_ID	zip.h	237;"	d
EB_LEN	zip.h	238;"	d
EB_L_UT_SIZE	unix/unix.c	456;"	d	file:
EB_MEMCMPR_HSIZ	zip.h	239;"	d
EB_UT_FLAGS	zip.h	251;"	d
EB_UT_FL_ATIME	zip.h	254;"	d
EB_UT_FL_CTIME	zip.h	255;"	d
EB_UT_FL_MTIME	zip.h	253;"	d
EB_UT_LEN	zip.h	256;"	d
EB_UT_MINLEN	zip.h	250;"	d
EB_UT_TIME1	zip.h	252;"	d
EB_UX2_GID	zip.h	260;"	d
EB_UX2_MINLEN	zip.h	258;"	d
EB_UX2_UID	zip.h	259;"	d
EB_UX2_VALID	zip.h	261;"	d
EB_UX_ATIME	zip.h	243;"	d
EB_UX_FULLSIZE	zip.h	246;"	d
EB_UX_GID	zip.h	248;"	d
EB_UX_MINLEN	zip.h	242;"	d
EB_UX_MTIME	zip.h	244;"	d
EB_UX_UID	zip.h	247;"	d
EC64LOC	zip.h	143;"	d
EC64REC	zip.h	144;"	d
EF_ACL	zip.h	224;"	d
EF_AOSVS	zip.h	229;"	d
EF_ATHEOS	zip.h	227;"	d
EF_BEOS	zip.h	226;"	d
EF_C_UNIX_SIZE	unix/unix.c	463;"	d	file:
EF_IZUNIX	zip.h	220;"	d
EF_IZUNIX2	zip.h	221;"	d
EF_L_UNIX_SIZE	unix/unix.c	462;"	d	file:
EF_MVS	zip.h	219;"	d
EF_NTSD	zip.h	225;"	d
EF_OS2EA	zip.h	223;"	d
EF_QDOS	zip.h	228;"	d
EF_SIZE_MAX	zip.h	235;"	d
EF_SPARK	zip.h	230;"	d
EF_TANDEM	zip.h	232;"	d
EF_THEOS	zip.h	231;"	d
EF_TIME	zip.h	222;"	d
EF_VMCMS	zip.h	218;"	d
ENDBEG	zipfile.c	91;"	d	file:
ENDCOM	zipfile.c	96;"	d	file:
ENDDSK	zipfile.c	90;"	d	file:
ENDHEAD	zip.h	142;"	d
ENDOFF	zipfile.c	95;"	d	file:
ENDSIG	zipfile.c	49;"	d	file:
ENDSIZ	zipfile.c	94;"	d	file:
ENDSUB	zipfile.c	92;"	d	file:
ENDTOT	zipfile.c	93;"	d	file:
END_BLOCK	trees.c	145;"	d	file:
EOF	WHATSNEW	/^- On VMS, changed -V (\/VMS) processing to truncate file at EOF, allowing$/;"	v
EPOCH_WDAY	timezone.c	70;"	d	file:
EPOCH_YEAR	timezone.c	71;"	d	file:
EQUAL	deflate.c	218;"	d	file:
EXIT	tailor.h	866;"	d
EXTCRC	zipfile.c	67;"	d	file:
EXTLEN	zipfile.c	69;"	d	file:
EXTLOCSIG	zipfile.c	50;"	d	file:
EXTSIZ	zipfile.c	68;"	d	file:
Echon	ttyio.c	/^void Echon(__G)$/;"	f
Etq1	fileio.o	/^é#÷ÿÿ@·¾/;"	v
FALSE	tailor.h	304;"	d
FAST	deflate.c	96;"	d	file:
FIRST_GOOD_YEAR	timezone.c	73;"	d	file:
FIXSCAN_BUFSIZE	zipfile.c	1836;"	d	file:
FLUSH_BLOCK	deflate.c	424;"	d	file:
FNMAX	zip.h	123;"	d
FNMAX	zip.h	125;"	d
FOPM	tailor.h	414;"	d
FOPM	unix/osdep.h	72;"	d
FOPR	tailor.h	413;"	d
FOPR	unix/osdep.h	71;"	d
FOPR_EX	tailor.h	426;"	d
FOPR_EX	tailor.h	428;"	d
FOPW	tailor.h	415;"	d
FOPW	unix/osdep.h	73;"	d
FOPW_TMP	tailor.h	419;"	d
FORCE_UNIX_OVER_WIN32	tailor.h	19;"	d
FREE	README.CR	/^    LIKE ANYTHING ELSE THAT IS FREE, ZIP, UNZIP AND THEIR ASSOCIATED$/;"	v
FRESHEN	zip.c	37;"	d	file:
FZOFFT_FMT	tailor.h	773;"	d
FZOFFT_HEX_DOT_WID	tailor.h	784;"	d
FZOFFT_HEX_WID	tailor.h	783;"	d
FZOFFT_HEX_WID_VALUE	tailor.h	776;"	d
FZOFFT_HEX_WID_VALUE	tailor.h	778;"	d
FZOFFT_LEN	util.c	485;"	d	file:
FZOFFT_NUM	util.c	484;"	d	file:
Far	tailor.h	495;"	d
Flag	WHATSNEW	/^  General Purpose Bit Flag, bit 11, UTF-8 flag, that indicates UTF-8$/;"	v
Freq	trees.c	230;"	d	file:
GETNAM_MAX	fileio.c	58;"	d	file:
GLOBAL	crypt.c	72;"	d	file:
GLOBAL	ttyio.c	43;"	d	file:
GLOBALS	globals.c	16;"	d	file:
GTTY	ttyio.c	52;"	d	file:
H	zip.o	/^/;"	v
H	zipup.o	/^uÜH9ÊAD$ÿH‰óu×€/;"	v
HASH_BITS	deflate.c	86;"	d	file:
HASH_MASK	deflate.c	89;"	d	file:
HASH_SIZE	deflate.c	88;"	d	file:
HEAP_SIZE	trees.c	235;"	d	file:
HOURSPERDAY	timezone.c	62;"	d	file:
H_SHIFT	deflate.c	147;"	d	file:
INCSTR	tailor.h	368;"	d
INDEX	zipsplit.c	30;"	d	file:
INDEX	zipsplit.c	37;"	d	file:
INDEX	zipsplit.c	43;"	d	file:
INDEX	zipsplit.c	48;"	d	file:
INSERT_STRING	deflate.c	247;"	d	file:
IN_VALUE_LIST	fileio.c	2588;"	d	file:
IPos	deflate.c	/^typedef unsigned IPos;$/;"	t	file:
IZTZ_GETLOCALETZINFO	timezone.c	51;"	d	file:
IZ_COMPANY_NAME	revision.h	31;"	d
IZ_IMP	tailor.h	204;"	d
IZ_PWLEN	crypt.h	61;"	d
IZ_PW_CANCEL	zip.h	270;"	d
IZ_PW_CANCELALL	zip.h	271;"	d
IZ_PW_ENTERED	zip.h	269;"	d
IZ_PW_ERROR	zip.h	272;"	d
IZ_PW_SKIPVERIFY	zip.h	273;"	d
JULIAN_DAY	timezone.h	30;"	d
KIND	README.CR	/^    UTILITIES ARE PROVIDED AS IS AND COME WITH NO WARRANTY OF ANY KIND,$/;"	v
LARGE_FILE_SUPPORT	unix/osdep.h	14;"	d
LAST_GOOD_YEAR	timezone.c	74;"	d	file:
LAST_KNOWN_COMPMETHOD	zip.h	333;"	d
LAST_KNOWN_COMPMETHOD	zip.h	335;"	d
LENGTH_CODES	trees.c	139;"	d	file:
LF	zip.h	264;"	d
LFLAGS2	unix/configure	/^            LFLAGS2="${LFLAGS2} ${lf}"$/;"	v
LFLAGS2	unix/configure	/^    LFLAGS2="${LFLAGS2} ${OPT}"$/;"	v
LG	fileio.c	849;"	d	file:
LG	zipfile.c	34;"	d	file:
LITERALS	trees.c	142;"	d	file:
LIT_BUFSIZE	trees.c	174;"	d	file:
LIT_BUFSIZE	trees.c	177;"	d	file:
LIT_BUFSIZE	trees.c	179;"	d	file:
LLG	fileio.c	850;"	d	file:
LLG	zipfile.c	35;"	d	file:
LOCCRC	zipfile.c	59;"	d	file:
LOCDAT	zipfile.c	58;"	d	file:
LOCEXT	zipfile.c	63;"	d	file:
LOCFLG	zipfile.c	55;"	d	file:
LOCHEAD	zip.h	140;"	d
LOCHOW	zipfile.c	56;"	d	file:
LOCLEN	zipfile.c	61;"	d	file:
LOCNAM	zipfile.c	62;"	d	file:
LOCSIG	zipfile.c	47;"	d	file:
LOCSIZ	zipfile.c	60;"	d	file:
LOCTIM	zipfile.c	57;"	d	file:
LOCVER	zipfile.c	54;"	d	file:
LSSTAT	tailor.h	733;"	d
LSSTAT	tailor.h	736;"	d
LSSTAT	tailor.h	749;"	d
LSSTAT	tailor.h	752;"	d
LSSTATW	tailor.h	738;"	d
LSSTATW	tailor.h	754;"	d
LSTAT	tailor.h	732;"	d
LSTAT	tailor.h	735;"	d
LSTAT	tailor.h	748;"	d
LSTAT	tailor.h	751;"	d
L_CODES	trees.c	148;"	d	file:
Len	trees.c	233;"	d	file:
Linux	TODO	/^- Extended attributes for Windows, Linux, and Mac OS X.$/;"	v
Linux	WHATSNEW	/^- Extended attributes for Windows, Linux, and Mac OS X.$/;"	v
MAKEF	unix/Makefile	/^MAKEF = -f unix\/Makefile$/;"	v
MARK	zipnote.c	33;"	d	file:
MARKE	zipnote.c	34;"	d	file:
MARKZ	zipnote.c	35;"	d	file:
MATCH	zip.h	129;"	d
MAXCOM	zip.c	29;"	d	file:
MAX_BITS	trees.c	133;"	d	file:
MAX_BL_BITS	trees.c	136;"	d	file:
MAX_DIST	match.S	57;"	d	file:
MAX_DIST	zip.h	116;"	d
MAX_ESCAPE_BYTES	fileio.c	2223;"	d	file:
MAX_MATCH	match.S	55;"	d	file:
MAX_MATCH	zip.h	100;"	d
MBSCHR	tailor.h	352;"	d
MBSCHR	tailor.h	362;"	d
MBSRCHR	tailor.h	353;"	d
MBSRCHR	tailor.h	363;"	d
MB_CLEN	zip.h	1048;"	d
MB_CLEN	zip.h	1052;"	d
MB_NEXTCHAR	zip.h	1049;"	d
MB_NEXTCHAR	zip.h	1053;"	d
MET	zip.txt	/^              The  format is TTThhDDD, where TTT is the time zone such as MET,$/;"	v
MINSPERHOUR	timezone.c	61;"	d	file:
MIN_LOOKAHEAD	match.S	56;"	d	file:
MIN_LOOKAHEAD	zip.h	111;"	d
MIN_MATCH	match.S	54;"	d	file:
MIN_MATCH	zip.h	99;"	d
MONSPERYEAR	timezone.c	68;"	d	file:
MONTH_NTH_DAY_OF_WEEK	timezone.h	32;"	d
MSDOS	INSTALL	/^     The steps for installation under VMS, MSDOS, OS\/2, NT, Amiga and$/;"	v
MSDOS	INSTALL	/^     wide range of systems:  Unix, VMS, MSDOS, OS\/2, NT, Amiga, Atari,$/;"	v
MSDOS	TODO	/^- on MSDOS, zip386.exe does not like "zip -bc: foo ..."$/;"	v
MSDOS_DIR_ATTR	tailor.h	434;"	d
MSDOS_HIDDEN_ATTR	tailor.h	433;"	d
MULTIBYTE_GETOPTNS	zip.h	1043;"	d
MY_ZCALLOC	tailor.h	878;"	d
Makefile	CHANGES	/^ 7. remove zilog entry from unix\/Makefile (Onno)$/;"	f
Max	trees.c	464;"	d	file:
NIL	deflate.c	93;"	d	file:
NL	zipsplit.c	25;"	d	file:
NL	zipsplit.c	27;"	d	file:
NON_OPTION_ARG	fileio.c	2589;"	d	file:
NO_PROTO	tailor.h	174;"	d
NT	INSTALL	/^     The steps for installation under VMS, MSDOS, OS\/2, NT, Amiga and$/;"	v
NT	INSTALL	/^     wide range of systems:  Unix, VMS, MSDOS, OS\/2, NT, Amiga, Atari,$/;"	v
NUM_HOSTS	tailor.h	853;"	d
OBJA	unix/configure	/^        OBJA="$OBJA crc_i386.o"$/;"	v
OBUF_SZ	zipup.c	1082;"	d	file:
OF	tailor.h	179;"	d
OF	tailor.h	182;"	d
OFT	tailor.h	180;"	d
OFT	tailor.h	183;"	d
OFT	zipfile.c	/^char *get_extra_field( OFT( ush) tag,$/;"	f
OFT	zipfile.c	/^local void append_ushort_to_mem( OFT( ush) usValue,$/;"	f
OFT	zipfile.c	/^local void write_ushort_to_mem( OFT( ush) usValue,$/;"	f
OPT	unix/configure	/^  OPT=""$/;"	v
OPTIONERR_BUF_SIZE	fileio.c	2602;"	d	file:
OS	INSTALL	/^     The steps for installation under VMS, MSDOS, OS\/2, NT, Amiga and$/;"	v
OS	INSTALL	/^     wide range of systems:  Unix, VMS, MSDOS, OS\/2, NT, Amiga, Atari,$/;"	v
OS_CODE	tailor.h	801;"	d
OS_CODE	tailor.h	804;"	d
OS_CODE	tailor.h	808;"	d
OS_CODE	tailor.h	811;"	d
OS_CODE	tailor.h	814;"	d
OS_CODE	tailor.h	817;"	d
OS_CODE	tailor.h	822;"	d
OS_CODE	tailor.h	825;"	d
OS_CODE	tailor.h	828;"	d
OS_CODE	tailor.h	831;"	d
OS_CODE	tailor.h	834;"	d
OS_CODE	tailor.h	837;"	d
OS_CODE	tailor.h	840;"	d
OS_CODE	tailor.h	843;"	d
OS_CODE	tailor.h	846;"	d
OS_CODE	tailor.h	850;"	d
OS_CODE	tailor.h	857;"	d
OS_CODE	tailor.h	861;"	d
OS_NAME	unix/unix.c	518;"	d	file:
O_BINARY	unix/zipup.h	15;"	d
O_RDONLY	unix/zipup.h	12;"	d
PAD	fileio.c	29;"	d	file:
PAD	unix/unix.c	20;"	d	file:
PAGESIZE	zipup.c	48;"	d	file:
PARSE	WHATSNEW	/^- On VMS (recent, non-VAX), with SET PROCESS \/PARSE = EXTEND,$/;"	v
PATHCUT	zipfile.c	261;"	d	file:
PATH_END	unix/unix.c	21;"	d	file:
PC_MAX_RND	zipup.c	276;"	d	file:
PC_MAX_SAFE	zipup.c	275;"	d	file:
PERR	ziperr.h	112;"	d
POSTINCSTR	tailor.h	350;"	d
POSTINCSTR	tailor.h	360;"	d
PREINCSTR	tailor.h	349;"	d
PREINCSTR	tailor.h	359;"	d
PROCNAME	zip.c	893;"	d	file:
PUTBYTE	trees.c	409;"	d	file:
PUTC	ttyio.c	41;"	d	file:
PUTLG	zipfile.c	39;"	d	file:
PUTLLG	zipfile.c	41;"	d	file:
PUTLOCAL_REWRITE	zip.h	991;"	d
PUTLOCAL_WRITE	zip.h	990;"	d
PUTSH	zipfile.c	38;"	d	file:
PUTSHORT	trees.c	402;"	d	file:
PWLEN	crypt.h	62;"	d
Parse_TZ	timezone.c	/^static int Parse_TZ(name, sp)$/;"	f	file:
Pos	deflate.c	/^  typedef ush Pos;$/;"	t	file:
RAND_HEAD_LEN	crypt.h	63;"	d
READ_REST_ARGS_VERBATIM	fileio.c	2592;"	d	file:
REPZ_11_138	trees.c	211;"	d	file:
REPZ_3_10	trees.c	208;"	d	file:
REP_3_6	trees.c	205;"	d	file:
RETURN	tailor.h	869;"	d
REVDATE	revision.h	25;"	d
REV_BE	crc32.h	28;"	d
ROUNDED_TIME	tailor.h	381;"	d
Rcount	globals.c	/^unsigned Rcount = 0;            \/* number of -R include patterns *\/$/;"	v
ReadNumString	util.c	/^uzoff_t ReadNumString( numstring )$/;"	f
SBSZ	tailor.h	464;"	d
SCAN_BUFSIZE	zipfile.c	2529;"	d	file:
SCAN_BUFSIZE	zipfile.c	2530;"	d	file:
SECSPERDAY	timezone.c	67;"	d	file:
SECSPERHOUR	timezone.c	66;"	d	file:
SECSPERMIN	timezone.c	60;"	d	file:
SEEK_CUR	tailor.h	300;"	d
SEEK_SET	tailor.h	296;"	d
SETLOCALE	tailor.h	355;"	d
SETLOCALE	tailor.h	365;"	d
SH	fileio.c	848;"	d	file:
SH	zipfile.c	33;"	d	file:
SKIP_VALUE_ARG	fileio.c	2585;"	d	file:
SLOW	deflate.c	97;"	d	file:
SMALLEST	trees.c	563;"	d	file:
SPLIT_MAXPATH	fileio.c	1233;"	d	file:
SSTAT	tailor.h	726;"	d
SSTAT	tailor.h	745;"	d
SSTATW	tailor.h	728;"	d
START_VALUE_LIST	fileio.c	2587;"	d	file:
STATIC_TREES	trees.c	168;"	d	file:
STOP_VALUE_LIST	fileio.c	2590;"	d	file:
STORE	zip.h	329;"	d
STORED_BLOCK	trees.c	167;"	d	file:
STTY	ttyio.c	53;"	d	file:
S_IFLNK	tailor.h	386;"	d
SavLen	crc_i386.S	144;"	d	file:
TB	zip30f.ann	/^  so many bytes read, settable from KB to TB, allowing progress to be$/;"	v
TEMPL_FMT	zipsplit.c	31;"	d	file:
TEMPL_FMT	zipsplit.c	38;"	d	file:
TEMPL_FMT	zipsplit.c	44;"	d	file:
TEMPL_FMT	zipsplit.c	49;"	d	file:
TEMPL_SIZ	zipsplit.c	32;"	d	file:
TEMPL_SIZ	zipsplit.c	39;"	d	file:
TEMPL_SIZ	zipsplit.c	45;"	d	file:
TEMPL_SIZ	zipsplit.c	50;"	d	file:
THIS_ARG_DONE	fileio.c	2586;"	d	file:
TMAX	zipsplit.c	90;"	d	file:
TM_HOUR_MAX	timezone.c	713;"	d	file:
TM_MDAY_MAX	timezone.c	710;"	d	file:
TM_MIN_MAX	timezone.c	716;"	d	file:
TM_MON_MAX	timezone.c	707;"	d	file:
TM_SEC_MAX	timezone.c	719;"	d	file:
TM_YEAR_BASE	timezone.c	72;"	d	file:
TM_YEAR_MAX	timezone.c	704;"	d	file:
TOO_FAR	deflate.c	100;"	d	file:
TRUE	tailor.h	308;"	d
TTThhDDD	zip.txt	/^              The  format is TTThhDDD, where TTT is the time zone such as MET,$/;"	v
TZDEFAULT	timezone.c	58;"	d	file:
TZDEFRULESTRING	timezone.c	57;"	d	file:
TZ_MAX_CHARS	timezone.h	24;"	d
TZ_MAX_CHARS	timezone.h	26;"	d
TZ_MAX_TIMES	timezone.h	21;"	d
TZ_MAX_TYPES	timezone.h	22;"	d
Trace	zip.h	567;"	d
Trace	zip.h	573;"	d
Trace	zip.h	582;"	d
Tracec	zip.h	570;"	d
Tracec	zip.h	576;"	d
Tracec	zip.h	585;"	d
Tracecv	zip.h	571;"	d
Tracecv	zip.h	577;"	d
Tracecv	zip.h	586;"	d
Tracev	zip.h	568;"	d
Tracev	zip.h	574;"	d
Tracev	zip.h	583;"	d
Tracevv	zip.h	569;"	d
Tracevv	zip.h	575;"	d
Tracevv	zip.h	584;"	d
UNALIGNED_OK	tailor.h	442;"	d
UNALIGNED_OK	tailor.h	445;"	d
UNICODE_SUPPORT	tailor.h	35;"	d
UNIX	tailor.h	23;"	d
UNKNOWN	zip.h	212;"	d
UPDATE	zip.c	36;"	d	file:
UPDATE_HASH	deflate.c	237;"	d	file:
USE_EF_UT_TIME	unix/osdep.h	79;"	d
USE_POSIX_TERMIOS	ttyio.c	45;"	d	file:
USE_STACKFRAME	crc_i386.S	84;"	d	file:
USING_DEFAULT_LARGE_FILE_SUPPORT	tailor.h	160;"	d
UTF8_BIT	zipfile.c	139;"	d	file:
UTF8_PATH_EF_TAG	zipfile.c	133;"	d	file:
UTIL	globals.c	17;"	d	file:
UTIL	zipcloak.c	22;"	d	file:
UTIL	zipnote.c	17;"	d	file:
UTIL	zipsplit.c	16;"	d	file:
Unicode	WHATSNEW	/^  Unicode, and UT time.$/;"	v
Unix	INSTALL	/^     wide range of systems:  Unix, VMS, MSDOS, OS\/2, NT, Amiga, Atari,$/;"	v
Unix	WHATSNEW	/^  Windows, Unix, and VMS using the bzip2 library.  A new option, -Z cm,$/;"	v
UpdCRC_lword	crc_i386.S	145;"	d	file:
UpdCRC_lword_sh	crc_i386.S	156;"	d	file:
VERSION	revision.h	24;"	d
VMS	INSTALL	/^     The steps for installation under VMS, MSDOS, OS\/2, NT, Amiga and$/;"	v
VMS	INSTALL	/^     wide range of systems:  Unix, VMS, MSDOS, OS\/2, NT, Amiga, Atari,$/;"	v
VMS	README	/^Testing for Zip 3.0 has focused mainly on Unix, VMS, Max OS X, and Win32,$/;"	v
VMS_MSG_IDENT	ziperr.h	22;"	d
WILDCHR_MULTI	util.c	25;"	d	file:
WILDCHR_SINGLE	util.c	24;"	d	file:
WIN32	CHANGES	/^    WIN32, set z->vem to "OS_DOS | <real zip version number>".$/;"	v
WIN32	tailor.h	26;"	d
WMASK	deflate.c	90;"	d	file:
WRBUFSIZ	zipnote.c	25;"	d	file:
WRBUFSIZ	zipnote.c	28;"	d	file:
WRBUFSIZ	zipnote.c	29;"	d	file:
WSIZE	match.S	52;"	d	file:
WSIZE	zip.h	104;"	d
Win32	INSTALL	/^    This flag should be set automatically on Unix, Win32, and some$/;"	v
Win32	README	/^Testing for Zip 3.0 has focused mainly on Unix, VMS, Max OS X, and Win32,$/;"	v
Win32	README	/^create and read large files and archives.  On Unix, Win32, and some other$/;"	v
Windows	README	/^how to use them.  Also, if you are using MSDOS or Windows, note that text$/;"	v
WriteNumString	util.c	/^int WriteNumString( num, outstring )$/;"	f
X	README	/^Testing for Zip 3.0 has focused mainly on Unix, VMS, Max OS X, and Win32,$/;"	v
XPG4	unix/README.OS390	/^XPG4, build environment, a Unix-style filesystem (called HFS), and$/;"	v
YDAYS	timezone.c	76;"	d	file:
ZBSZ	tailor.h	450;"	d
ZBSZ	tailor.h	455;"	d
ZBSZ	tailor.h	460;"	d
ZCONST	ebcdic.h	49;"	d
ZCONST	tailor.h	190;"	d
ZCONST	tailor.h	193;"	d
ZCRYPT_INTERNAL	crypt.c	32;"	d	file:
ZCR_SEED2	tailor.h	795;"	d
ZE_ABORT	ziperr.h	48;"	d
ZE_BIG	ziperr.h	45;"	d
ZE_COMPERR	ziperr.h	57;"	d
ZE_CREAT	ziperr.h	54;"	d
ZE_EOF	ziperr.h	41;"	d
ZE_FORM	ziperr.h	42;"	d
ZE_LOGIC	ziperr.h	44;"	d
ZE_MAXERR	ziperr.h	60;"	d
ZE_MEM	ziperr.h	43;"	d
ZE_MISS	ziperr.h	39;"	d
ZE_NAME	ziperr.h	52;"	d
ZE_NONE	ziperr.h	51;"	d
ZE_NOTE	ziperr.h	46;"	d
ZE_OK	ziperr.h	40;"	d
ZE_OPEN	ziperr.h	56;"	d
ZE_PARMS	ziperr.h	55;"	d
ZE_READ	ziperr.h	50;"	d
ZE_S_ERROR	ziperr.h	27;"	d
ZE_S_INFO	ziperr.h	28;"	d
ZE_S_PERR	ziperr.h	33;"	d
ZE_S_SEVERE	ziperr.h	29;"	d
ZE_S_SUCCESS	ziperr.h	26;"	d
ZE_S_UNUSED	ziperr.h	30;"	d
ZE_S_WARNING	ziperr.h	25;"	d
ZE_TEMP	ziperr.h	49;"	d
ZE_TEST	ziperr.h	47;"	d
ZE_WRITE	ziperr.h	53;"	d
ZE_ZIP64	ziperr.h	58;"	d
ZIP	README.CR	/^    LIKE ANYTHING ELSE THAT IS FREE, ZIP, UNZIP AND THEIR ASSOCIATED$/;"	v
ZIP	zip.h	79;"	d
ZIP64_CENTRAL_DIR_TAIL_END_SIG	zipfile.c	121;"	d	file:
ZIP64_CENTRAL_DIR_TAIL_SIG	zipfile.c	120;"	d	file:
ZIP64_CENTRAL_DIR_TAIL_SIZE	zipfile.c	119;"	d	file:
ZIP64_EFIELD_OFS_CSIZE	zipfile.c	125;"	d	file:
ZIP64_EFIELD_OFS_DISK	zipfile.c	127;"	d	file:
ZIP64_EFIELD_OFS_OFS	zipfile.c	126;"	d	file:
ZIP64_EFIELD_OFS_OSIZE	zipfile.c	124;"	d	file:
ZIP64_EF_TAG	zipfile.c	123;"	d	file:
ZIP64_EOCDL_OFS_EOCD_START	zipfile.c	116;"	d	file:
ZIP64_EOCDL_OFS_SIZE	zipfile.c	103;"	d	file:
ZIP64_EOCDL_OFS_SIZE	zipfile.c	115;"	d	file:
ZIP64_EOCDL_OFS_TOTALDISKS	zipfile.c	117;"	d	file:
ZIP64_EOCDL_SIG	zipfile.c	101;"	d	file:
ZIP64_EOCD_OFS_CD_START	zipfile.c	114;"	d	file:
ZIP64_EOCD_OFS_SIZE	zipfile.c	113;"	d	file:
ZIP64_EOCD_SIG	zipfile.c	112;"	d	file:
ZIP64_EXTCRC	zipfile.c	109;"	d	file:
ZIP64_EXTLEN	zipfile.c	111;"	d	file:
ZIP64_EXTSIZ	zipfile.c	110;"	d	file:
ZIP64_LARGE_FILE_HEAD_SIZE	zipfile.c	122;"	d	file:
ZIP64_MIN_VER	zipfile.c	118;"	d	file:
ZIP64_SUPPORT	unix/osdep.h	59;"	d
ZIP64_SUPPORT	unix/osdep.h	63;"	d
ZIPERR	tailor.h	873;"	d
ZIPERRORS	ziperr.h	115;"	d
ZIP_EF_HEADER_SIZE	zipfile.c	107;"	d	file:
ZIP_UWORD16_MAX	zipfile.c	105;"	d	file:
ZIP_UWORD32_MAX	zipfile.c	106;"	d	file:
ZOFF_T_FORMAT_SIZE_PREFIX	tailor.h	142;"	d
ZOFF_T_FORMAT_SIZE_PREFIX	tailor.h	153;"	d
ZOFF_T_FORMAT_SIZE_PREFIX	unix/osdep.h	35;"	d
ZOFF_T_FORMAT_SIZE_PREFIX	unix/osdep.h	37;"	d
ZPATH_SEP	zipsplit.c	33;"	d	file:
ZPATH_SEP	zipsplit.c	36;"	d	file:
ZPATH_SEP	zipsplit.c	46;"	d	file:
ZPATH_SEP	zipsplit.c	51;"	d	file:
ZP_NEED_GEN_D2U_TIME	fileio.c	654;"	d	file:
ZP_NEED_GEN_D2U_TIME	fileio.c	679;"	d	file:
ZP_PW_ENTER	zip.h	276;"	d
ZP_PW_VERIFY	zip.h	277;"	d
Z_BETALEVEL	revision.h	22;"	d
Z_MAJORVER	revision.h	19;"	d
Z_MINORVER	revision.h	20;"	d
Z_PATCHLEVEL	revision.h	21;"	d
Z_UINT4_DEFINED	tailor.h	393;"	d
Z_UINT4_DEFINED	tailor.h	397;"	d
Z_UINT4_DEFINED	tailor.h	401;"	d
Z_UINT4_DEFINED	tailor.h	409;"	d
_FILE_OFFSET_BITS	tailor.h	135;"	d
_FILE_OFFSET_BITS	unix/configure	354;"	d	file:
_FILE_OFFSET_BITS	unix/configure	410;"	d	file:
_FILE_OFFSET_BITS	unix/osdep.h	26;"	d
_LARGEFILE64_SOURCE	tailor.h	134;"	d
_LARGEFILE64_SOURCE	unix/configure	353;"	d	file:
_LARGEFILE64_SOURCE	unix/configure	409;"	d	file:
_LARGEFILE64_SOURCE	unix/osdep.h	25;"	d
_LARGEFILE_SOURCE	tailor.h	133;"	d
_LARGEFILE_SOURCE	unix/configure	352;"	d	file:
_LARGEFILE_SOURCE	unix/configure	408;"	d	file:
_LARGEFILE_SOURCE	unix/osdep.h	24;"	d
_LARGE_FILES	tailor.h	136;"	d
_LARGE_FILES	unix/configure	355;"	d	file:
_LARGE_FILES	unix/configure	411;"	d	file:
_LARGE_FILES	unix/osdep.h	27;"	d
_P100	timezone.c	83;"	d	file:
_P4	timezone.c	82;"	d	file:
_P400	timezone.c	84;"	d	file:
_PATH_TTY	ttyio.c	98;"	d	file:
_STD_ENTRY	crc_i386.S	95;"	d	file:
_STD_LEAVE	crc_i386.S	99;"	d	file:
__686	crc_i386.S	80;"	d	file:
__CRC32_C	crc32.c	22;"	d	file:
__DEFLATE_C	deflate.c	70;"	d	file:
__EBCDIC	zip.h	215;"	d
__FILEIO_C	fileio.c	14;"	d	file:
__G	crypt.h	47;"	d
__GDEF	crypt.h	49;"	d
__GLOBALS_C	globals.c	14;"	d	file:
__GPRO	crypt.h	50;"	d
__GPRO__	crypt.h	51;"	d
__G__	crypt.h	48;"	d
__TREES_C	trees.c	118;"	d	file:
__TTYIO_C	ttyio.c	29;"	d	file:
__UTIL_C	util.c	14;"	d	file:
__ZBZ2ERR_C	zbz2err.c	30;"	d	file:
__ZIPCLOAK_C	zipcloak.c	19;"	d	file:
__ZIPFILE_C	zipfile.c	14;"	d	file:
__ZIPNOTE_C	zipnote.c	14;"	d	file:
__ZIPSPLIT_C	zipsplit.c	14;"	d	file:
__ZIPUP_C	zipup.c	14;"	d	file:
__ZIP_C	zip.c	14;"	d	file:
__anon1::name	ziperr.h	/^    char *name;$/;"	m	struct:__anon1	access:public
__anon1::severity	ziperr.h	/^    int severity;$/;"	m	struct:__anon1	access:public
__anon1::string	ziperr.h	/^    char *string;$/;"	m	struct:__anon1	access:public
__anon2::name	ziperr.h	/^    char *name;$/;"	m	struct:__anon2	access:public
__anon2::severity	ziperr.h	/^    int severity;$/;"	m	struct:__anon2	access:public
__anon2::string	ziperr.h	/^    char *string;$/;"	m	struct:__anon2	access:public
__crc32_h	crc32.h	15;"	d
__crypt_h	crypt.h	26;"	d
__ebcdic_h	ebcdic.h	45;"	d
__revision_h	revision.h	16;"	d
__timezone_c	timezone.c	37;"	d	file:
__timezone_h	timezone.h	12;"	d
__ttyio_h	ttyio.h	17;"	d
__tzset	timezone.c	/^void __tzset()$/;"	f
__zip_h	zip.h	77;"	d
_crc32	crc_i386.S	57;"	d	file:
_get_crc_table	crc_i386.S	58;"	d	file:
_good_match	match.S	/^        cmp     _good_match,%ebx       \/* do we have a good match already? *\/$/;"	v
_good_match	match.S	29;"	d	file:
_isindst	timezone.c	/^int _isindst(tb)$/;"	f
_longest_match	match.S	35;"	d	file:
_match_init	match.S	34;"	d	file:
_match_start	match.S	27;"	d	file:
_max_chain_length	match.S	/^        mov     _max_chain_length,%ebp \/* chain_length = max_chain_length *\/$/;"	v
_max_chain_length	match.S	32;"	d	file:
_nice_match	match.S	30;"	d	file:
_prev	match.S	25;"	d	file:
_prev_length	match.S	/^        mov     _prev_length,%ebx      \/* best_len = prev_length *\/$/;"	v
_prev_length	match.S	28;"	d	file:
_strstart	match.S	/^        mov     _strstart,%edx$/;"	v
_strstart	match.S	31;"	d	file:
_tmbuf	timezone.c	/^static struct tm _tmbuf;$/;"	v	typeref:struct:tm	file:
_window	match.S	/^        add     $2+_window,%edi        \/* edi = offset(window+strstart+2) *\/$/;"	v
_window	match.S	/^        add     $2+_window,%esi         \/* si = match *\/$/;"	v
_window	match.S	/^        sub     $2+_window,%esi     \/* esi = cur_match + len *\/$/;"	v
_window	match.S	26;"	d	file:
abbrevmatch	util.c	/^int abbrevmatch (matchstring, abbrev, case_sensitive, minmatch)$/;"	f
actime	tailor.h	/^    time_t actime;              \/* new access time *\/$/;"	m	struct:ztimbuf	access:public
action	zip.c	/^local int action = ADD; \/* one of ADD, UPDATE, FRESHEN, DELETE, or ARCHIVE *\/$/;"	v
add_Unicode_Path_cen_extra_field	zipfile.c	/^local int add_Unicode_Path_cen_extra_field(pZEntry)$/;"	f
add_Unicode_Path_local_extra_field	zipfile.c	/^local int add_Unicode_Path_local_extra_field(pZEntry)$/;"	f
add_central_zip64_extra_field	zipfile.c	/^local int add_central_zip64_extra_field(pZipListEntry)$/;"	f
add_local_zip64_extra_field	zipfile.c	/^local int add_local_zip64_extra_field(pZEntry)$/;"	f
add_name	zip.c	/^local long add_name(filearg)$/;"	f
adding	zip30f.ann	/^  files on the file system, adding, updating, and deleting entries as needed,$/;"	v
adjust	globals.c	/^int adjust = 0;         \/* 1=adjust offsets for sfx'd file (keep preamble) *\/$/;"	v
adjust_zip_central_entry	zipfile.c	/^local void adjust_zip_central_entry(pZipListEntry)$/;"	f
adjust_zip_local_entry	zipfile.c	/^local int adjust_zip_local_entry(pZipListEntry)$/;"	f
after	globals.c	/^ulg after = 0;          \/* 0=ignore, else exclude files newer than this time *\/$/;"	v
allow_empty_archive	globals.c	/^int allow_empty_archive = 0;  \/* if no files, create empty archive anyway 12\/28\/05 *\/$/;"	v
allow_fifo	globals.c	/^int allow_fifo = 0;           \/* 1=allow reading Unix FIFOs, waiting if pipe open *\/$/;"	v
allow_regex	globals.c	/^int allow_regex = 0;         \/* 1 = allow [list] matching *\/$/;"	v
already	INSTALL	/^     you have unpacked it already, or you cheated and got a tar.Z file...$/;"	v
and	zip.txt	/^              the  archive  and,  depending  on  the  damage,  it may find the$/;"	v
append_int64_to_mem	zipfile.c	/^local void append_int64_to_mem(l64Value, pPtr, offset, blocksize)$/;"	f
append_string_to_mem	zipfile.c	/^local void append_string_to_mem(strValue, strLength, pPtr, offset, blocksize)$/;"	f
append_ulong_to_mem	zipfile.c	/^local void append_ulong_to_mem(uValue, pPtr, offset, blocksize)$/;"	f
archive	INSTALL	/^     the archive, making the creating of the zipsrc directory optional.$/;"	v
archive	man/zip.1	/^In cmd, {} is replaced by the name of the temporary archive, otherwise the name$/;"	v
archive	tags	/^archive	man\/zip.1	\/^In cmd, {} is replaced by the name of the temporary archive, otherwise the name$\/;"	v$/;"	v
archive	unix/Packaging/README	/^files are resident in the archive, and it is easily distributed.$/;"	v
archive	zip.txt	/^              Grow (append to) the specified zip archive, instead of  creating$/;"	v
archive	zip30f.ann	/^  creating an updated archive that should be the same as a new archive, but$/;"	v
archived	zip.txt	/^              being archived, and -DF to create a differential archive.$/;"	v
archives	README	/^bzip2 compressed entries in archives, so test your unzip first before using$/;"	v
archives	README	/^spanned archives, but Zip 3.0 supports split archives.  A split archive is an$/;"	v
arg1	crc_i386.S	/^                movl    arg1, %eax           \/* 1st arg: ulg crc             *\/$/;"	v
arg1	crc_i386.S	96;"	d	file:
arg2	crc_i386.S	97;"	d	file:
arg3	crc_i386.S	/^                movl    arg3, %ecx           \/* 3rd arg: extent len          *\/$/;"	v
arg3	crc_i386.S	98;"	d	file:
ascii	ebcdic.h	/^ZCONST uch ascii[] = {$/;"	v
ask_for_split_read_path	fileio.c	/^int ask_for_split_read_path(current_disk)$/;"	f
ask_for_split_write_path	fileio.c	/^int ask_for_split_write_path(current_disk)$/;"	f
at_signature	zipfile.c	/^local int at_signature(f, signature)$/;"	f
atime	zip.h	/^   time_t atime;                \/* new access time *\/$/;"	m	struct:iztimes	access:public
ats	timezone.h	/^    time_t          ats[TZ_MAX_TIMES];$/;"	m	struct:state	access:public
att	zip.h	/^  ush att, lflg;                \/* offset of lflg must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
att6300	INSTALL	/^     att6300, coherent, cray_v3, minix, sco_x286, xenix, zilog.$/;"	v
attributes	README	/^extended file attributes; conversion from Unix to MSDOS text file format; and,$/;"	v
atx	zip.h	/^  ulg atx;$/;"	m	struct:zlist	access:public
backups	zip30.ann	/^  difference mode for supporting incremental backups, a file sync$/;"	v
bad_bytes_so_far	globals.c	/^uzoff_t bad_bytes_so_far = 0; \/* bad bytes skipped so far *\/$/;"	v
bad_files_so_far	globals.c	/^ulg bad_files_so_far = 0;     \/* bad files skipped so far *\/$/;"	v
base_dist	trees.c	/^local int near base_dist[D_CODES];$/;"	v
base_length	trees.c	/^local int near base_length[LENGTH_CODES];$/;"	v
be	WHATSNEW	/^  to be, to read then strip old extra fields when reading entries from an$/;"	v
before	globals.c	/^ulg before = 0;         \/* 0=ignore, else exclude files before this time *\/$/;"	v
better	README	/^favorite port is broke, send us the details or, better, send bug fixes.  It's$/;"	v
bfcopy	fileio.c	/^int bfcopy(n)$/;"	f
bfwrite	fileio.c	/^size_t bfwrite(buffer, size, count, mode)$/;"	f
bi_buf	trees.c	/^local unsigned bi_buf;$/;"	v
bi_buf	trees.c	/^unsigned bi_buf;$/;"	v
bi_init	trees.c	/^void bi_init (tgt_buf, tgt_size, flsh_allowed)$/;"	f
bi_reverse	trees.c	/^local unsigned bi_reverse(code, len)$/;"	f
bi_valid	trees.c	/^int bi_valid;$/;"	v
bi_valid	trees.c	/^local int bi_valid;$/;"	v
bi_windup	trees.c	/^local void bi_windup()$/;"	f
bit	WHATSNEW	/^  General Purpose Bit Flag, bit 11, UTF-8 flag, that indicates UTF-8$/;"	v
bits_sent	trees.c	/^local uzoff_t bits_sent;   \/* bit length of the compressed data *\/$/;"	v
bl_count	trees.c	/^local ush near bl_count[MAX_BITS+1];$/;"	v
bl_desc	trees.c	/^local tree_desc near bl_desc =$/;"	v
bl_order	trees.c	/^local uch near bl_order[BL_CODES]$/;"	v
bl_tree	trees.c	/^local ct_data near bl_tree[2*BL_CODES+1];$/;"	v
block_start	deflate.c	/^long block_start;$/;"	v
bstrm	zipup.c	/^local bz_stream bstrm;      \/* zlib's data interface structure *\/$/;"	v
build_bl_tree	trees.c	/^local int build_bl_tree()$/;"	f
build_tree	trees.c	/^local void build_tree(desc)$/;"	f
bytes_prev_splits	globals.c	/^uzoff_t bytes_prev_splits = 0;    \/* total bytes written to all splits before this *\/$/;"	v
bytes_so_far	globals.c	/^uzoff_t bytes_so_far = 0;     \/* bytes processed so far (from initial scan) *\/$/;"	v
bytes_this_entry	globals.c	/^uzoff_t bytes_this_entry = 0;     \/* bytes written for this entry across all splits *\/$/;"	v
bytes_this_split	globals.c	/^uzoff_t bytes_this_split = 0;     \/* bytes written to the current split *\/$/;"	v
bytes_total	globals.c	/^uzoff_t bytes_total = 0;      \/* total bytes to process (from initial scan) *\/$/;"	v
bz_compress_free	zipup.c	/^void bz_compress_free()$/;"	f
bz_compress_init	zipup.c	/^local int bz_compress_init(pack_level)$/;"	f
bz_internal_error	zbz2err.c	/^void bz_internal_error(errcode)$/;"	f
bzfilecompress	zipup.c	/^local zoff_t bzfilecompress(z_entry, cmpr_method)$/;"	f
bzipInit	zipup.c	/^local int bzipInit;         \/* flag: bzip2lib is initialized *\/$/;"	v
c	CHANGES	/^ 1. Fix bug in QDOS patch that broke zipsplit.c (Onno, Paul)$/;"	f
c	crypt.c	/^    int c;                      \/* byte of plain text *\/$/;"	v
c	zipfile.c	/^  uzoff_t c;                \/* offset of central directory *\/$/;"	v
capabilities	zip30.ann	/^  capabilities, but modifying existing programs to use the new dll$/;"	v
case_map	tailor.h	212;"	d
case_map	tailor.h	215;"	d
catalloc	zipnote.c	/^local int catalloc(a, s)$/;"	f
cd_entries_this_disk	globals.c	/^uzoff_t cd_entries_this_disk = 0; \/* cd entries this disk *\/$/;"	v
cd_start_disk	globals.c	/^ulg     cd_start_disk = (ulg)-1;  \/* central directory start disk *\/$/;"	v
cd_start_offset	globals.c	/^uzoff_t cd_start_offset = 0;      \/* offset of start of cd on cd start disk *\/$/;"	v
cenbeg	globals.c	/^uzoff_t cenbeg;               \/* Starting offset of central dir *\/$/;"	v
cext	zip.h	/^  ush nam, ext, cext, com;      \/* offset of ext must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
cextra	zip.h	/^  char *cextra;                 \/* Extra in central (set only if cext != 0) *\/$/;"	m	struct:zlist	access:public
charcnt	timezone.h	/^    int             charcnt;$/;"	m	struct:state	access:public
chars	timezone.h	/^    char            chars[TZ_MAX_CHARS];$/;"	m	struct:state	access:public
check_dup	fileio.c	/^int check_dup()$/;"	f
check_match	deflate.c	418;"	d	file:
check_unzip_version	zip.c	/^local int check_unzip_version(unzippath)$/;"	f
check_zipfile	zip.c	/^local void check_zipfile(zipname, zippath)$/;"	f
close_split	fileio.c	/^int close_split(disk_number, tempfile, temp_name)$/;"	f
cma$tis_errno_get_addr	zip.h	360;"	d
cmpr_bytelen	trees.c	/^local uzoff_t cmpr_bytelen;     \/* total byte length of compressed file *\/$/;"	v
cmpr_len_bits	trees.c	/^local ulg cmpr_len_bits;        \/* number of bits past 'cmpr_bytelen' *\/$/;"	v
code	WHATSNEW	/^  otherwise use base code, and compiling normally to enable Zip64 code$/;"	v
code	trees.c	/^        ush  code;       \/* bit string *\/$/;"	m	union:ct_data::__anon3	file:	access:public
coherent	INSTALL	/^     att6300, coherent, cray_v3, minix, sco_x286, xenix, zilog.$/;"	v
com	zip.h	/^  ush nam, ext, cext, com;      \/* offset of ext must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
comadd	zip.c	/^local int comadd = 0;   \/* 1=add comments for new files *\/$/;"	v
comment	zip.h	/^  char *comment;                \/* Comment (set only if com != 0) *\/$/;"	m	struct:zlist	access:public
common	INSTALL	/^     SYS$LOGIN:LOGIN.COM procedure, or to a common, site-specific$/;"	v
compatibility	zip.txt	/^       path  for  backward  compatibility,  the UTF-8 translation of the path.$/;"	v
compress_block	trees.c	/^local void compress_block(ltree, dtree)$/;"	f
compressed	zip.txt	/^              copied instead of compressed, updating an existing archive  with$/;"	v
config	deflate.c	/^typedef struct config {$/;"	s	file:
config	deflate.c	/^} config;$/;"	t	typeref:struct:config	file:
config::good_length	deflate.c	/^   ush good_length; \/* reduce lazy search above this match length *\/$/;"	m	struct:config	file:	access:public
config::max_chain	deflate.c	/^   ush max_chain;$/;"	m	struct:config	file:	access:public
config::max_lazy	deflate.c	/^   ush max_lazy;    \/* do not perform lazy search above this match length *\/$/;"	m	struct:config	file:	access:public
config::nice_length	deflate.c	/^   ush nice_length; \/* quit search above this match length *\/$/;"	m	struct:config	file:	access:public
configuration_table	deflate.c	/^local config configuration_table[10] = {$/;"	v
const	tailor.h	191;"	d
contents	zip.txt	/^       temporary file with the new contents, and only replace the old one when$/;"	v
contributions	README	/^thoughts and contributions, etc., check out the new discussion forum.  This is$/;"	v
copied	WHATSNEW	/^  since existing entries are copied, may be much faster.$/;"	v
copy_args	fileio.c	/^char **copy_args(args, max_args)$/;"	f
copy_block	trees.c	/^local void copy_block(block, len, header)$/;"	f
copy_nondup_extra_fields	zipfile.c	/^char *copy_nondup_extra_fields(oldExtra, oldExtraLen, newExtra, newExtraLen, newLen)$/;"	f
copy_only	globals.c	/^int copy_only = 0;            \/* 1=copying archive entries only *\/$/;"	v
copying	WHATSNEW	/^  when deleting, copying, or freshening entries (deleting and copying$/;"	v
copyright	revision.h	/^ZCONST char *copyright[] = {$/;"	v
count_args	util.c	/^local int count_args(s)$/;"	f
course	README	/^of course, the ability to run on most of your favorite operating systems.  And$/;"	v
cray_v3	INSTALL	/^     att6300, coherent, cray_v3, minix, sco_x286, xenix, zilog.$/;"	v
crc	zip.h	/^  ulg tim, crc;$/;"	m	struct:zlist	access:public
crc	zipup.c	/^local ulg crc;                  \/* crc on uncompressed file data *\/$/;"	v
crc32	crc32.c	/^ulg crc32(crc, buf, len)$/;"	f
crc_32_tab	zip.c	/^ZCONST ulg near *crc_32_tab;$/;"	v
crc_32_tab	zipcloak.c	/^ZCONST uLongf *crc_32_tab;$/;"	v
crc_32_tab	zipcloak.c	/^ZCONST ulg near *crc_32_tab;$/;"	v
crc_table	crc32.c	/^local ZCONST ulg near crc_table[CRC_TBLS*256] = {$/;"	v
created	WHATSNEW	/^  directories being created, -AS now does not store directory$/;"	v
created	zip30f.ann	/^  includes only files changed or added since the input archive was created,$/;"	v
crypthead	crypt.c	/^void crypthead(passwd, crc)$/;"	f
cryptnote	revision.h	/^ZCONST char * far cryptnote[] = {$/;"	v
ct_data	trees.c	/^typedef struct ct_data {$/;"	s	file:
ct_data	trees.c	/^} ct_data;$/;"	t	typeref:struct:ct_data	file:
ct_data::__anon3::code	trees.c	/^        ush  code;       \/* bit string *\/$/;"	m	union:ct_data::__anon3	file:	access:public
ct_data::__anon3::freq	trees.c	/^        ush  freq;       \/* frequency count *\/$/;"	m	union:ct_data::__anon3	file:	access:public
ct_data::__anon4::dad	trees.c	/^        ush  dad;        \/* father node in Huffman tree *\/$/;"	m	union:ct_data::__anon4	file:	access:public
ct_data::__anon4::len	trees.c	/^        ush  len;        \/* length of bit string *\/$/;"	m	union:ct_data::__anon4	file:	access:public
ct_data::dl	trees.c	/^    } dl;$/;"	m	struct:ct_data	typeref:union:ct_data::__anon4	file:	access:public
ct_data::fc	trees.c	/^    } fc;$/;"	m	struct:ct_data	typeref:union:ct_data::__anon3	file:	access:public
ct_init	trees.c	/^void ct_init(attr, method)$/;"	f
ct_tally	trees.c	/^int ct_tally (dist, lc)$/;"	f
ctime	zip.h	/^   time_t ctime;                \/* new creation time (!= Unix st.ctime) *\/$/;"	m	struct:iztimes	access:public
cur_match	match.S	93;"	d	file:
current	zip.h	/^  int current;                  \/* Marker for files that are current to what is on OS (filesync) *\/$/;"	m	struct:zlist	access:public
current_disk	globals.c	/^ulg     current_disk = 0;         \/* current disk number *\/$/;"	v
current_in_disk	globals.c	/^ulg     current_in_disk = 0;    \/* current read split disk *\/$/;"	v
current_in_offset	globals.c	/^uzoff_t current_in_offset = 0;  \/* current offset in current read disk *\/$/;"	v
current_local_disk	globals.c	/^ulg     current_local_disk = 0;   \/* disk with current local header *\/$/;"	v
current_local_file	globals.c	/^FILE  *current_local_file = NULL; \/* file pointer for current local header *\/$/;"	v
current_local_offset	globals.c	/^uzoff_t current_local_offset = 0; \/* offset to start of current local header *\/$/;"	v
current_local_tempname	globals.c	/^char *current_local_tempname = NULL; \/* name of temp file *\/$/;"	v
cutpath	zipfile.c	/^local void cutpath(p, delim)$/;"	f
d_buf	trees.c	/^  local ush far *d_buf;$/;"	v
d_buf	trees.c	/^  local ush far d_buf[DIST_BUFSIZE]; \/* buffer for distances *\/$/;"	v
d_code	trees.c	457;"	d	file:
d_desc	trees.c	/^local tree_desc near d_desc =$/;"	v
dad	trees.c	/^        ush  dad;        \/* father node in Huffman tree *\/$/;"	m	union:ct_data::__anon4	file:	access:public
damage	zip.txt	/^              the  archive  and,  depending  on  the  damage,  it may find the$/;"	v
daylight	timezone.c	/^int daylight = 0;$/;"	v
decrypt_byte	crypt.c	/^int decrypt_byte(__G)$/;"	f
decrypt_byte	crypt.h	57;"	d
defined	CHANGES	/^ 2. Only call NLMsignals() in zip.c when NLM is defined (Mike, Onno)$/;"	f
deflInit	zipup.c	/^local int deflInit = FALSE;   \/* flag: zlib deflate is initialized *\/$/;"	v
deflate	deflate.c	/^uzoff_t deflate()$/;"	f
deflate_fast	deflate.c	/^local uzoff_t deflate_fast()$/;"	f
deletedir	unix/unix.c	/^int deletedir(d)$/;"	f
depth	trees.c	/^local uch near depth[2*L_CODES+1];$/;"	v
des_crc	globals.c	/^ulg des_crc = 0;        \/* Data descriptor CRC *\/$/;"	v
des_csize	globals.c	/^uzoff_t des_csize = 0;  \/* Data descriptor csize *\/$/;"	v
des_good	globals.c	/^int des_good = 0;       \/* Good data descriptor found *\/$/;"	v
des_usize	globals.c	/^uzoff_t des_usize = 0;  \/* Data descriptor usize *\/$/;"	v
descmp	zipsplit.c	/^local int descmp(a, b)$/;"	f
descriptions	CHANGES	/^ 7. windll: Fix some typos, descriptions (Christian)$/;"	f
destroy	fileio.c	/^int destroy(f)$/;"	f
detection	CHANGES	/^ 3. use #elif constructions for msdos,os2 and win32 compiler detection (Onno)$/;"	f
diag	zip.h	564;"	d
diag	zip.h	580;"	d
diff_mode	globals.c	/^int diff_mode = 0;            \/* 1=require --out and only store changed and add *\/$/;"	v
different	zip.txt	/^       or size of the OS file is different, adding  new  files,  and  deleting$/;"	v
directories	zip.txt	/^              the paths of entries, including directories, are stored as usual$/;"	v
directory	README.CR	/^      directory, as usual.$/;"	v
directory	zip.txt	/^              include  dir,  a directory directly under the current directory,$/;"	v
dirnames	globals.c	/^int dirnames = 1;             \/* include directory entries by default *\/$/;"	v
display_bytes	globals.c	/^int display_bytes = 0;        \/* display running bytes remaining *\/$/;"	v
display_counts	globals.c	/^int display_counts = 0;       \/* display running file count *\/$/;"	v
display_globaldots	globals.c	/^int display_globaldots = 0;   \/* display dots for archive instead of each file *\/$/;"	v
display_usize	globals.c	/^int display_usize = 0;        \/* display uncompressed bytes *\/$/;"	v
display_volume	globals.c	/^int display_volume = 0;       \/* display current input and output volume (disk) numbers *\/$/;"	v
dispose	globals.c	/^int dispose = 0;        \/* 1=remove files after put in zip file *\/$/;"	v
dist_code	trees.c	/^local uch dist_code[512];$/;"	v
dl	trees.c	/^    } dl;$/;"	m	struct:ct_data	typeref:union:ct_data::__anon4	file:	access:public
dos2unixtime	fileio.c	/^time_t dos2unixtime(dostime)$/;"	f
dosflag	zip.h	/^  int dosflag;                  \/* Set to force MSDOS file attributes *\/$/;"	m	struct:flist	access:public
dosflag	zip.h	/^  int dosflag;                  \/* Set to force MSDOS file attributes *\/$/;"	m	struct:zlist	access:public
dosify	globals.c	/^int dosify = 0;         \/* 1=make new entries look like MSDOS *\/$/;"	v
dostime	fileio.c	/^ulg dostime(y, n, d, h, m, s)$/;"	f
dot_count	globals.c	/^zoff_t dot_count = 0;         \/* buffers seen, recyles at dot_size *\/$/;"	v
dot_size	globals.c	/^zoff_t dot_size = 0;          \/* bytes processed in deflate per dot, 0 = no dots *\/$/;"	v
doubledash_ends_options	fileio.c	/^int doubledash_ends_options = 1;            \/* when -- what follows are not options *\/$/;"	v
dsk	zip.h	/^  ulg dsk;                      \/* disk number was ush but now ulg *\/$/;"	m	struct:zlist	access:public
dyn_dtree	trees.c	/^local ct_data near dyn_dtree[2*D_CODES+1]; \/* distance tree *\/$/;"	v
dyn_ltree	trees.c	/^local ct_data near dyn_ltree[HEAP_SIZE];   \/* literal and length tree *\/$/;"	v
dyn_tree	trees.c	/^    ct_data near *dyn_tree;      \/* the dynamic tree *\/$/;"	m	struct:tree_desc	file:	access:public
dynamic	LICENSE	/^       modified or added functionality, and dynamic, shared, or static library$/;"	v
dynamic	tags	/^functionality	LICENSE	\/^       modified or added functionality, and dynamic, shared, or static library$\/;"	v$/;"	v
dynamic	tags	/^shared	LICENSE	\/^       modified or added functionality, and dynamic, shared, or static library$\/;"	v$/;"	v
eax	crc_i386.S	/^                subl    %eax, %eax           \/* > if (!buf)                  *\/$/;"	v
eax	match.S	/^        mov     %eax,%ebx               \/* ebx = best_len = len *\/$/;"	v
eax	match.S	/^        sub     %eax,%esi           \/* esi = cur_match *\/$/;"	v
ebcdic	ebcdic.h	/^ZCONST uch ebcdic[] = {$/;"	v
ebx	crc_i386.S	/^                subl    %ebx, %ebx           \/* ebx=0; bl usable as dword    *\/$/;"	v
ebx	match.S	/^        cmp     %ebx,%eax           \/* len > best_len ? *\/$/;"	v
ebx	match.S	/^        mov     %ebx,%eax               \/* result = eax = best_len *\/$/;"	v
echofd	ttyio.c	/^   static int echofd=(-1);      \/* file descriptor whose echo is off *\/$/;"	v	file:
echoff	ttyio.h	24;"	d
echon	ttyio.h	25;"	d
ecx	crc_i386.S	/^                testl   %ecx, %ecx$/;"	v
edi	match.S	/^        mov     %edi,%eax               \/* ax = scan+2 *\/$/;"	v
edi	match.S	/^        sub     %edi,%eax           \/* eax = len *\/$/;"	v
edi	match.S	/^        xchg    %edi,%eax           \/* edi = scan+2, eax = end of scan *\/$/;"	v
edx	match.S	/^        cmp     %edx,%esi               \/* cur_match <= limit ? *\/$/;"	v
edx	match.S	/^        mov     %edx,%edi$/;"	v
edx	match.S	/^        sub     %edx,%edx              \/* limit = NIL *\/$/;"	v
ef_scan_ut_time	zipfile.c	/^local int ef_scan_ut_time(ef_buf, ef_len, ef_is_cent, z_utim)$/;"	f
elems	trees.c	/^    int     elems;               \/* max number of elements in the tree *\/$/;"	m	struct:tree_desc	file:	access:public
enable_permute	fileio.c	/^int enable_permute = 1;                     \/* yes - return options first *\/$/;"	v
encr_passwd	zip.c	/^int encr_passwd(modeflag, pwbuf, size, zfn)$/;"	f
encryption	README.CR	/^For more serious encryption, check into PGP (Pretty Good Privacy), a$/;"	v
entries	zip.txt	/^              the paths of entries, including directories, are stored as usual$/;"	v
entry	zip.txt	/^       is written for the entry, but for a stream the size of the data is  not$/;"	v
envargs	util.c	/^void envargs(Pargc, Pargv, envstr, envstr2)$/;"	f
environment	unix/README.OS390	/^XPG4, build environment, a Unix-style filesystem (called HFS), and$/;"	v
eofile	deflate.c	/^local int           eofile;        \/* flag set at end of input file *\/$/;"	v
errbuf	globals.c	/^char errbuf[FNMAX+4081];$/;"	v
error	zip.c	/^void error(h)$/;"	f
error	zip.h	614;"	d
esi	crc_i386.S	/^                testl   %esi, %esi           \/* >   return 0;                *\/$/;"	v
esi	match.S	/^        mov     %esi,_match_start       \/* match_start = cur_match *\/$/;"	v
eval	unix/configure	/^  elif eval "$CC -c _match.s >\/dev\/null 2>\/dev\/null" && [ -f _match.o ]; then$/;"	v
ex2in	unix/unix.c	/^char *ex2in(x, isdir, pdosflag)$/;"	f
executables	INSTALL	/^     most users define foreign command symbols for the Zip executables, like$/;"	v
exit	zipnote.c	69;"	d	file:
exit	zipsplit.c	40;"	d	file:
expand_args	util.c	/^void expand_args(argcp, argvp)$/;"	f
ext	zip.h	/^  ush nam, ext, cext, com;      \/* offset of ext must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
extension	README	/^file using an extension, such as .z02 as in the file name archive.z02, that$/;"	v
extension	TODO	/^- For an sfx file without extension, "zip -A sfx" works but "zip sfx -A"$/;"	v
extent	tailor.h	/^   typedef size_t extent;$/;"	t
extent	tailor.h	/^   typedef unsigned int extent;$/;"	t
extra	zip.h	/^  char *extra;                  \/* Extra field (set only if ext != 0) *\/$/;"	m	struct:zlist	access:public
extra_base	trees.c	/^    int     extra_base;          \/* base index for extra_bits *\/$/;"	m	struct:tree_desc	file:	access:public
extra_bits	trees.c	/^    int     near *extra_bits;    \/* extra bits for each code or NULL *\/$/;"	m	struct:tree_desc	file:	access:public
extra_blbits	trees.c	/^local int near extra_blbits[BL_CODES]\/* extra bits for each bit length code *\/$/;"	v
extra_dbits	trees.c	/^local int near extra_dbits[D_CODES] \/* extra bits for each distance code *\/$/;"	v
extra_fields	globals.c	/^int extra_fields = 1;         \/* 0=create minimum, 1=don't copy old, 2=keep old *\/$/;"	v
extra_lbits	trees.c	/^local int near extra_lbits[LENGTH_CODES] \/* extra bits for each length code *\/$/;"	v
f	ttyio.c	/^    int f;                    \/* file descriptor for which to turn echo off *\/$/;"	v
fP	man/zip.1	/^\\fBk\\fP (kilobytes), \\fBm\\fP (megabytes), \\fBg\\fP (gigabytes), or \\fBt\\fP$/;"	f
f_ibuf	zipup.c	/^local char *f_ibuf = NULL;$/;"	v
f_obuf	zipup.c	/^local char *f_obuf = NULL;$/;"	v
far	tailor.h	470;"	d
far	tailor.h	474;"	d
far	tailor.h	482;"	d
farfree	tailor.h	491;"	d
farmalloc	tailor.h	490;"	d
fbad	unix/zipup.h	18;"	d
fc	trees.c	/^    } fc;$/;"	m	struct:ct_data	typeref:union:ct_data::__anon3	file:	access:public
fcopy	fileio.c	/^int fcopy(f, g, n)$/;"	f
fcount	globals.c	/^extent fcount;                    \/* Count of files in list *\/$/;"	v
features	README	/^can be used to discuss issues, request features, and is one place new betas$/;"	v
fexpel	fileio.c	/^struct flist far *fexpel(f)$/;"	f
ffile_size	zipfile.c	/^zoff_t ffile_size( file)$/;"	f
fhow	unix/zipup.h	17;"	d
fields	WHATSNEW	/^  The new option -X- (negated -X) keeps any old extra fields, copying$/;"	v
file	INSTALL	/^     distribution file, in this case zip30.zip.  But since you read this,$/;"	v
file	WHATSNEW	/^  but instead of displaying them for each file, the dots track the total$/;"	v
file	WHERE	/^   unz552d2.zip      OS\/2 2\/3\/4.x (32-bit) DLL, header file, demo exe and docs$/;"	v
file_binary	zipup.c	/^local int file_binary = 0;        \/* first buf *\/$/;"	v
file_binary_final	zipup.c	/^local int file_binary_final = 0;  \/* for bzip2 for entire file.  assume text until find binary *\/$/;"	v
file_method	trees.c	/^local int *file_method;     \/* pointer to DEFLATE or STORE *\/$/;"	v
file_outbuf	zipup.c	/^local char file_outbuf[1024]; \/* output buffer for compression to file *\/$/;"	v
file_read	zipup.c	/^local unsigned file_read(buf, size)$/;"	f
file_type	trees.c	/^local ush *file_type;       \/* pointer to UNKNOWN, BINARY or ASCII *\/$/;"	v
filearg_count	zip.c	/^long filearg_count = 0;$/;"	v
filecompress	zipup.c	/^local zoff_t filecompress(struct zlist far *z_entry, int *cmpr_method)$/;"	f	signature:(struct zlist far *z_entry, int *cmpr_method)
filelist	zip.c	/^struct filelist_struct *filelist = NULL;  \/* start of list *\/$/;"	v	typeref:struct:filelist_struct
filelist_struct	zip.c	/^struct filelist_struct {$/;"	s	file:
filelist_struct::name	zip.c	/^    char *name;$/;"	m	struct:filelist_struct	file:	access:public
filelist_struct::next	zip.c	/^    struct filelist_struct *next;$/;"	m	struct:filelist_struct	typeref:struct:filelist_struct::filelist_struct	file:	access:public
files	README	/^large files, but they currently do not handle split archives.  A work around$/;"	v
files	README.CR	/^  use encryption and compress regular disk files, you need not worry about$/;"	v
files	WHERE	/^   unz552dN.zip      NT4\/W2K\/XP\/2K3\/W9x (32-bit Intel) DLL, header files, docs$/;"	v
files	zip.txt	/^       or size of the OS file is different, adding  new  files,  and  deleting$/;"	v
files_so_far	globals.c	/^ulg files_so_far = 0;         \/* files processed so far *\/$/;"	v
files_total	globals.c	/^ulg files_total = 0;          \/* files total to process *\/$/;"	v
filesync	globals.c	/^int filesync = 0;       \/* 1=file sync, delete entries not on file system *\/$/;"	v
filetime	unix/unix.c	/^ulg filetime(f, a, n, t)$/;"	f
filetypes	zipup.c	/^local int filetypes(a, s)$/;"	f
fill_window	deflate.c	/^local void fill_window()$/;"	f
filter	fileio.c	/^int filter(name, casesensitive)$/;"	f
filter	zip.txt	/^       as  a filter, compressing standard input to standard output.  For exam-$/;"	v
filter_match_case	globals.c	/^int filter_match_case = 1;    \/* 1=match case when filter() *\/$/;"	v
filterlist	zip.c	/^struct filterlist_struct *filterlist = NULL;  \/* start of list *\/$/;"	v	typeref:struct:filterlist_struct
filterlist_struct	zip.c	/^struct filterlist_struct {$/;"	s	file:
filterlist_struct::flag	zip.c	/^    char flag;$/;"	m	struct:filterlist_struct	file:	access:public
filterlist_struct::next	zip.c	/^    struct filterlist_struct *next;$/;"	m	struct:filterlist_struct	typeref:struct:filterlist_struct::filterlist_struct	file:	access:public
filterlist_struct::pattern	zip.c	/^    char *pattern;$/;"	m	struct:filterlist_struct	file:	access:public
filterlist_to_patterns	zip.c	/^local int filterlist_to_patterns()$/;"	f
find_next_signature	zipfile.c	/^local int find_next_signature(f)$/;"	f
find_signature	zipfile.c	/^local int find_signature(f, signature)$/;"	f
finish	zip.c	/^local int finish(e)$/;"	f
fix	globals.c	/^int fix = 0;            \/* 1=fix the zip file, 2=FF, 3=ZipNote *\/$/;"	v
fixes	Betas_Readme.txt	/^We take suggestions, bug fixes, and patches at any time, so send them in.$/;"	v
flag	zip.c	/^    char flag;$/;"	m	struct:filterlist_struct	file:	access:public
flag_bit	trees.c	/^local uch flag_bit;         \/* current bit used in flags *\/$/;"	v
flag_buf	trees.c	/^local uch near flag_buf[(LIT_BUFSIZE\/8)];$/;"	v
flags	trees.c	/^local uch flags;            \/* current flags not yet saved in flag_buf *\/$/;"	v
flg	zip.h	/^  ush vem, ver, flg, how;$/;"	m	struct:zlist	access:public
flist	zip.h	/^struct flist {$/;"	s
flist::dosflag	zip.h	/^  int dosflag;                  \/* Set to force MSDOS file attributes *\/$/;"	m	struct:flist	access:public
flist::iname	zip.h	/^  char *iname;                  \/* Internal file name after cleanup *\/$/;"	m	struct:flist	access:public
flist::inamew	zip.h	/^  wchar_t *inamew;              \/* Windows wide character version of iname *\/$/;"	m	struct:flist	access:public
flist::lst	zip.h	/^  struct flist far *far *lst;   \/* Pointer to link pointing here *\/$/;"	m	struct:flist	typeref:struct:flist::far	access:public
flist::name	zip.h	/^  char *name;                   \/* Raw internal file name *\/$/;"	m	struct:flist	access:public
flist::namew	zip.h	/^  wchar_t *namew;               \/* Windows wide character version of name *\/$/;"	m	struct:flist	access:public
flist::nxt	zip.h	/^  struct flist far *nxt;        \/* Link to next name *\/$/;"	m	struct:flist	typeref:struct:flist::far	access:public
flist::oname	zip.h	/^  char *oname;                  \/* Display version of internal name *\/$/;"	m	struct:flist	access:public
flist::uname	zip.h	/^  char *uname;                  \/* UTF-8 name *\/$/;"	m	struct:flist	access:public
flist::usize	zip.h	/^  uzoff_t usize;                \/* usize from initial scan *\/$/;"	m	struct:flist	access:public
flist::zname	zip.h	/^  char *zname;                  \/* External version of internal name *\/$/;"	m	struct:flist	access:public
flist::znamew	zip.h	/^  wchar_t *znamew;              \/* Windows wide character version of zname *\/$/;"	m	struct:flist	access:public
flush_block	trees.c	/^uzoff_t flush_block(buf, stored_len, eof)$/;"	f
flush_flg	trees.c	/^local int flush_flg;$/;"	v
flush_outbuf	zipup.c	/^void flush_outbuf(o_buf, o_idx)$/;"	f
fnxt	globals.c	/^struct flist far * far *fnxt = &found;$/;"	v	typeref:struct:far
force_zip64	globals.c	/^  int force_zip64 = -1;       \/* if 1 force entries to be zip64, 0 force not zip64 *\/$/;"	v
format	README	/^extended file attributes; conversion from Unix to MSDOS text file format; and,$/;"	v
format	tags	/^!_TAG_FILE_FORMAT	2	\/extended format; --format=1 will not append ;" to lines\/$/;"	v
found	globals.c	/^struct flist far *found = NULL;   \/* List of names found *\/$/;"	v	typeref:struct:far
fqcmp	fileio.c	/^local int fqcmp(a, b)$/;"	f
fqcmpz	fileio.c	/^local int fqcmpz(a, b)$/;"	f
free	zip.h	590;"	d
free_args	fileio.c	/^int free_args(args)$/;"	f
freeup	zip.c	/^local void freeup()$/;"	f
freq	trees.c	/^        ush  freq;       \/* frequency count *\/$/;"	m	union:ct_data::__anon3	file:	access:public
fseekable	util.c	/^int fseekable( fp)$/;"	f
ftype	unix/zipup.h	/^typedef int ftype;$/;"	t
functionality	LICENSE	/^       modified or added functionality, and dynamic, shared, or static library$/;"	v
functionality	tags	/^functionality	LICENSE	\/^       modified or added functionality, and dynamic, shared, or static library$\/;"	v$/;"	v
functionality	tags	/^shared	LICENSE	\/^       modified or added functionality, and dynamic, shared, or static library$\/;"	v$/;"	v
gen_bitlen	trees.c	/^local void gen_bitlen(desc)$/;"	f
gen_codes	trees.c	/^local void gen_codes (tree, max_code)$/;"	f
generate_transitions	timezone.c	/^static void generate_transitions(sp, start, end)$/;"	f	file:
generic_gcc	INSTALL	/^     where "system" is one of:  generic, generic_gcc,$/;"	v
get_crc_table	crc32.c	/^ZCONST ulg near *get_crc_table OF((void))$/;"	f	signature:(void)
get_ef_ut_ztime	zipfile.c	/^int get_ef_ut_ztime(z, z_utim)$/;"	f
get_in_split_path	fileio.c	/^char *get_in_split_path(base_path, disk_number)$/;"	f
get_longopt	fileio.c	/^local unsigned long get_longopt(args, argnum, optchar, negated, value,$/;"	f
get_option	fileio.c	/^unsigned long get_option(pargs, argc, argnum, optchar, value,$/;"	f
get_out_split_path	fileio.c	/^char *get_out_split_path(base_path, disk_number)$/;"	f
get_shortopt	fileio.c	/^local unsigned long get_shortopt(args, argnum, optchar, negated, value,$/;"	f
getfileattr	fileio.c	/^int getfileattr(f)$/;"	f
getnam	fileio.c	/^char *getnam(fp)$/;"	f
getnum	timezone.c	/^static ZCONST char *getnum(strp, nump, min, max)$/;"	f	file:
getoffset	timezone.c	/^static ZCONST char *getoffset(strp, offsetp)$/;"	f	file:
getrule	timezone.c	/^static ZCONST char *getrule(strp, rulep)$/;"	f	file:
getsecs	timezone.c	/^static ZCONST char *getsecs(strp, secsp)$/;"	f	file:
getzname	timezone.c	/^static ZCONST char *getzname(strp)$/;"	f	file:
gmt	timezone.c	/^static ZCONST char  gmt[] = "GMT";$/;"	v	file:
gmtime	timezone.c	/^struct tm *gmtime(when)$/;"	f
go	zip30.ann	/^  information, such as how many entries processed and to go, how$/;"	v
go	zip30.ann	/^  many bytes processed and to go, and adjustable size progress$/;"	v
good_bytes_so_far	globals.c	/^uzoff_t good_bytes_so_far = 0;\/* good bytes read so far *\/$/;"	v
good_length	deflate.c	/^   ush good_length; \/* reduce lazy search above this match length *\/$/;"	m	struct:config	file:	access:public
good_match	deflate.c	/^unsigned near good_match;$/;"	v
greedy	zipsplit.c	/^local extent greedy(a, n, c, d)$/;"	f
handler	zip.c	/^local void handler(s)$/;"	f
handler	zipcloak.c	/^local void handler(sig)$/;"	f
handler	zipnote.c	/^local void handler(s)$/;"	f
handler	zipsplit.c	/^local void handler(s)$/;"	f
handling	CHANGES	/^ 2. win32 volumelabel handling (Paul)$/;"	f
have	README	/^   readable in what you have, zip -FF should be able to recover it.$/;"	v
head	deflate.c	/^  Pos    head[HASH_SIZE];$/;"	v
heap	trees.c	/^local int near heap[2*L_CODES+1]; \/* heap used to build the Huffman trees *\/$/;"	v
heap_len	trees.c	/^local int heap_len;               \/* number of elements in the heap *\/$/;"	v
heap_max	trees.c	/^local int heap_max;               \/* element of largest frequency *\/$/;"	v
help	zip.c	/^local void help()$/;"	f
help	zipcloak.c	/^local void help()$/;"	f
help	zipnote.c	/^local void help()$/;"	f
help	zipsplit.c	/^local void help()$/;"	f
help_extended	zip.c	/^local void help_extended()$/;"	f
help_info	zipcloak.c	/^static ZCONST char *help_info[] = {$/;"	v	file:
hidden_files	globals.c	/^int hidden_files = 0;         \/* process hidden and system files *\/$/;"	v
how	zip.h	/^  ush vem, ver, flg, how;$/;"	m	struct:zlist	access:public
however	INSTALL	/^  set the flags appropriately.  In some cases, however, you may need to$/;"	v
huge	tailor.h	469;"	d
huge	tailor.h	479;"	d
i386	unix/Packaging/README	/^   Where:  $(arch) := system architecture, currently i386, sparc, or ppc.$/;"	v
ibs	zip.txt	/^              dd if=\/dev\/nrst0  ibs=16k | funzip | tar xvf -$/;"	v
icount	globals.c	/^unsigned icount = 0;            \/* number of include only patterns *\/$/;"	v
ideal	INSTALL	/^     if you see optimization for your system is not ideal, send in$/;"	v
ifile	zipup.c	/^local ftype ifile;              \/* file to compress *\/$/;"	v
implementations	INSTALL	/^     free GNU C implementations, respectively.  More detailed instructions$/;"	v
in2ex	unix/unix.c	/^char *in2ex(n)$/;"	f
in_buf	zipup.c	/^local char *in_buf;$/;"	v
in_file	globals.c	/^FILE *in_file = NULL;         \/* current input file for splits *\/$/;"	v
in_offset	zipup.c	/^local unsigned in_offset;$/;"	v
in_path	globals.c	/^char *in_path = NULL;         \/* base name of input archive file *\/$/;"	v
in_size	zipup.c	/^local unsigned in_size;     \/* size of current input buffer *\/$/;"	v
in_split_path	globals.c	/^char *in_split_path = NULL;   \/* in split path *\/$/;"	v
iname	zip.h	/^  char *iname;                  \/* Internal file name after cleanup (stored in archive) *\/$/;"	m	struct:zlist	access:public
iname	zip.h	/^  char *iname;                  \/* Internal file name after cleanup *\/$/;"	m	struct:flist	access:public
inameLocal	zipfile.c	1172;"	d	file:
inameLocal	zipfile.c	1176;"	d	file:
inameLocal	zipfile.c	1279;"	d	file:
inameLocal	zipfile.c	1283;"	d	file:
inamew	zip.h	/^  wchar_t *inamew;              \/* Windows wide character version of iname *\/$/;"	m	struct:flist	access:public
inamew	zip.h	/^  wchar_t *inamew;              \/* Windows wide character version of iname *\/$/;"	m	struct:zlist	access:public
inaries	LICENSE	/^       be misrepresented as being the original source or, if binaries,$/;"	v	file:
indexmade	zipsplit.c	/^local int indexmade = 0;        \/* true if index file made *\/$/;"	v
indll	CHANGES	/^ 7. Updated VB examples for windll (Mike)$/;"	f
init_block	trees.c	/^local void init_block()$/;"	f
init_keys	crypt.h	59;"	d
init_upper	util.c	/^void init_upper()$/;"	f
input	zip.txt	/^       pressed,  in  which  case  it  will  read the file from standard input,$/;"	v
input_len	trees.c	/^local uzoff_t input_len;        \/* total byte length of input file *\/$/;"	v
ins_h	deflate.c	/^local unsigned ins_h;  \/* hash index of string to be inserted *\/$/;"	v
insert_arg	fileio.c	/^int insert_arg(pargs, arg, at_arg, free_args)$/;"	f
interfaces	LICENSE	/^       systems, existing ports with new graphical interfaces, versions with$/;"	v
interfaces	tags	/^systems	LICENSE	\/^       systems, existing ports with new graphical interfaces, versions with$\/;"	v$/;"	v
invalid	globals.o	/^/;"	v
is_ascii_string	fileio.c	/^int is_ascii_string(mbstring)$/;"	f
is_seekable	zipup.c	/^int is_seekable(y)$/;"	f
is_signature	zipfile.c	/^local int is_signature(sig1, sig2)$/;"	f
is_text_buf	util.c	/^int is_text_buf(buf_ptr, buf_size)$/;"	f
isize	zipup.c	/^local zoff_t isize;         \/* input file size. global only for debugging *\/$/;"	v
isize	zipup.c	/^zoff_t isize;               \/* input file size. global only for debugging *\/$/;"	v
iso2oem	ebcdic.h	/^ZCONST uch Far iso2oem[] = {$/;"	v
isshexp	util.c	/^char *isshexp(p)$/;"	f
issymlnk	fileio.c	/^int issymlnk(a)$/;"	f
iztimes	zip.h	/^typedef struct iztimes {$/;"	s
iztimes	zip.h	/^} iztimes;$/;"	t	typeref:struct:iztimes
iztimes::atime	zip.h	/^   time_t atime;                \/* new access time *\/$/;"	m	struct:iztimes	access:public
iztimes::ctime	zip.h	/^   time_t ctime;                \/* new creation time (!= Unix st.ctime) *\/$/;"	m	struct:iztimes	access:public
iztimes::mtime	zip.h	/^   time_t mtime;                \/* new modification time *\/$/;"	m	struct:iztimes	access:public
junk_sfx	zip.c	/^local int junk_sfx = 0; \/* 1=junk the sfx prefix *\/$/;"	v
key	globals.c	/^char *key = NULL;       \/* Scramble password if scrambling *\/$/;"	v
keys	crypt.c	/^   local z_uint4 keys[3];       \/* keys defining the pseudo-random sequence *\/$/;"	v
l_buf	trees.c	/^  local uch far *l_buf;$/;"	v
l_buf	trees.c	/^  local uch far l_buf[LIT_BUFSIZE];  \/* buffer for literals\/lengths *\/$/;"	v
l_desc	trees.c	/^local tree_desc near l_desc =$/;"	v
label	fileio.c	/^char *label = NULL;                \/* global, but only used in `system'.c *\/$/;"	v
label_mode	unix/unix.c	/^local ulg label_mode = 0;$/;"	v
label_time	unix/unix.c	/^local ulg label_time = 0;$/;"	v
label_utim	unix/unix.c	/^local time_t label_utim = 0;$/;"	v
last	fileio.c	/^char *last(p, c)$/;"	f
last_dist	trees.c	/^local unsigned last_dist;   \/* running index in d_buf *\/$/;"	v
last_flags	trees.c	/^local unsigned last_flags;  \/* running index in flag_buf *\/$/;"	v
last_lit	trees.c	/^local unsigned last_lit;    \/* running index in l_buf *\/$/;"	v
lastchar	tailor.h	361;"	d
lastfile	zip.c	/^struct filelist_struct *lastfile = NULL;  \/* last file in list *\/$/;"	v	typeref:struct:filelist_struct
lastfilter	zip.c	/^struct filterlist_struct *lastfilter = NULL;  \/* last filter in list *\/$/;"	v	typeref:struct:filterlist_struct
latest	zip.c	/^local int latest = 0;   \/* 1=set zip file time to time of latest file *\/$/;"	v
leap	timezone.c	79;"	d	file:
len	trees.c	/^        ush  len;        \/* length of bit string *\/$/;"	m	union:ct_data::__anon4	file:	access:public
len	zip.h	/^  uzoff_t siz, len;             \/* zip64 support 08\/29\/2003 R.Nausedat *\/$/;"	m	struct:zlist	access:public
length_code	trees.c	/^local uch length_code[MAX_MATCH-MIN_MATCH+1];$/;"	v
level	globals.c	/^int level = 6;          \/* 0=fastest compression, 9=best compression *\/$/;"	v
lf	unix/configure	/^          lf='-Wl,-search_paths_first'$/;"	v
lflg	zip.h	/^  ush att, lflg;                \/* offset of lflg must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
lib$establish	zip.h	361;"	d
lib$get_foreign	zip.h	362;"	d
lib$get_input	zip.h	363;"	d
lib$sig_to_ret	zip.h	364;"	d
library$	tags	/^functionality	LICENSE	\/^       modified or added functionality, and dynamic, shared, or static library$\/;"	v$/;"	v	file:
library$	tags	/^shared	LICENSE	\/^       modified or added functionality, and dynamic, shared, or static library$\/;"	v$/;"	v	file:
license	zip.c	/^local void license()$/;"	f
license	zipcloak.c	/^local void license()$/;"	f
license	zipnote.c	/^local void license()$/;"	f
license	zipsplit.c	/^local void license()$/;"	f
lines	zip30.ann	/^  more readable command lines, and also allows lists for the -x$/;"	v
linkput	globals.c	/^int linkput = 0;              \/* 1=store symbolic links as such *\/$/;"	v
lm_free	deflate.c	/^void lm_free()$/;"	f
lm_init	deflate.c	/^void lm_init (pack_level, flags)$/;"	f
local	zip.h	82;"	d
local_to_display_string	fileio.c	/^char *local_to_display_string(local_string)$/;"	f
local_to_escape_string	fileio.c	/^char *local_to_escape_string(local_string)$/;"	f
local_to_utf8_string	fileio.c	/^char *local_to_utf8_string(local_string)$/;"	f
local_to_wide_string	fileio.c	/^zwchar *local_to_wide_string(local_string)$/;"	f
localtime	timezone.c	/^struct tm *localtime(when)$/;"	f
logall	globals.c	/^int logall = 0;               \/* 0 = warnings\/errors, 1 = all *\/$/;"	v
logfile	globals.c	/^FILE *logfile = NULL;         \/* pointer to open logfile or NULL *\/$/;"	v
logfile_append	globals.c	/^int logfile_append = 0;       \/* append to existing logfile *\/$/;"	v
logfile_line_started	globals.c	/^int logfile_line_started = 0;     \/* 1=started writing a line to logfile *\/$/;"	v
logfile_path	globals.c	/^char *logfile_path = NULL;    \/* pointer to path of logfile *\/$/;"	v
long_op_ambig_err	fileio.c	/^static ZCONST char Far long_op_ambig_err[] = "long option '%s' ambiguous";$/;"	v	file:
long_op_not_sup_err	fileio.c	/^static ZCONST char Far long_op_not_sup_err[] = "long option '%s' not supported";$/;"	v	file:
longest_match	deflate.c	/^int longest_match(cur_match)$/;"	f
longopt	zip.h	/^  char Far *longopt;        \/* char * to long option string *\/$/;"	m	struct:option_struct	access:public
lookahead	deflate.c	/^local unsigned      lookahead;     \/* number of valid bytes ahead in window *\/$/;"	v
lower	util.c	/^uch upper[256], lower[256];$/;"	v
lst	zip.h	/^  struct flist far *far *lst;   \/* Pointer to link pointing here *\/$/;"	m	struct:flist	typeref:struct:flist::far	access:public
m	ttyio.c	/^    ZCONST char *m;             \/* prompt for password *\/$/;"	v
m	zipfile.c	/^  extent m;                 \/* length of zip file comment (0 if none) *\/$/;"	v
main	unix/configure	/^int main()$/;"	f
main	zip.c	/^int main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	zipcloak.c	/^int main()$/;"	f
main	zipcloak.c	/^int main(argc, argv)$/;"	f
main	zipnote.c	/^int main(argc, argv)$/;"	f
main	zipsplit.c	/^int main(argc, argv)$/;"	f
mark	zip.h	/^  int mark;                     \/* Marker for files to operate on *\/$/;"	m	struct:zlist	access:public
match_start	deflate.c	/^      unsigned near match_start;   \/* start of matching string *\/$/;"	v
matching	zip.txt	/^              pattern matching, and more obscure options.$/;"	v
max_chain	deflate.c	/^   ush max_chain;$/;"	m	struct:config	file:	access:public
max_chain_length	deflate.c	/^unsigned near max_chain_length;$/;"	v
max_code	trees.c	/^    int     max_code;            \/* largest code with non zero frequency *\/$/;"	m	struct:tree_desc	file:	access:public
max_insert_length	deflate.c	174;"	d	file:
max_lazy	deflate.c	/^   ush max_lazy;    \/* do not perform lazy search above this match length *\/$/;"	m	struct:config	file:	access:public
max_lazy_match	deflate.c	/^local unsigned int max_lazy_match;$/;"	v
max_length	trees.c	/^    int     max_length;          \/* max bit length for the codes *\/$/;"	m	struct:tree_desc	file:	access:public
mem_read	zipup.c	/^local unsigned mem_read(b, bsize)$/;"	f
memcompress	zipup.c	/^ulg memcompress(tgt, tgtsize, src, srcsize)$/;"	f
mesg	globals.c	/^FILE *mesg;             \/* stdout by default, stderr for piping *\/$/;"	v
mesg_line_started	globals.c	/^int mesg_line_started = 0;        \/* 1=started writing a line to mesg *\/$/;"	v
method	globals.c	/^int method = BEST;      \/* one of BEST, DEFLATE (only), or STORE (only) *\/$/;"	v
minix	INSTALL	/^     att6300, coherent, cray_v3, minix, sco_x286, xenix, zilog.$/;"	v
missed	zip.txt	/^              archive are missed, then try$/;"	v
missing	zip.txt	/^              this file is missing, you must use -FF to fix the archive, which$/;"	v
mkgmtime	timezone.c	/^time_t mkgmtime(tm)$/;"	f
mktime	timezone.c	/^time_t mktime(tm)$/;"	f
mode	zip.txt	/^       The new File Sync option (-FS) is also considered a new mode, though it$/;"	v
modtime	tailor.h	/^    time_t modtime;             \/* new modification time *\/$/;"	m	struct:ztimbuf	access:public
mon_lengths	timezone.c	/^static ZCONST int    mon_lengths[2][MONSPERYEAR] = {$/;"	v	file:
monthlen	timezone.c	88;"	d	file:
msname	fileio.c	/^char *msname(n)$/;"	f
msnamew	fileio.c	/^wchar_t *msnamew(nw)$/;"	f
mtime	zip.h	/^   time_t mtime;                \/* new modification time *\/$/;"	m	struct:iztimes	access:public
n	ttyio.c	/^    int n;                      \/* bytes available in p[] *\/$/;"	v
nam	zip.h	/^  ush nam, ext, cext, com;      \/* offset of ext must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
name	zip.c	/^    char *name;$/;"	m	struct:filelist_struct	file:	access:public
name	zip.h	/^  char *name;                   \/* File name in zip file *\/$/;"	m	struct:zlist	access:public
name	zip.h	/^  char *name;                   \/* Raw internal file name *\/$/;"	m	struct:flist	access:public
name	zip.h	/^  char Far *name;           \/* optional string for option returned on some errors *\/$/;"	m	struct:option_struct	access:public
name	zip.txt	/^       where the option starts with --, has a multicharacter name, can include$/;"	v
name	ziperr.h	/^    char *name;$/;"	m	struct:__anon1	access:public
name	ziperr.h	/^    char *name;$/;"	m	struct:__anon2	access:public
name	zipsplit.c	/^local char *name;               \/* where name goes in path[] *\/$/;"	v
name$	tags	/^archive	man\/zip.1	\/^In cmd, {} is replaced by the name of the temporary archive, otherwise the name$\/;"	v$/;"	v
namecmp	util.c	/^int namecmp(string1, string2)$/;"	f
namew	zip.h	/^  wchar_t *namew;               \/* Windows wide character version of name *\/$/;"	m	struct:flist	access:public
namew	zip.h	/^  wchar_t *namew;               \/* Windows wide character version of name *\/$/;"	m	struct:zlist	access:public
near	tailor.h	471;"	d
near	tailor.h	475;"	d
near	tailor.h	485;"	d
nearfree	tailor.h	489;"	d
nearmalloc	tailor.h	488;"	d
needed	zip30f.ann	/^  files on the file system, adding, updating, and deleting entries as needed,$/;"	v
negatable	zip.h	/^  int  negatable;           \/* from above *\/$/;"	m	struct:option_struct	access:public
newname	fileio.c	/^int newname(name, isdir, casesensitive)$/;"	f
next	zip.c	/^    struct filelist_struct *next;$/;"	m	struct:filelist_struct	typeref:struct:filelist_struct::filelist_struct	file:	access:public
next	zip.c	/^    struct filterlist_struct *next;$/;"	m	struct:filterlist_struct	typeref:struct:filterlist_struct::filterlist_struct	file:	access:public
nice_length	deflate.c	/^   ush nice_length; \/* quit search above this match length *\/$/;"	m	struct:config	file:	access:public
nice_match	deflate.c	/^  int near nice_match; \/* Stop searching when current match exceeds this *\/$/;"	v
nleap	timezone.c	85;"	d	file:
no_arg_files_err	fileio.c	/^static ZCONST char Far no_arg_files_err[] = "argument files not enabled\\n";$/;"	v	file:
no_wild	globals.c	/^int no_wild = 0;             \/* 1 = wildcards are disabled *\/$/;"	v
noisy	globals.c	/^int noisy = 1;                \/* 0=quiet operation *\/$/;"	v
noisy_splits	globals.c	/^int noisy_splits = 0;             \/* note when splits are being created *\/$/;"	v
now	README.CR	/^source distributions for all of these now, but the encryption patch is still$/;"	v
null	unix/configure	/^  if \/usr\/bin\/hostinfo | grep NeXT > \/dev\/null; then$/;"	v
num_req_val_err	fileio.c	/^static ZCONST char Far num_req_val_err[] = "option %s requires number value";$/;"	v	file:
nxt	zip.h	/^  struct flist far *nxt;        \/* Link to next name *\/$/;"	m	struct:flist	typeref:struct:flist::far	access:public
nxt	zip.h	/^  struct zlist far *nxt;        \/* Pointer to next header in list *\/$/;"	m	struct:zlist	typeref:struct:zlist::far	access:public
oERR	fileio.c	2571;"	d	file:
oWARN	fileio.c	2570;"	d	file:
o_AC	zip.c	1250;"	d	file:
o_ARG_FILE_ERR	zip.h	1022;"	d
o_AS	zip.c	1251;"	d	file:
o_C2	zip.c	1252;"	d	file:
o_C5	zip.c	1253;"	d	file:
o_DF	zip.c	1259;"	d	file:
o_FF	zip.c	1264;"	d	file:
o_FI	zip.c	1265;"	d	file:
o_FS	zip.c	1266;"	d	file:
o_MM	zip.c	1275;"	d	file:
o_NEGATABLE	zip.h	1013;"	d
o_NON_OPTION_ARG	zip.h	1020;"	d
o_NOT_NEGATABLE	zip.h	1012;"	d
o_NO_OPTION_MATCH	zip.h	1017;"	d
o_NO_VALUE	zip.h	1003;"	d
o_NUMBER_VALUE	zip.h	1008;"	d
o_ONE_CHAR_VALUE	zip.h	1007;"	d
o_OPTIONAL_VALUE	zip.h	1005;"	d
o_RE	zip.c	1277;"	d	file:
o_REQUIRED_VALUE	zip.h	1004;"	d
o_TT	zip.c	1288;"	d	file:
o_UN	zip.c	1289;"	d	file:
o_VALUE_LIST	zip.h	1006;"	d
o_VV	zip.c	1291;"	d	file:
o_db	zip.c	1254;"	d	file:
o_dc	zip.c	1255;"	d	file:
o_dd	zip.c	1256;"	d	file:
o_des	zip.c	1257;"	d	file:
o_df	zip.c	1258;"	d	file:
o_dg	zip.c	1260;"	d	file:
o_ds	zip.c	1261;"	d	file:
o_du	zip.c	1262;"	d	file:
o_dv	zip.c	1263;"	d	file:
o_h2	zip.c	1267;"	d	file:
o_ic	zip.c	1268;"	d	file:
o_jj	zip.c	1269;"	d	file:
o_la	zip.c	1270;"	d	file:
o_lf	zip.c	1271;"	d	file:
o_li	zip.c	1272;"	d	file:
o_ll	zip.c	1273;"	d	file:
o_mm	zip.c	1274;"	d	file:
o_nw	zip.c	1276;"	d	file:
o_sU	zip.c	1285;"	d	file:
o_sb	zip.c	1278;"	d	file:
o_sc	zip.c	1279;"	d	file:
o_sd	zip.c	1280;"	d	file:
o_sf	zip.c	1281;"	d	file:
o_so	zip.c	1282;"	d	file:
o_sp	zip.c	1283;"	d	file:
o_su	zip.c	1284;"	d	file:
o_sv	zip.c	1286;"	d	file:
o_tt	zip.c	1287;"	d	file:
o_ve	zip.c	1290;"	d	file:
o_ws	zip.c	1292;"	d	file:
o_ww	zip.c	1293;"	d	file:
o_z64	zip.c	1294;"	d	file:
oco_no_mbc_err	fileio.c	/^static ZCONST char Far oco_no_mbc_err[] = "option %s does not support multibyte values";$/;"	v	file:
oco_req_val_err	fileio.c	/^static ZCONST char Far oco_req_val_err[] = "option %s requires one character value";$/;"	v	file:
oem2iso	ebcdic.h	/^ZCONST uch Far oem2iso[] = {$/;"	v
of	README	/^   of "unzip zipfile", to let unzip know which file is the zip archive$/;"	v
off	zip.h	/^  uzoff_t off;$/;"	m	struct:zlist	access:public
oname	zip.h	/^  char *oname;                  \/* Display version of internal name *\/$/;"	m	struct:flist	access:public
oname	zip.h	/^  char *oname;                  \/* Display version of name used in messages *\/$/;"	m	struct:zlist	access:public
op_no_allow_val_err	fileio.c	/^static ZCONST char Far op_no_allow_val_err[] = "option %s does not allow a value";$/;"	v	file:
op_not_neg_err	fileio.c	/^static ZCONST char Far op_not_neg_err[] = "option %s not negatable";$/;"	v	file:
op_req_val_err	fileio.c	/^static ZCONST char Far op_req_val_err[] = "option %s requires a value";$/;"	v	file:
opt_len	trees.c	/^local ulg opt_len;        \/* bit length of current block with optimal trees *\/$/;"	v
option	README.CR	/^      option; the dummy files may be newer than the real sources in$/;"	v
option_ID	zip.h	/^  unsigned long option_ID;  \/* value returned by get_option when this option is found *\/$/;"	m	struct:option_struct	access:public
option_struct	zip.h	/^struct option_struct {$/;"	s
option_struct::longopt	zip.h	/^  char Far *longopt;        \/* char * to long option string *\/$/;"	m	struct:option_struct	access:public
option_struct::name	zip.h	/^  char Far *name;           \/* optional string for option returned on some errors *\/$/;"	m	struct:option_struct	access:public
option_struct::negatable	zip.h	/^  int  negatable;           \/* from above *\/$/;"	m	struct:option_struct	access:public
option_struct::option_ID	zip.h	/^  unsigned long option_ID;  \/* value returned by get_option when this option is found *\/$/;"	m	struct:option_struct	access:public
option_struct::shortopt	zip.h	/^  char *shortopt;           \/* char * to sequence of char that is short option *\/$/;"	m	struct:option_struct	access:public
option_struct::value_type	zip.h	/^  int  value_type;          \/* from above *\/$/;"	m	struct:option_struct	access:public
optionerr	fileio.c	/^local int optionerr(buf, err, optind, islong)$/;"	f
optionerrbuf	fileio.c	/^local char Far optionerrbuf[OPTIONERR_BUF_SIZE + 1];$/;"	v
options	zip.c	/^struct option_struct far options[] = {$/;"	v	typeref:struct:far
options	zipcloak.c	/^struct option_struct far options[] = {$/;"	v	typeref:struct:far
options	zipnote.c	/^struct option_struct far options[] = {$/;"	v	typeref:struct:far
options	zipsplit.c	/^struct option_struct far options[] = {$/;"	v	typeref:struct:far
or	README	/^favorite port is broke, send us the details or, better, send bug fixes.  It's$/;"	v
ots$cvt_tu_l	zip.h	365;"	d
ouname	zip.h	/^  char *ouname;                 \/* Display version of zuname *\/$/;"	m	struct:zlist	access:public
out_buf	trees.c	/^char *out_buf;$/;"	v
out_buf	trees.c	/^local char *out_buf;$/;"	v
out_offset	trees.c	/^local unsigned out_offset;$/;"	v
out_offset	trees.c	/^unsigned out_offset;$/;"	v
out_path	globals.c	/^char *out_path = NULL;        \/* base name of output file, usually same as zipfile *\/$/;"	v
out_size	trees.c	/^local unsigned out_size;$/;"	v
out_size	trees.c	/^unsigned out_size;$/;"	v
output_seekable	globals.c	/^int output_seekable = 1;      \/* 1 = output seekable 3\/13\/05 EG *\/$/;"	v
p	ttyio.c	/^    char *p;                    \/* return value: line input *\/$/;"	v
package	unix/Packaging/README	/^installable package files for the package, IZzip.$/;"	v
passwd	crypt.c	/^    ZCONST char *passwd;        \/* password string with which to modify keys *\/$/;"	v
path	zipsplit.c	/^local char *path = NULL;        \/* space for full name *\/$/;"	v
pathput	globals.c	/^int pathput = 1;        \/* 1=store path with name *\/$/;"	v
paths	WHATSNEW	/^  Zip on WIN32 now stores OEM paths, which should be more compatible$/;"	v
paths	zip.txt	/^              and OS paths, and is preferred.$/;"	v
pattern	zip.c	/^    char *pattern;$/;"	m	struct:filterlist_struct	file:	access:public
patterns	globals.c	/^struct plist *patterns = NULL;  \/* List of patterns to be matched *\/$/;"	v	typeref:struct:plist
pcount	globals.c	/^unsigned pcount = 0;            \/* number of patterns *\/$/;"	v
percent	zipup.c	/^int percent(n, m)$/;"	f
plist	zip.h	/^struct plist {$/;"	s
plist::select	zip.h	/^  int select;                   \/* Selection flag ('i' or 'x') *\/$/;"	m	struct:plist	access:public
plist::zname	zip.h	/^  char *zname;                  \/* External version of internal name *\/$/;"	m	struct:plist	access:public
plit	zip.txt	/^       reads  archive  inarchive.zip,  even if split, adds the files foo.c and$/;"	v
ports	README	/^ports, large file and Zip64 support is automatically checked for and$/;"	v
ports	WHATSNEW	/^  all ports, that can result in a 10 times increase in speed in some cases$/;"	v
pqdownheap	trees.c	/^local void pqdownheap(tree, k)$/;"	f
pqremove	trees.c	571;"	d	file:
prev	deflate.c	/^  Pos    prev[WSIZE];$/;"	v
prev_length	deflate.c	/^unsigned int near prev_length;$/;"	v
proc_archive_name	fileio.c	/^int proc_archive_name(n, caseflag)$/;"	f
procedures	WHATSNEW	/^release information, INSTALL for installation procedures, and the manual$/;"	v
process	INSTALL	/^     To initiate the actual compiling process, you have to specify$/;"	v
processed	zip.txt	/^       progress  dots  every  2  seconds  or  every so many entries processed,$/;"	v
procname	unix/unix.c	/^int procname(n, caseflag)$/;"	f
public	zipcloak.c	/^static ZCONST char *public[] = {$/;"	v	file:
putcentral	zipfile.c	/^int putcentral(z)$/;"	f
putclean	zipnote.c	/^local void putclean(s, n)$/;"	f
putextended	zipfile.c	/^int putextended(z)$/;"	f
putlocal	zipfile.c	/^int putlocal(z, rewrite)$/;"	f
r_day	timezone.h	/^    int             r_day;      \/* day number of rule *\/$/;"	m	struct:rule	access:public
r_mon	timezone.h	/^    int             r_mon;      \/* month number of rule *\/$/;"	m	struct:rule	access:public
r_time	timezone.h	/^    long            r_time;     \/* transition time of rule *\/$/;"	m	struct:rule	access:public
r_type	timezone.h	/^    int             r_type;     \/* type of rule--JULIAN_DAY etc *\/$/;"	m	struct:rule	access:public
r_week	timezone.h	/^    int             r_week;     \/* week number of rule *\/$/;"	m	struct:rule	access:public
rdsymlnk	zip.h	698;"	d
rdsymlnk	zip.h	701;"	d
read	globals.o	/^/;"	v
read	zip30f.ann	/^  so many bytes read, settable from KB to TB, allowing progress to be$/;"	v
read_Unicode_Path_entry	zipfile.c	/^local void read_Unicode_Path_entry(pZipListEntry)$/;"	f
read_Unicode_Path_local_entry	zipfile.c	/^local void read_Unicode_Path_local_entry(pZipListEntry)$/;"	f
read_buf	zipup.c	/^unsigned (*read_buf) OF((char *buf, unsigned size)) = file_read;$/;"	v
read_split_archive	globals.c	/^int read_split_archive = 0;       \/* 1=scanzipf_reg detected spanning signature *\/$/;"	v
readd	unix/unix.c	/^local char *readd(d)$/;"	f
readlocal	zipfile.c	/^int readlocal(localz, z)$/;"	f
readzipfile	zipfile.c	/^int readzipfile()$/;"	f
real_timezone_is_set	timezone.c	/^int real_timezone_is_set = FALSE;       \/* set by tzset() *\/$/;"	v
recmatch	util.c	/^local int recmatch(p, s, cs)$/;"	f
recurse	globals.c	/^int recurse = 0;        \/* 1=recurse into directories encountered *\/$/;"	v
releases	Betas_Readme.txt	/^All code, including releases, are released under the Info-ZIP license.$/;"	v
remain	zipup.c	/^local ulg remain;$/;"	v
rename_split	zip.c	/^int rename_split(temp_name, out_path)$/;"	f
rename_split	zipcloak.c	/^int rename_split(temp_name, out_path)$/;"	f
rename_split	zipnote.c	/^int rename_split(temp_name, out_path)$/;"	f
rename_split	zipsplit.c	/^int rename_split(temp_name, out_path)$/;"	f
repe	match.S	/^        repe;   cmpsw                   \/* loop until mismatch *\/$/;"	v
replace	fileio.c	/^int replace(d, s)$/;"	f
required	man/zip.1	/^archive is named \\fBarchive\\fP and three splits are required, the resulting$/;"	v
resulting$	tags	/^required	man\/zip.1	\/^archive is named \\\\fBarchive\\\\fP and three splits are required, the resulting$\/;"	v$/;"	v
retry	zipsplit.c	/^local int retry()$/;"	f
rqcmp	zipfile.c	/^local int rqcmp(a, b)$/;"	f
rule	timezone.h	/^struct rule {$/;"	s
rule::r_day	timezone.h	/^    int             r_day;      \/* day number of rule *\/$/;"	m	struct:rule	access:public
rule::r_mon	timezone.h	/^    int             r_mon;      \/* month number of rule *\/$/;"	m	struct:rule	access:public
rule::r_time	timezone.h	/^    long            r_time;     \/* transition time of rule *\/$/;"	m	struct:rule	access:public
rule::r_type	timezone.h	/^    int             r_type;     \/* type of rule--JULIAN_DAY etc *\/$/;"	m	struct:rule	access:public
rule::r_week	timezone.h	/^    int             r_week;     \/* week number of rule *\/$/;"	m	struct:rule	access:public
rules	TODO	/^- zip and unzip should use the same pattern matching rules, particularly$/;"	v
s	zipfile.c	/^  uzoff_t s;                \/* size of central directory *\/$/;"	v
safer	zip.txt	/^              a  new  archive name is safer, avoids mismatches between archive$/;"	v
scan_count	globals.c	/^uzoff_t scan_count = 0; \/* Used for Scanning files ... message *\/$/;"	v
scan_delay	globals.c	/^time_t scan_delay = 5;  \/* seconds before display Scanning files message *\/$/;"	v
scan_dot_time	globals.c	/^time_t scan_dot_time = 2; \/* time in seconds between Scanning files dots *\/$/;"	v
scan_last	globals.c	/^time_t scan_last = 0;   \/* time of last message *\/$/;"	v
scan_start	globals.c	/^time_t scan_start = 0;  \/* start of scan *\/$/;"	v
scan_started	globals.c	/^int scan_started = 0;   \/* scan has started *\/$/;"	v
scan_tree	trees.c	/^local void scan_tree (tree, max_code)$/;"	f
scanzipf_fixnew	zipfile.c	/^local int scanzipf_fixnew()$/;"	f
scanzipf_regnew	zipfile.c	/^local int scanzipf_regnew()$/;"	f
sco_x286	INSTALL	/^     att6300, coherent, cray_v3, minix, sco_x286, xenix, zilog.$/;"	v
sdos	CHANGES	/^ 3. use #elif constructions for msdos,os2 and win32 compiler detection (Onno)$/;"	v
search	util.c	/^zvoid far **search(b, a, n, cmp)$/;"	f
seconds	zip.txt	/^       process  (if  needed).  If this scan takes longer than about 5 seconds,$/;"	v
seekable	zipup.c	/^int seekable()$/;"	f
select	zip.h	/^  int select;                   \/* Selection flag ('i' or 'x') *\/$/;"	m	struct:plist	access:public
send_all_trees	trees.c	/^local void send_all_trees(lcodes, dcodes, blcodes)$/;"	f
send_bits	trees.c	/^local void send_bits(value, length)$/;"	f
send_code	trees.c	448;"	d	file:
send_code	trees.c	452;"	d	file:
send_tree	trees.c	/^local void send_tree (tree, max_code)$/;"	f
set	zip30f.ann	/^  Windows in the local OEM character set, as some other zips do$/;"	v
set_extra_field	unix/unix.c	/^int set_extra_field(z, z_utim)$/;"	f
set_file_type	trees.c	/^local void set_file_type()$/;"	f
set_filetype	zip.c	/^int set_filetype(char *out_path)$/;"	f	signature:(char *out_path)
set_filetype	zipcloak.c	/^int set_filetype(out_path)$/;"	f
set_filetype	zipnote.c	/^int set_filetype(out_path)$/;"	f
set_filetype	zipsplit.c	/^int set_filetype(out_path)$/;"	f
set_new_unix_extra_field	unix/unix.c	/^int set_new_unix_extra_field(z, s)$/;"	f
setfileattr	fileio.c	/^int setfileattr(f, a)$/;"	f
severity	ziperr.h	/^    int severity;$/;"	m	struct:__anon1	access:public
severity	ziperr.h	/^    int severity;$/;"	m	struct:__anon2	access:public
sg_flags	ttyio.c	51;"	d	file:
sgttyb	ttyio.c	50;"	d	file:
sh_op_not_sup_err	fileio.c	/^static ZCONST char Far sh_op_not_sup_err[] = "short option '%c' not supported";$/;"	v	file:
shared	LICENSE	/^       modified or added functionality, and dynamic, shared, or static library$/;"	v
shared	tags	/^functionality	LICENSE	\/^       modified or added functionality, and dynamic, shared, or static library$\/;"	v$/;"	v
shared	tags	/^shared	LICENSE	\/^       modified or added functionality, and dynamic, shared, or static library$\/;"	v$/;"	v
shell	TODO	/^- on NT with C shell, zip should not do file name expansion again.$/;"	v
shmatch	util.c	/^int shmatch(p, s, cs)$/;"	f
shortopt	zip.h	/^  char *shortopt;           \/* char * to sequence of char that is short option *\/$/;"	m	struct:option_struct	access:public
show_files	globals.c	/^int show_files = 0;           \/* show files to operate on and exit (=2 log only) *\/$/;"	v
sigbuf	zipfile.c	/^local char sigbuf[4];   \/* signature found *\/$/;"	v
simple	zipsplit.c	/^local extent simple(a, n, c, d)$/;"	f
siz	zip.h	/^  uzoff_t siz, len;             \/* zip64 support 08\/29\/2003 R.Nausedat *\/$/;"	m	struct:zlist	access:public
size	man/zip.1	/^archive reaches the specified split size, that split is closed and the next split$/;"	v
size_t	tailor.h	/^   typedef unsigned int size_t;$/;"	t
skip_current_disk	globals.c	/^ulg     skip_current_disk = 0;  \/* if != 0 and fix then skip entries on this disk *\/$/;"	v
skip_this_disk	globals.c	/^ulg skip_this_disk = 0;$/;"	v
sliding	deflate.c	/^local int sliding;$/;"	v
smaller	trees.c	582;"	d	file:
sparc	unix/Packaging/README	/^   Where:  $(arch) := system architecture, currently i386, sparc, or ppc.$/;"	v
special	globals.c	/^char *special = ".Z:.zip:.zoo:.arc:.lzh:.arj"; \/* List of special suffixes *\/$/;"	v
split_bell	globals.c	/^int split_bell = 0;               \/* when pause for next split ring bell *\/$/;"	v
split_method	globals.c	/^int split_method = 0;             \/* 0=no splits, 1=seekable, 2=data desc, -1=no *\/$/;"	v
split_size	globals.c	/^uzoff_t split_size = 0;           \/* how big each split should be *\/$/;"	v
stamp	unix/unix.c	/^void stamp(f, d)$/;"	f
state	timezone.h	/^struct state {$/;"	s
state::ats	timezone.h	/^    time_t          ats[TZ_MAX_TIMES];$/;"	m	struct:state	access:public
state::charcnt	timezone.h	/^    int             charcnt;$/;"	m	struct:state	access:public
state::chars	timezone.h	/^    char            chars[TZ_MAX_CHARS];$/;"	m	struct:state	access:public
state::timecnt	timezone.h	/^    int             timecnt;$/;"	m	struct:state	access:public
state::ttis	timezone.h	/^    struct ttinfo   ttis[TZ_MAX_TYPES];$/;"	m	struct:state	typeref:struct:state::ttinfo	access:public
state::typecnt	timezone.h	/^    int             typecnt;$/;"	m	struct:state	access:public
state::types	timezone.h	/^    unsigned char   types[TZ_MAX_TIMES];$/;"	m	struct:state	access:public
static_dtree	trees.c	/^local ct_data near static_dtree[D_CODES];$/;"	v
static_len	trees.c	/^local ulg static_len;     \/* bit length of current block with static trees *\/$/;"	v
static_ltree	trees.c	/^local ct_data near static_ltree[L_CODES+2];$/;"	v
static_tree	trees.c	/^    ct_data near *static_tree;   \/* corresponding static tree or NULL *\/$/;"	m	struct:tree_desc	file:	access:public
statism	timezone.c	/^static struct state statism;$/;"	v	typeref:struct:state	file:
stderr	zip.h	561;"	d
stderr	zip.h	562;"	d
stores	zip.txt	/^       port wide characters, zip now stores, in addition to the standard local$/;"	v
str$concat	zip.h	366;"	d
str$find_first_substring	zip.h	367;"	d
str$free1_dx	zip.h	368;"	d
strchr	tailor.h	260;"	d
string	ziperr.h	/^    char *string;$/;"	m	struct:__anon1	access:public
string	ziperr.h	/^    char *string;$/;"	m	struct:__anon2	access:public
strrchr	tailor.h	256;"	d
strstart	deflate.c	/^      unsigned near strstart;      \/* start of string to insert *\/$/;"	v
suffixes	zipup.c	/^local int suffixes(a, s)$/;"	f
support	WHERE	/^     Zip 2.31 release, all official binaries include encryption support; the$/;"	v
swlicense	revision.h	/^ZCONST char * far swlicense[] = {$/;"	v
sys$asctim	zip.h	369;"	d
sys$assign	zip.h	370;"	d
sys$bintim	zip.h	371;"	d
sys$close	zip.h	372;"	d
sys$connect	zip.h	373;"	d
sys$dassgn	zip.h	374;"	d
sys$display	zip.h	375;"	d
sys$getjpiw	zip.h	376;"	d
sys$open	zip.h	377;"	d
sys$parse	zip.h	378;"	d
sys$qiow	zip.h	379;"	d
sys$read	zip.h	380;"	d
sys$search	zip.h	381;"	d
system	WHATSNEW	/^  system, adding updating, and deleting entries as needed.  This$/;"	v
systems	LICENSE	/^       systems, existing ports with new graphical interfaces, versions with$/;"	v
systems	tags	/^systems	LICENSE	\/^       systems, existing ports with new graphical interfaces, versions with$\/;"	v$/;"	v
tHH	deflate.o	/^ELF/;"	v
talln	zipsplit.c	/^int talln = 0;          \/* number of entries in talls[] *\/$/;"	v
talloc	zipsplit.c	/^local zvoid *talloc(s)$/;"	f
talls	zipsplit.c	/^zvoid *talls[TMAX];     \/* malloc'ed pointers to track *\/$/;"	v
tempath	globals.c	/^char *tempath = NULL;   \/* Path for temporary files *\/$/;"	v
tempdir	zip.c	/^local int tempdir = 0;  \/* 1=use temp directory (-b) *\/$/;"	v
template	zipsplit.c	/^local char template[TEMPL_SIZ]; \/* name template for output files *\/$/;"	v
tempname	fileio.c	/^char *tempname(zip)$/;"	f
tempzf	zipcloak.c	/^local FILE *tempzf;$/;"	v
tempzf	zipnote.c	/^local FILE *tempzf;$/;"	v
tempzip	globals.c	/^char *tempzip = NULL;         \/* name of temp file *\/$/;"	v
tempzn	globals.c	/^uzoff_t tempzn;               \/* Count of bytes written to output zip files *\/$/;"	v
test	zip.c	/^local int test = 0;     \/* 1=test zip file with unzip -t *\/$/;"	v
testers	README	/^UnZip utility) development, join the ranks of BETA testers, add your own$/;"	v
tfree	zipsplit.c	/^local void tfree(p)$/;"	f
tfreeall	zipsplit.c	/^local void tfreeall()$/;"	f
then	INSTALL	/^     the sources.  First step, then, is to unpack Zip.  The following$/;"	v
tim	zip.h	/^  ulg tim, crc;$/;"	m	struct:zlist	access:public
time	Betas_Readme.txt	/^We take suggestions, bug fixes, and patches at any time, so send them in.$/;"	v
time_t	tailor.h	/^   typedef long time_t;$/;"	t
timecnt	timezone.h	/^    int             timecnt;$/;"	m	struct:state	access:public
timezone	timezone.c	/^long timezone = 0;$/;"	v
to	LICENSE	/^       limited to, labeling of the altered versions with the names "Info-ZIP"$/;"	v	file:
to	LICENSE	/^    3. Altered versions--including, but not limited to, ports to new operating$/;"	v
to	tags	/^to	LICENSE	\/^       limited to, labeling of the altered versions with the names "Info-ZIP"$\/;"	v	file:$/;"	v
to_up	tailor.h	213;"	d
to_up	tailor.h	216;"	d
total_cd_entries	globals.c	/^uzoff_t total_cd_entries = 0;     \/* total cd entries in new\/updated archive *\/$/;"	v
total_disks	globals.c	/^ulg     total_disks = 0;        \/* total disks in archive *\/$/;"	v
translate_eol	globals.c	/^int translate_eol = 0;  \/* Translate end-of-line LF -> CR LF *\/$/;"	v
transtime	timezone.c	/^static time_t transtime(janfirst, year, rulep, offset)$/;"	f	file:
trash	zip.h	/^  int trash;                    \/* Marker for files to delete *\/$/;"	m	struct:zlist	access:public
trash	zipfile.c	/^int trash()$/;"	f
tree_desc	trees.c	/^typedef struct tree_desc {$/;"	s	file:
tree_desc	trees.c	/^} tree_desc;$/;"	t	typeref:struct:tree_desc	file:
tree_desc::dyn_tree	trees.c	/^    ct_data near *dyn_tree;      \/* the dynamic tree *\/$/;"	m	struct:tree_desc	file:	access:public
tree_desc::elems	trees.c	/^    int     elems;               \/* max number of elements in the tree *\/$/;"	m	struct:tree_desc	file:	access:public
tree_desc::extra_base	trees.c	/^    int     extra_base;          \/* base index for extra_bits *\/$/;"	m	struct:tree_desc	file:	access:public
tree_desc::extra_bits	trees.c	/^    int     near *extra_bits;    \/* extra bits for each code or NULL *\/$/;"	m	struct:tree_desc	file:	access:public
tree_desc::max_code	trees.c	/^    int     max_code;            \/* largest code with non zero frequency *\/$/;"	m	struct:tree_desc	file:	access:public
tree_desc::max_length	trees.c	/^    int     max_length;          \/* max bit length for the codes *\/$/;"	m	struct:tree_desc	file:	access:public
tree_desc::static_tree	trees.c	/^    ct_data near *static_tree;   \/* corresponding static tree or NULL *\/$/;"	m	struct:tree_desc	file:	access:public
tt_abbrind	timezone.h	/^    int             tt_abbrind; \/* abbreviation list index *\/$/;"	m	struct:ttinfo	access:public
tt_gmtoff	timezone.h	/^    long            tt_gmtoff;  \/* UTC offset in seconds *\/$/;"	m	struct:ttinfo	access:public
tt_isdst	timezone.h	/^    int             tt_isdst;   \/* used to set tm_isdst *\/$/;"	m	struct:ttinfo	access:public
ttinfo	timezone.h	/^struct ttinfo {$/;"	s
ttinfo::tt_abbrind	timezone.h	/^    int             tt_abbrind; \/* abbreviation list index *\/$/;"	m	struct:ttinfo	access:public
ttinfo::tt_gmtoff	timezone.h	/^    long            tt_gmtoff;  \/* UTC offset in seconds *\/$/;"	m	struct:ttinfo	access:public
ttinfo::tt_isdst	timezone.h	/^    int             tt_isdst;   \/* used to set tm_isdst *\/$/;"	m	struct:ttinfo	access:public
ttis	timezone.h	/^    struct ttinfo   ttis[TZ_MAX_TYPES];$/;"	m	struct:state	typeref:struct:state::ttinfo	access:public
typecnt	timezone.h	/^    int             typecnt;$/;"	m	struct:state	access:public
types	timezone.h	/^    unsigned char   types[TZ_MAX_TIMES];$/;"	m	struct:state	access:public
tzname	timezone.c	/^char *tzname[2];$/;"	v
tzset	timezone.c	/^void tzset()$/;"	f
u	trees.o	/^ELF/;"	v
uch	zip.h	/^typedef unsigned char uch;      \/* unsigned 8-bit value *\/$/;"	t
ucs4_char_from_utf8	fileio.c	/^long ucs4_char_from_utf8(utf8)$/;"	f
ucs4_string_to_utf8	fileio.c	/^local int ucs4_string_to_utf8(ucs4, utf8buf, buflen)$/;"	f
ulg	zip.h	/^typedef unsigned long ulg;      \/* unsigned 32-bit value *\/$/;"	t
uname	zip.h	/^  char *uname;                  \/* UTF-8 name *\/$/;"	m	struct:flist	access:public
uname	zip.h	/^  char *uname;                  \/* UTF-8 version of iname *\/$/;"	m	struct:zlist	access:public
unicode_escape_all	globals.c	/^int unicode_escape_all = 0; \/* 1=escape all non-ASCII characters in paths *\/$/;"	v
unicode_mismatch	globals.c	/^int unicode_mismatch = 1; \/* unicode mismatch is 0=error, 1=warn, 2=ignore, 3=no *\/$/;"	v
unix2dostime	fileio.c	/^ulg unix2dostime(t)$/;"	f
unzip	globals.o	/^/;"	v
unzip_path	zip.c	/^local char *unzip_path = NULL; \/* where to find unzip *\/$/;"	v
update_keys	crypt.h	58;"	d
updating	WHATSNEW	/^  system, adding updating, and deleting entries as needed.  This$/;"	v
updating	zip30f.ann	/^  files on the file system, adding, updating, and deleting entries as needed,$/;"	v
upper	util.c	/^uch upper[256], lower[256];$/;"	v
use_descriptors	globals.c	/^int use_descriptors = 0;      \/* 1=use data descriptors 12\/29\/04 *\/$/;"	v
use_wide_to_mb_default	globals.c	/^  int use_wide_to_mb_default = 0;$/;"	v
ush	zip.h	/^typedef unsigned short ush;     \/* unsigned 16-bit value *\/$/;"	t
using_utf8	globals.c	/^   int using_utf8 = 0;       \/* 1 if current character set UTF-8 *\/$/;"	v
usize	zip.h	/^  uzoff_t usize;                \/* usize from initial scan *\/$/;"	m	struct:flist	access:public
utf8_char_bytes	fileio.c	/^local int utf8_char_bytes(utf8)$/;"	f
utf8_force	globals.c	/^ int utf8_force = 0;    \/* 1=force storing UTF-8 as standard per AppNote bit 11 *\/$/;"	v
utf8_from_ucs4_char	fileio.c	/^local int utf8_from_ucs4_char(utf8buf, ch)$/;"	f
utf8_to_escape_string	fileio.c	/^char *utf8_to_escape_string(utf8_string)$/;"	f
utf8_to_local_string	fileio.c	/^char *utf8_to_local_string(utf8_string)$/;"	f
utf8_to_ucs4_string	fileio.c	/^local int utf8_to_ucs4_string(utf8, ucs4buf, buflen)$/;"	f
utf8_to_wide_string	fileio.c	/^zwchar *utf8_to_wide_string(utf8_string)$/;"	f
uzoff_t	tailor.h	/^    typedef unsigned long long uzoff_t;  \/* unsigned zoff_t (12\/29\/04 EG) *\/$/;"	t
uzoff_t	tailor.h	/^    typedef unsigned long uzoff_t;$/;"	t
uzoff_t	unix/osdep.h	/^  typedef unsigned long long uzoff_t;$/;"	t
uzoff_t	unix/osdep.h	/^  typedef unsigned long uzoff_t;$/;"	t
valloc	zipup.c	51;"	d	file:
value_type	zip.h	/^  int  value_type;          \/* from above *\/$/;"	m	struct:option_struct	access:public
vem	zip.h	/^  ush vem, ver, flg, how;$/;"	m	struct:zlist	access:public
ver	zip.h	/^  ush vem, ver, flg, how;$/;"	m	struct:zlist	access:public
verbose	globals.c	/^int verbose = 0;        \/* 1=report oddities in zip file structure *\/$/;"	v
versinfolines	revision.h	/^ZCONST char * far versinfolines[] = {$/;"	v
version_info	zip.c	/^local void version_info()$/;"	f
version_info	zipcloak.c	/^local void version_info()$/;"	f
version_info	zipnote.c	/^local void version_info()$/;"	f
version_info	zipsplit.c	/^local void version_info()$/;"	f
version_local	unix/unix.c	/^void version_local()$/;"	f
void	tailor.h	245;"	d
volume_label	globals.c	/^int volume_label = 0;         \/* add volume label *\/$/;"	v
wide_char_to_escape_string	fileio.c	/^char *wide_char_to_escape_string(wide_char)$/;"	f
wide_to_escape_string	fileio.c	/^char *wide_to_escape_string(wide_string)$/;"	f
wide_to_local_string	fileio.c	/^char *wide_to_local_string(wide_string)$/;"	f
wide_to_mb_default_string	zip.h	919;"	d
wide_to_utf8_string	fileio.c	/^char *wide_to_utf8_string(wide_string)$/;"	f
wild_stop_at_dir	globals.c	/^   int wild_stop_at_dir = 0; \/* default wildcards do include \/ in matches *\/$/;"	v
win32	CHANGES	/^ 3. Fix NTSD_EAS link time failures with win32 (Paul)$/;"	f
window	deflate.c	/^  uch    window[2L*WSIZE];$/;"	v
window	zipup.c	/^local uch *window = NULL;   \/* Used to read all input file at once *\/$/;"	v
window_size	deflate.c	/^ulg window_size;$/;"	v
window_size	zipup.c	/^local ulg window_size;      \/* size of said window *\/$/;"	v
with	zip.txt	/^       can have a value (option argument) specified by preceeding  it  with  =$/;"	v
with$	tags	/^systems	LICENSE	\/^       systems, existing ports with new graphical interfaces, versions with$\/;"	v$/;"	v
write_int64_to_mem	zipfile.c	/^local void write_int64_to_mem(l64Value,pPtr)$/;"	f
write_string_to_mem	zipfile.c	/^local void write_string_to_mem(strValue, pPtr)$/;"	f
write_ulong_to_mem	zipfile.c	/^local void write_ulong_to_mem(uValue, pPtr)$/;"	f
wuname	zip.h	/^  char *wuname;                 \/* Converted back ouname for Win32 *\/$/;"	m	struct:zlist	access:public
xample	WHATSNEW	/^  for example, and this approach creates archives that should be$/;"	v
xample	zip.txt	/^       Be aware that console windows on Win32 and Unix, for example, sometimes$/;"	v
xample	zip.txt	/^       between splits to allow changing removable media, for example, but read$/;"	v
xenix	INSTALL	/^     att6300, coherent, cray_v3, minix, sco_x286, xenix, zilog.$/;"	v
y	globals.c	/^FILE *y = NULL;               \/* output file now global so can change in splits *\/$/;"	v
year_lengths	timezone.c	/^static ZCONST int   year_lengths[2] = {$/;"	v	file:
yr_days	timezone.c	/^static ZCONST int    yr_days[2][MONSPERYEAR+1] = {$/;"	v	file:
z	zipfile.c	/^  char *z;                  \/* zip file comment if m != 0 *\/$/;"	v
z_stat	tailor.h	/^  typedef struct stat z_stat;$/;"	t	typeref:struct:stat
z_stat	unix/osdep.h	/^  typedef struct stat z_stat;$/;"	t	typeref:struct:stat
z_uint4	tailor.h	/^           typedef unsigned short   z_uint4;$/;"	t
z_uint4	tailor.h	/^         typedef unsigned long    z_uint4;$/;"	t
z_uint4	tailor.h	/^       typedef unsigned int     z_uint4;$/;"	t
z_uint4	tailor.h	/^  typedef ulg                z_uint4;$/;"	t
zbcmp	zipfile.c	/^local int zbcmp(n, z)$/;"	f
zcalloc	tailor.h	883;"	d
zcfree	tailor.h	885;"	d
zclose	unix/zipup.h	22;"	d
zcomlen	globals.c	/^ush zcomlen;                      \/* Length of zip file comment *\/$/;"	v
zcomment	globals.c	/^char *zcomment = NULL;            \/* Zip file comment (not zero-terminated) *\/$/;"	v
zcount	globals.c	/^extent zcount;                    \/* Number of files in zip file *\/$/;"	v
zdecode	crypt.h	71;"	d
zencode	crypt.h	68;"	d
zerr	unix/zipup.h	23;"	d
zfdopen	tailor.h	558;"	d
zfdopen	tailor.h	578;"	d
zfdopen	tailor.h	608;"	d
zfdopen	tailor.h	628;"	d
zfdopen	tailor.h	655;"	d
zfdopen	tailor.h	682;"	d
zfdopen	tailor.h	714;"	d
zfiles	globals.c	/^struct zlist far *zfiles = NULL;  \/* Pointer to list of files in zip file *\/$/;"	v	typeref:struct:far
zfopen	tailor.h	557;"	d
zfopen	tailor.h	577;"	d
zfopen	tailor.h	607;"	d
zfopen	tailor.h	627;"	d
zfopen	tailor.h	654;"	d
zfopen	tailor.h	681;"	d
zfopen	tailor.h	713;"	d
zfseeko	tailor.h	543;"	d
zfseeko	tailor.h	550;"	d
zfseeko	tailor.h	571;"	d
zfseeko	tailor.h	621;"	d
zfseeko	tailor.h	711;"	d
zfstat	tailor.h	538;"	d
zfstat	tailor.h	567;"	d
zfstat	tailor.h	595;"	d
zfstat	tailor.h	617;"	d
zfstat	tailor.h	642;"	d
zfstat	tailor.h	669;"	d
zfstat	tailor.h	709;"	d
zftello	tailor.h	546;"	d
zftello	tailor.h	553;"	d
zftello	tailor.h	574;"	d
zftello	tailor.h	624;"	d
zftello	tailor.h	712;"	d
zfwrite	crypt.c	/^unsigned zfwrite(buf, item_size, nb)$/;"	f
zgetline	zipnote.c	/^local char *zgetline(buf, size)$/;"	f
zip	unix/README.OS390	/^If GNU make is not available, the existing makefile can create zip, but will$/;"	v
zip64_archive	globals.c	/^  int zip64_archive = 0;      \/* if 1 then at least 1 entry needs zip64 *\/$/;"	v
zip64_entry	globals.c	/^  int zip64_entry = 0;        \/* current entry needs Zip64 *\/$/;"	v
zip64_eocd_disk	globals.c	/^ulg     zip64_eocd_disk = 0;      \/* disk with Zip64 End Of Central Directory Record *\/$/;"	v
zip64_eocd_offset	globals.c	/^uzoff_t zip64_eocd_offset = 0;    \/* offset for Zip64 EOCD Record *\/$/;"	v
zip_attributes	globals.c	/^int zip_attributes = 0;$/;"	v
zip_fuzofft	util.c	/^char *zip_fuzofft( val, pre, post)$/;"	f
zip_fzofft	util.c	/^char *zip_fzofft( val, pre, post)$/;"	f
zip_to_stdout	globals.c	/^int zip_to_stdout = 0;        \/* output zipfile to stdout 12\/30\/04 *\/$/;"	v
zipbare	crypt.c	/^int zipbare(z, passwd)$/;"	f
zipbeg	globals.c	/^uzoff_t zipbeg;               \/* Starting offset of zip structures *\/$/;"	v
zipcloak	README	/^Utilities.  At this point zipsplit, zipcloak, and zipnote should work with$/;"	v
zipcloak	README	/^and install zip, zipsplit, zipcloak, and zipnote and please read the manual$/;"	v
zipcloak	crypt.c	/^int zipcloak(z, passwd)$/;"	f
zipcopy	zipfile.c	/^int zipcopy(z)$/;"	f
zipedit	zip.c	/^local int zipedit = 0;  \/* 1=edit zip comment and all file comments *\/$/;"	v
ziperr	zip.c	/^void ziperr(c, h)$/;"	f
ziperr	zipcloak.c	/^void ziperr(c, h)$/;"	f
ziperr	zipcloak.c	/^void ziperr(code, msg)$/;"	f
ziperr	zipnote.c	/^void ziperr(c, h)$/;"	f
ziperr	zipnote.c	61;"	d	file:
ziperr	zipsplit.c	/^void ziperr(c, h)$/;"	f
ziperr	zipsplit.c	57;"	d	file:
ziperrors	ziperr.h	/^} ziperrors[ZE_MAXERR + 1] = {$/;"	v	typeref:struct:__anon1
zipfile	globals.c	/^char *zipfile;          \/* New or existing zip archive (zip file) *\/$/;"	v
zipfile_exists	globals.c	/^int zipfile_exists = 0;           \/* 1 if zipfile exists *\/$/;"	v
zipmessage	zip.c	/^void zipmessage(a, b)$/;"	f
zipmessage	zipcloak.c	/^void zipmessage(a, b)$/;"	f
zipmessage	zipnote.c	/^void zipmessage(a, b)$/;"	f
zipmessage	zipsplit.c	/^void zipmessage(a, b)$/;"	f
zipmessage_nl	zip.c	/^void zipmessage_nl(a, nl)$/;"	f
zipmessage_nl	zipcloak.c	/^void zipmessage_nl(a, nl)$/;"	f
zipmessage_nl	zipnote.c	/^void zipmessage_nl(a, nl)$/;"	f
zipmessage_nl	zipsplit.c	/^void zipmessage_nl(a, nl)$/;"	f
zipoddities	zipfile.c	/^local void zipoddities(z)$/;"	f
zipsmade	zipsplit.c	/^local int zipsmade = 0;         \/* number of zip files made *\/$/;"	v
zipsplit	README	/^and install zip, zipsplit, zipcloak, and zipnote and please read the manual$/;"	v
zipstatb	fileio.c	/^local z_stat zipstatb;             \/* now use z_stat globally - 7\/24\/04 EG *\/$/;"	v
zipstate	fileio.c	/^local int zipstate = -1;$/;"	v
zipstdout	zip.c	/^local void zipstdout()$/;"	f
ziptyp	zipfile.c	/^char *ziptyp(s)$/;"	f
zipup	zipup.c	/^int zipup(z)$/;"	f
zipwarn	zip.c	/^void zipwarn(a, b)$/;"	f
zipwarn	zipcloak.c	/^void zipwarn(msg1, msg2)$/;"	f
zipwarn	zipnote.c	/^void zipwarn(a, b)$/;"	f
zipwarn	zipnote.c	62;"	d	file:
zipwarn	zipsplit.c	/^void zipwarn(a, b)$/;"	f
zipwarn	zipsplit.c	58;"	d	file:
zl_deflate_free	zipup.c	/^void zl_deflate_free()$/;"	f
zl_deflate_init	zipup.c	/^local int zl_deflate_init(pack_level)$/;"	f
zlist	zip.h	/^struct zlist {$/;"	s
zlist::att	zip.h	/^  ush att, lflg;                \/* offset of lflg must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
zlist::atx	zip.h	/^  ulg atx;$/;"	m	struct:zlist	access:public
zlist::cext	zip.h	/^  ush nam, ext, cext, com;      \/* offset of ext must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
zlist::cextra	zip.h	/^  char *cextra;                 \/* Extra in central (set only if cext != 0) *\/$/;"	m	struct:zlist	access:public
zlist::com	zip.h	/^  ush nam, ext, cext, com;      \/* offset of ext must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
zlist::comment	zip.h	/^  char *comment;                \/* Comment (set only if com != 0) *\/$/;"	m	struct:zlist	access:public
zlist::crc	zip.h	/^  ulg tim, crc;$/;"	m	struct:zlist	access:public
zlist::current	zip.h	/^  int current;                  \/* Marker for files that are current to what is on OS (filesync) *\/$/;"	m	struct:zlist	access:public
zlist::dosflag	zip.h	/^  int dosflag;                  \/* Set to force MSDOS file attributes *\/$/;"	m	struct:zlist	access:public
zlist::dsk	zip.h	/^  ulg dsk;                      \/* disk number was ush but now ulg *\/$/;"	m	struct:zlist	access:public
zlist::ext	zip.h	/^  ush nam, ext, cext, com;      \/* offset of ext must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
zlist::extra	zip.h	/^  char *extra;                  \/* Extra field (set only if ext != 0) *\/$/;"	m	struct:zlist	access:public
zlist::flg	zip.h	/^  ush vem, ver, flg, how;$/;"	m	struct:zlist	access:public
zlist::how	zip.h	/^  ush vem, ver, flg, how;$/;"	m	struct:zlist	access:public
zlist::iname	zip.h	/^  char *iname;                  \/* Internal file name after cleanup (stored in archive) *\/$/;"	m	struct:zlist	access:public
zlist::inamew	zip.h	/^  wchar_t *inamew;              \/* Windows wide character version of iname *\/$/;"	m	struct:zlist	access:public
zlist::len	zip.h	/^  uzoff_t siz, len;             \/* zip64 support 08\/29\/2003 R.Nausedat *\/$/;"	m	struct:zlist	access:public
zlist::lflg	zip.h	/^  ush att, lflg;                \/* offset of lflg must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
zlist::mark	zip.h	/^  int mark;                     \/* Marker for files to operate on *\/$/;"	m	struct:zlist	access:public
zlist::nam	zip.h	/^  ush nam, ext, cext, com;      \/* offset of ext must be >= LOCHEAD *\/$/;"	m	struct:zlist	access:public
zlist::name	zip.h	/^  char *name;                   \/* File name in zip file *\/$/;"	m	struct:zlist	access:public
zlist::namew	zip.h	/^  wchar_t *namew;               \/* Windows wide character version of name *\/$/;"	m	struct:zlist	access:public
zlist::nxt	zip.h	/^  struct zlist far *nxt;        \/* Pointer to next header in list *\/$/;"	m	struct:zlist	typeref:struct:zlist::far	access:public
zlist::off	zip.h	/^  uzoff_t off;$/;"	m	struct:zlist	access:public
zlist::oname	zip.h	/^  char *oname;                  \/* Display version of name used in messages *\/$/;"	m	struct:zlist	access:public
zlist::ouname	zip.h	/^  char *ouname;                 \/* Display version of zuname *\/$/;"	m	struct:zlist	access:public
zlist::siz	zip.h	/^  uzoff_t siz, len;             \/* zip64 support 08\/29\/2003 R.Nausedat *\/$/;"	m	struct:zlist	access:public
zlist::tim	zip.h	/^  ulg tim, crc;$/;"	m	struct:zlist	access:public
zlist::trash	zip.h	/^  int trash;                    \/* Marker for files to delete *\/$/;"	m	struct:zlist	access:public
zlist::uname	zip.h	/^  char *uname;                  \/* UTF-8 version of iname *\/$/;"	m	struct:zlist	access:public
zlist::vem	zip.h	/^  ush vem, ver, flg, how;$/;"	m	struct:zlist	access:public
zlist::ver	zip.h	/^  ush vem, ver, flg, how;$/;"	m	struct:zlist	access:public
zlist::wuname	zip.h	/^  char *wuname;                 \/* Converted back ouname for Win32 *\/$/;"	m	struct:zlist	access:public
zlist::zname	zip.h	/^  char *zname;                  \/* External version of internal name *\/$/;"	m	struct:zlist	access:public
zlist::znamew	zip.h	/^  wchar_t *znamew;              \/* Windows wide character version of zname *\/$/;"	m	struct:zlist	access:public
zlist::zuname	zip.h	/^  char *zuname;                 \/* Escaped Unicode zname from uname *\/$/;"	m	struct:zlist	access:public
zlstat	tailor.h	539;"	d
zlstat	tailor.h	568;"	d
zlstat	tailor.h	596;"	d
zlstat	tailor.h	618;"	d
zlstat	tailor.h	643;"	d
zlstat	tailor.h	670;"	d
zlstat	tailor.h	710;"	d
zname	zip.h	/^  char *zname;                  \/* External version of internal name *\/$/;"	m	struct:flist	access:public
zname	zip.h	/^  char *zname;                  \/* External version of internal name *\/$/;"	m	struct:plist	access:public
zname	zip.h	/^  char *zname;                  \/* External version of internal name *\/$/;"	m	struct:zlist	access:public
znamew	zip.h	/^  wchar_t *znamew;              \/* Windows wide character version of zname *\/$/;"	m	struct:flist	access:public
znamew	zip.h	/^  wchar_t *znamew;              \/* Windows wide character version of zname *\/$/;"	m	struct:zlist	access:public
zoff_t	tailor.h	/^    typedef long zoff_t;$/;"	t
zoff_t	tailor.h	/^    typedef off_t zoff_t;$/;"	t
zoff_t	unix/osdep.h	/^  typedef long zoff_t;$/;"	t
zoff_t	unix/osdep.h	/^  typedef off_t zoff_t;$/;"	t
zopen	unix/zipup.h	20;"	d
zqcmp	zipfile.c	/^local int zqcmp(a, b)$/;"	f
zread	unix/zipup.h	21;"	d
zsearch	zipfile.c	/^struct zlist far *zsearch(n)$/;"	f
zsort	globals.c	/^struct zlist far **zsort;         \/* List of files sorted by name *\/$/;"	v	typeref:struct:far
zstat	tailor.h	537;"	d
zstat	tailor.h	566;"	d
zstat	tailor.h	589;"	d
zstat	tailor.h	616;"	d
zstat	tailor.h	636;"	d
zstat	tailor.h	663;"	d
zstat	tailor.h	708;"	d
zstdin	unix/zipup.h	24;"	d
zstrm	zipup.c	/^local z_stream zstrm;         \/* zlib's data interface structure *\/$/;"	v
ztimbuf	tailor.h	/^typedef struct ztimbuf {$/;"	s
ztimbuf	tailor.h	/^} ztimbuf;$/;"	t	typeref:struct:ztimbuf
ztimbuf::actime	tailor.h	/^    time_t actime;              \/* new access time *\/$/;"	m	struct:ztimbuf	access:public
ztimbuf::modtime	tailor.h	/^    time_t modtime;             \/* new modification time *\/$/;"	m	struct:ztimbuf	access:public
zubcmp	zipfile.c	/^local int zubcmp(n, z)$/;"	f
zuname	zip.h	/^  char *zuname;                 \/* Escaped Unicode zname from uname *\/$/;"	m	struct:zlist	access:public
zuqcmp	zipfile.c	/^local int zuqcmp(a, b)$/;"	f
zusort	globals.c	/^  struct zlist far **zusort;      \/* List of files sorted by zuname *\/$/;"	v	typeref:struct:far
zvoid	tailor.h	/^   typedef char zvoid;$/;"	t
zvoid	tailor.h	/^   typedef void zvoid;$/;"	t
zvoid	tailor.h	249;"	d
zw_stat	tailor.h	593;"	d
zw_stat	tailor.h	640;"	d
zw_stat	tailor.h	667;"	d
zw_stat	tailor.h	718;"	d
zwchar	zip.h	/^  typedef unsigned long zwchar;$/;"	t
zwchar_to_wchar_t_default_char	zip.h	916;"	d
zwfstat	tailor.h	591;"	d
zwfstat	tailor.h	638;"	d
zwfstat	tailor.h	665;"	d
zwfstat	tailor.h	716;"	d
zwstat	tailor.h	592;"	d
zwstat	tailor.h	639;"	d
zwstat	tailor.h	666;"	d
zwstat	tailor.h	717;"	d
